focal_method,test_prefix,docstring
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test0001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test0002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test0003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test0004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test0016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test0017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test0018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test0019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('Y', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('Y');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test00217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals(""t"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getNullString() {
    return nullString;
}","public void test00754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals(""$/G"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('F');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00971() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test01078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertEquals(""?"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test01079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertTrue(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test01080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator((String) null);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test01184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator(""$6\u0005i+`jwl"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test01287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertEquals('b', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test01288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test01295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""\u0085"");
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test013100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test013101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test013102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test013104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test013105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test014106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test014107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test014108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test014109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test014110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test014111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test014112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test014113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test015115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test015116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test016117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test016118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test016119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertEquals(""T"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test016120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test016121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test016123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test016124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf(']');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('T');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test017125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test017126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test017127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals(""|"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test017128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test017129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test017130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test017131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test017132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test017133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test017134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test018135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('Z');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test018136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('Z');
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test018137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('Z');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test018138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('Z');
    assertEquals(""Z"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test019139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test019140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test019141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test019143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test019144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test019145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test020146() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test020147() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test020148() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test020149() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test020150() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test020151() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test020152() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test020153() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('x');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test021154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test021155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test021156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test021157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test021158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test021159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test021160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test021161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test022162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test022163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test022164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test022165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test022166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test022167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test022168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test022169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test023170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test023171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test023172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test023173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals('O', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test023174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test023175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test023176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test023177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test023178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test023179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('O');
    Character character0 = new Character('~');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test024181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test024182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test024183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test024184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test024185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test024187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test024188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Character character1 = new Character('=');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test025189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test025190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test025191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test025192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test025193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test025194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test025196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test025197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test026198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test026200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test027201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test027202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test027203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test027204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test027205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test027206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test027207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test027208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test027209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('9');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('9');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test028210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test028211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals('_', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test028212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test028213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals('_', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test028214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test028215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test028216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test028217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test028218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('_');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test029219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test029220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test029221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertEquals('*', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test029222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test029223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertEquals('G', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test029224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test029225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertEquals('r', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test029226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test029227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test029228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('*');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test030229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test030230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals('_', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test030231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test030232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test031233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test031234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test031235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test031236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test031237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test031238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test031239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertEquals('9', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test031240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test031241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test031242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('9');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test032243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test032244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test032245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test032246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test032247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test032248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test032249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test032250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test032251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test033252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test033253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertEquals(""N(686|R}S{Y&2"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test033254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test033255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test033256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test033257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test033258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test033259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test033260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test033261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('5');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""N(686|R}S{Y&2"");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test034262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""i+GE6EAjjvqAW3"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test034263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""i+GE6EAjjvqAW3"");
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test034264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""i+GE6EAjjvqAW3"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test035265() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test035266() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test035267() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals(""krB-k'{"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test035268() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test035269() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test035270() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test035271() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test035272() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test035273() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test035274() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test036275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test036276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test036277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test036278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test036279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test036280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test036282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test036284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test036285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('~');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test037286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test037287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test037288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test037289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test037290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test037291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test037292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test037293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test037294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test038295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test038296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test038297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test038298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test038299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test038300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test039301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test039302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test039303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test039304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test039305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test039306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test039307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test039308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test039309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test039310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test039311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test039312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test040313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test040314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test040315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test040316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test040317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test040318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test040319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test040320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test040321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test041322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test041323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test041324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test041325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test041326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test041327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test041328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test041329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test041330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test041331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test041332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test042333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test042334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test042335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test042336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test042337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test042338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test042339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test043340() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test043341() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test043342() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test043343() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertEquals(""$VALUES"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test043344() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test043345() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test043346() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test043347() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test043348() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test043349() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""$VALUES"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test044350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test044351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test044352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test044353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test044354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test044355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test044356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test044357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test044358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test044359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test044360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test044361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertEquals('~', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test045362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test045363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test045364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test045365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test045366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test045367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test045368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test045369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test045370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test046371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test046372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test046373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test046374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test046375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test047376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test047377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test047378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test047379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test047380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test047381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test047382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test048383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test048384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test048385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertFalse(cSVFormat3.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test048386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test048387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test048388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test048389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test048390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test048391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test048392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test049393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test049394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test049395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test049396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test049397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals("") invalid parse sequence"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test049398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test049399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test049400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test049401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test049402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test049403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test049404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("") invalid parse sequence"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test050405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test050406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals('t', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test050407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test050408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test050409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test050410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test050411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test050412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test050413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('t');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test051414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test051415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test051416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test051417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test051418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test051419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test051420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test051421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test051422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test052423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test052424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test052425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertEquals('I', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test052426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test052427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test052428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test052429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test052430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test052431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('I');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test053432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test053433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test053434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test053435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test053436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test053437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test053438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals('\'', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test053439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test054440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test054441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test054442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test055443() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test055444() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test055445() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test055446() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(""lwi!f<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test055447() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test055448() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test055449() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test055450() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test055451() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test055452() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test055453() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test055454() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""lwi!f<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test056455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test056456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test056457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test056458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test056459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals('b', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test056460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test056461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test056462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test056463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test056464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test056465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test056466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('b');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test057467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test057468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test057470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test057471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test057473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test057474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test057475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test057476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test057477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test058478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test058479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test058480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test059481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test059482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test059483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test059484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test059485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test059486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test059487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test060488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getNullString() {
    return nullString;
}","public void test060489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test060490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test060491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test060492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test060493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test061494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test061495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test061496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test061497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test061498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test061499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test061500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test061502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test062503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test062504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test062505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test062506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test062507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test062508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test062509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test062510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test062511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test063512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test063513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test063514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test064515() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test064516() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(""format"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test064517() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test064518() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test064519() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test064520() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test064521() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test064522() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test064523() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test064524() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""format"");
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test065525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals('r', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test065526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test065527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test065528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test065529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test065530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test065531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test065532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test065533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test065534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test066535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test066536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test066537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test066538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test066539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test066540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test066541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test066542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test066543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test067544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String[] stringArray0 = new String[2];
    stringArray0[0] = """";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String[] stringArray0 = new String[2];
    stringArray0[0] = """";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test067546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String[] stringArray0 = new String[2];
    stringArray0[0] = """";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test068547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test068548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test068549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test069550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test069551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test069552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test069553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test069554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test069555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public String getNullString() {
    return nullString;
}","public void test069556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals(""t"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test069557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test069558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test070559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test070560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test070561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test070562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test070563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test071564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test071565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test071566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test071567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test071568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test071569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test071570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test071571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test072572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test072573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test072574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test073575() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test073576() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test073577() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test073578() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test073579() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test073580() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test073581() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test073582() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test073583() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getNullString() {
    return nullString;
}","public void test073584() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""krB-k'{"");
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals(""krB-k'{"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test074585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test074586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test075587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test075588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test075589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test075590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test075591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test075592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals('~', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test075593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test075594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test075595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test075596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('~');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test076597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test076598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test076599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test076600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test076601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test076602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test076603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test076604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test076605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test077606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test077607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test077608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test077609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test077610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test077611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test077612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test077613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test077614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test078615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test078616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test078617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test078618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test078619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test078620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test078621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test078622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test078623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('F', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test078624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    Character character0 = new Character('F');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""NONE"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test079625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test079626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test079627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test079628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test079629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertEquals(' ', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test079630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test079631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test079632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertEquals('|', (char) cSVFormat3.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test080633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test080634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test080635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test080636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test080637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test080638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test080639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test080640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(' ', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test080641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test081642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    Character character0 = new Character(')');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test081643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    Character character0 = new Character(')');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test081644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    Character character0 = new Character(')');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test082645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertEquals('z', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test082646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test082647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test082648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertEquals(""t"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test082649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test082650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test082651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test082652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test082653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test082654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('z');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test083655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test083656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test083657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test083658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test083659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertEquals('t', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test083660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test083661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test083662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertEquals('r', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test083663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertEquals('G', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test083664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('G');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('r');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('t');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test084665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test084666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test084667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertEquals('g', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test084668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertEquals('A', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test084669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test084670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test084671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test084672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test084673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('g');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('A');
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test085674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test085675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test085676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test085677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertEquals('O', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test085678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test085679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test085680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test085681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test085682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('O');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test086683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test086684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test086685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test086686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test086687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test086688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test086689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertEquals('9', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test086690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test086691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test086692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('9');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test087693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertEquals('U', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test087694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test087695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test087696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test087697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test087698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test087699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test087700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test087701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test088702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test088703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test088704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test088705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test088706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertEquals('S', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test088707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test088708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test088709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test088710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('S');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test089711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test089712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test089713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(""TDF"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test089714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test089715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test089716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test089717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test089718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    Character character0 = Character.valueOf('A');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test090719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test090720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test090721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test090722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test090723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test090724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test090725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test090726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test090727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker((Character) null);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test091728() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Character character0 = new Character('P');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test091729() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Character character0 = new Character('P');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test091730() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Character character0 = new Character('P');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test092731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test092732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test092733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test092734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertEquals('6', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test092735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test092736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test092737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test092738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test092739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('6');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test093740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test093741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test093742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertEquals('w', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test093743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test093744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test093745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test093746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test093747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test093748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test093749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('w');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test094750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test094751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test094752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test094753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertEquals('I', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test094754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test094755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test094756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test094757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test094758() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test094759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('I');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test095760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('4');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test095761() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('4');
    assertEquals('4', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test095762() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('4');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test095763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('4');
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test096764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test096765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test096766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test096767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test096768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test096769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test096770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test096771() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test096772() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test097773() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test097774() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertEquals(""-"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test097775() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test097776() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test097777() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test097778() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test097779() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test097780() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertEquals('$', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test097781() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat3.equals((Object) cSVFormat1));
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test097782() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test097783() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('$');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('-');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test098784() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test098785() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test098786() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test099787() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat4.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test099788() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat4.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test099789() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertEquals("""", cSVFormat4.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test099790() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat4.equals((Object) cSVFormat3));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test099791() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertEquals(""\r\n"", cSVFormat4.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test099792() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertEquals(';', cSVFormat4.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test099793() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test099794() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter(';');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test100795() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test100796() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test100797() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test100798() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test100799() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test100800() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('u');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test101801() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test101802() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test101803() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test101804() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test101805() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test101806() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test101807() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test101808() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test101809() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    Character character0 = new Character('F');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test102810() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test102811() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test102812() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test102813() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test102814() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test102815() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test102816() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test102817() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test102818() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test102819() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test103820() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test103821() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test103822() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test103823() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test103824() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertEquals('0', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test103825() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test104826() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test104827() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test104828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test104829() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test104830() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertEquals('|', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test104831() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test104832() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test104833() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test104834() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test104835() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('|');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test105836() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test105837() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertEquals(')', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test105838() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test105839() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test105840() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test105841() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(')');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test106842() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test106843() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test106844() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test106845() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertEquals('D', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test106846() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test106847() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('D');
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test107848() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertEquals('E', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test107849() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test107850() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test107851() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test107852() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test107853() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test108854() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test108855() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test108856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test108857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test108858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test108859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test108860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""TDF"", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test108861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test108862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test108863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""TDF"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test109864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test109865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals("""", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test109866() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test109867() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test109868() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test109869() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test109870() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test109871() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test109872() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test109873() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test110874() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test110875() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test110876() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test110877() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test110878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test110879() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test110880() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test110881() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test110882() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test111883() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test111884() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test111885() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test112886() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test113887() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[3];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    cSVFormat1.getHeaderComments();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test113888() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[3];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    cSVFormat1.getHeaderComments();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test113889() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[3];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    cSVFormat1.getHeaderComments();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test114890() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertEquals('\\', (char) character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test115891() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    char char0 = cSVFormat0.getDelimiter();
    assertEquals(',', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test116892() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test116893() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test116894() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test116895() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test116896() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('4', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test116897() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('4');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test117898() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test117899() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test117900() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test117901() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test117902() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test117903() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test117904() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('w');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test118905() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test118906() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test118907() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test118908() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test118909() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test118910() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertTrue(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test118911() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test118912() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test118913() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {
    return withHeader(resultSet != null ? resultSet.getMetaData() : null);
}","public void test119914() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ResultSetMetaData resultSetMetaData0 = mock(ResultSetMetaData.class, new ViolatedAssumptionAnswer());
    doReturn((-3419)).when(resultSetMetaData0).getColumnCount();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(resultSetMetaData0).when(resultSet0).getMetaData();
    // Undeclared exception!
    try {
        cSVFormat0.EXCEL.withHeader(resultSet0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the header of the format. The header can either be parsed automatically from the input file with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader();
 * </pre>
 *
 * or specified manually with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader(resultSet);
 * </pre>
 * <p>
 * The header is also used by the {@link CSVPrinter}..
 * </p>
 *
 * @param resultSet
 *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified
 *            otherwise.
 *
 * @return A new CSVFormat that is equal to this but with the specified header
 * @throws SQLException
 *             SQLException if a database access error occurs or this method is called on a closed result set.
 * @since 1.1
 */"
"public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {
    return withHeader(resultSet != null ? resultSet.getMetaData() : null);
}","public void test120915() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ResultSetMetaData resultSetMetaData0 = mock(ResultSetMetaData.class, new ViolatedAssumptionAnswer());
    doReturn(477).when(resultSetMetaData0).getColumnCount();
    doReturn((String) null, (String) null, (String) null, (String) null, (String) null).when(resultSetMetaData0).getColumnLabel(anyInt());
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(resultSetMetaData0).when(resultSet0).getMetaData();
    // Undeclared exception!
    try {
        cSVFormat0.EXCEL.withHeader(resultSet0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The header contains a duplicate entry: 'null' in [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the header of the format. The header can either be parsed automatically from the input file with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader();
 * </pre>
 *
 * or specified manually with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader(resultSet);
 * </pre>
 * <p>
 * The header is also used by the {@link CSVPrinter}..
 * </p>
 *
 * @param resultSet
 *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified
 *            otherwise.
 *
 * @return A new CSVFormat that is equal to this but with the specified header
 * @throws SQLException
 *             SQLException if a database access error occurs or this method is called on a closed result set.
 * @since 1.1
 */"
"public CSVFormat withEscape(final Character escape) {
    if (isLineBreak(escape)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);
}","public void test121916() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('P');
    Character character0 = new Character('P');
    // Undeclared exception!
    try {
        cSVFormat0.withEscape(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The escape character and the delimiter cannot be the same ('P')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the escape character of the format to the specified character.
 *
 * @param escape
 *            the escape character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);
}","public void test122917() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('O');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withCommentMarker(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('O')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the comment start marker of the format to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker, use {@code null} to disable
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test123918() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.MYSQL.print((Appendable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'out' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output
 * @return a printer to an output
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test124919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.parse((Reader) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test125920() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    PipedReader pipedReader0 = new PipedReader();
    try {
        cSVFormat1.parse(pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test126921() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.format((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public CSVFormat withDelimiter(final char delimiter) {
    if (isLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);
}","public void test127922() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('E');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withDelimiter('E');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('E')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the delimiter of the format to the specified character.
 *
 * @param delimiter
 *            the delimiter character
 * @return A new CSVFormat that is equal to this with the specified character as delimiter
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test128923() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isQuoteCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test129924() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test129925() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test129926() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test129927() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test129928() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertEquals('E', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test129929() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('E');
    cSVFormat0.isQuoteCharacterSet();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test130930() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test130931() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test130932() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test130933() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test130934() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test130935() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertEquals(""S9!tjmt06ctf:57#Z"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test130936() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test130937() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""S9!tjmt06ctf:57#Z"");
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat2.isNullStringSet();
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test131938() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isNullStringSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test132939() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test133940() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test134941() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test134942() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test134943() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test134944() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test134945() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test134946() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test134947() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test134948() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test134949() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test134950() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test135951() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isCommentMarkerSet();
    assertFalse(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public String[] getHeaderComments() {
    return headerComments != null ? headerComments.clone() : null;
}","public void test136952() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = cSVFormat0.getHeaderComments();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header comment array.
 *
 * @return a copy of the header comment array; {@code null} if disabled.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test137953() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test137954() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test137955() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test137956() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test137957() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test137958() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test137959() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test137960() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test137961() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test138962() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = cSVFormat0.getHeader();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file
 */"
"public QuoteMode getQuoteMode() {
    return quoteMode;
}","public void test139963() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    cSVFormat0.getQuoteMode();
}","/**
 * Returns the quote policy output fields.
 *
 * @return the quote policy
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test140964() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test141965() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getSkipHeaderRecord();
    assertFalse(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test142966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertFalse(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test143967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test143968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test143969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test143970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test143971() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test143972() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test143973() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test143974() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test143975() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test144976() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = cSVFormat0.getCommentMarker();
    assertNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test145977() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getNullString();
    assertNull(string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test146978() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test147979() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertTrue(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test148980() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getRecordSeparator();
    assertEquals(""\r\n"", string0);
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test149981() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getIgnoreHeaderCase();
    assertFalse(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test150982() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test150983() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test150984() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test151985() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('w', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test151986() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test151987() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test151988() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test151989() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test151990() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {
    return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);
}","public void test153992() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NONE;
    // Undeclared exception!
    try {
        cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No quotes mode set but no escape character is set
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the output quote policy of the format to the specified value.
 *
 * @param quoteModePolicy
 *            the quote policy to use for output.
 *
 * @return A new CSVFormat that is equal to this but with the specified quote policy
 */"
"public CSVFormat withEscape(final char escape) {
    return withEscape(Character.valueOf(escape));
}","public void test154993() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    // Undeclared exception!
    try {
        cSVFormat1.withEscape('(');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('(')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the escape character of the format to the specified character.
 *
 * @param escape
 *            the escape character
 * @return A new CSVFormat that is equal to his but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final Character quoteChar) {
    if (isLineBreak(quoteChar)) {
        throw new IllegalArgumentException(""The quoteChar cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);
}","public void test155994() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    Character character0 = Character.valueOf('6');
    // Undeclared exception!
    try {
        cSVFormat1.withQuote(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('6')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the quoteChar of the format to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final char commentMarker) {
    return withCommentMarker(Character.valueOf(commentMarker));
}","public void test156995() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    // Undeclared exception!
    try {
        cSVFormat0.withCommentMarker('w');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the delimiter cannot be the same ('w')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the comment start marker of the format to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final char quoteChar) {
    return withQuote(Character.valueOf(quoteChar));
}","public void test157996() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(')');
    // Undeclared exception!
    try {
        cSVFormat1.withQuote(')');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same (')')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the quoteChar of the format to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test158997() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test158998() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false Header:[]"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test159999() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test1591000() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> SkipHeaderRecord:false HeaderComments:[null, null]"", string0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1601001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    String string0 = cSVFormat2.toString();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1601002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    String string0 = cSVFormat2.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test1601003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('0');
    String string0 = cSVFormat2.toString();
    assertEquals(""Delimiter=<,> Escape=<0> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored IgnoreHeaderCase:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1611004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test1611005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<q> SkipHeaderRecord:false"", string0);
}",""
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test1621006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""i+GE6EAjjvqAW3"");
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> NullString=<i+GE6EAjjvqAW3> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1621007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""i+GE6EAjjvqAW3"");
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1631008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    assertFalse(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1631009() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1631010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1631011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1631012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1631013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertEquals('w', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1631014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1631015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    Object[] objectArray0 = new Object[4];
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test1641016() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> CommentStart=<!> RecordSeparator=<\r\n> SkipHeaderRecord:false"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1641017() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    String string0 = cSVFormat1.toString();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1651018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('0');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1651019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('0');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1651020() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('0');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1651021() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('0');
    cSVFormat0.hashCode();
    assertEquals('0', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1651022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('0');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1661023() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1661024() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1661025() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1661026() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1661027() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1661028() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1671029() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1671030() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1671031() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreHeaderCase ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test1681032() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    cSVFormat0.TDF.hashCode();
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1691033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    cSVFormat1.hashCode();
    assertEquals('|', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1691034() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1691035() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1691036() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('|');
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreHeaderCase ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test1701037() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    cSVFormat0.MYSQL.hashCode();
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1711038() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1711039() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1721040() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1721041() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1721042() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1721043() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1721044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1721045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1721046() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    cSVFormat2.getHeaderComments();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1731047() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1731048() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1731049() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1731050() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('w', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1731051() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1731052() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('w');
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1741053() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1741054() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1741055() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1741056() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1741057() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1741058() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1741059() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1741060() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1741061() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1751062() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1751063() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1751064() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1751065() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1751066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1751067() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1751068() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1751069() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1751070() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""63msK\""sU`@JH@kw8"";
    stringArray0[1] = ""L,d3z4N*9<"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1761071() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1761072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1761073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1761074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1761075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertEquals(""?"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1761076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test1761077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('?');
    cSVFormat2.equals(cSVFormat1);
    assertEquals(""$/G"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1771078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1771079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1771080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1771081() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1771082() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1771083() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1771084() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1771085() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1771086() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$/G"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat0.equals(cSVFormat2);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1781087() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1781088() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1781089() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1781090() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1781091() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test1781092() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1781093() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1781094() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('!', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1781095() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1781096() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1791097() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1791098() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1791099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1791100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1791101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1791102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1791103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1791104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1791105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('?', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1791106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1791107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('?');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1801108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertTrue(boolean0);
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1801109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1801110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals('\'', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1801111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1801112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1801113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withDelimiter('\'');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1811114() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1811115() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1811116() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1811117() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1811118() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1811119() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1811120() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1811121() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1821122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1821123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1821124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1821125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('w', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1821126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1821127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1821128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1821129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1821130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1821131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1821132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('w');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1831133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.equals(""63msK\""sU`@JH@kw8"");
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test1841134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertEquals('!', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1841135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1841136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1841137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1841138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1841139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1841140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('!');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1851141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1861142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1861143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1861144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1871145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertFalse(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1881146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1881147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1881148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1881149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test1881150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""NONE"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1881151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1881152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1881153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1881154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1881155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""NONE"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1891156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1891157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1891158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1901159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1901160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1901161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""Excel"");
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1911162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1911163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertTrue(cSVFormat3.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test1911164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertEquals('j', cSVFormat4.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1911165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertTrue(cSVFormat4.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1911166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertTrue(cSVFormat3.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1911167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withHeader((ResultSet) null);
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('j');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1921168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1921169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1921170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1921171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1921172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1921173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1921174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1921175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1931176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1931177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1931178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1931179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1931180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1931181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertEquals('?', (char) cSVFormat3.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1931182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1931183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertEquals(""\r\n"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1931184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public String getNullString() {
    return nullString;
}","public void test1931185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertEquals(""$/G"", cSVFormat3.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1931186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""$/G"");
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('?');
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test1941187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockFileWriter mockFileWriter0 = new MockFileWriter("">Z%5F+:E"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    CSVPrinter cSVPrinter0 = cSVFormat0.DEFAULT.print(mockPrintWriter0);
    assertNotNull(cSVPrinter0);
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output
 * @return a printer to an output
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1951188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1951189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1951190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1951191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1951192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1951193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1951194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1951195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1951196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1951197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    PipedReader pipedReader0 = new PipedReader();
    cSVFormat1.parse(pipedReader0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test1961198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat0.format(objectArray0);
    assertEquals(""\""\"","", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
