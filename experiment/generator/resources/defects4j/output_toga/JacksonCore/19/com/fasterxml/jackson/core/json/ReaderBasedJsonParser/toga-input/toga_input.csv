focal_method,test_prefix,docstring
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test0000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2181, (-2966), false);
    try {
        readerBasedJsonParser0._reportInvalidToken("""", """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000009; line: 1, column: -784]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, Native Ids (type, object)
    /**********************************************************
     */
/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 * <p>
 *  Default implementation returns true; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */
public boolean canReadObjectId() {
    return false;
}","public void test0011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""p_t+Z5."", false);
    StringReader stringReader0 = new StringReader(""N9v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 53, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    assertFalse(readerBasedJsonParser0.canReadObjectId());
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test0022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""was expecting a colon to separate field name and value"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000010; line: 1, column: 60]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test0033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""#{JavKs!AIJv(cvN"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 114, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(1718);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\u06B6' (code 1718 / 0x6b6)): was expecting double-quote to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000011; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test0044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""x|R!R5YnYXU%cz3uk "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000012; line: 1, column: 37]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test0055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2863, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1629, 3, false);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: UNKNOWN; line: 1, column: 1633]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test0066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""No digit following minus sign"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 410, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 98, 0, false);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('N' (code 78)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000013; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test0077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""x|R!R5YnYXU%cz3uk "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'x': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000014; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenLineNr() {
    return _tokenInputRow;
}","public void test0088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""E4&OL`r@"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2095), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._closeInput();
    assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{SPa0Upf-4=\""dp'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, false);
    readerBasedJsonParser0._handleApos();
    readerBasedJsonParser0.nextFieldName((SerializableString) null);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test01010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""S"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    byte[] byteArray0 = new byte[4];
    ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
    CharBuffer charBuffer0 = byteBuffer0.asCharBuffer();
    stringReader0.read(charBuffer0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1818, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-2001), false);
    readerBasedJsonParser0.nextLongValue(0);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test01111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, (-1664), false);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertFalse(boolean0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test01212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""\""Na [AVw_`e-v 6If"", true);
    StringReader stringReader0 = new StringReader(""m2g"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2, true);
    String string0 = readerBasedJsonParser0.getValueAsString((String) null);
    assertNull(string0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test01313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString("""");
    assertEquals("""", string0);
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""%eq=-#$> K%q5"", false);
    StringReader stringReader0 = new StringReader(""%eq=-#$> K%q5"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 108, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0.getNextChar((String) null);
    assertEquals('%', char0);
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""0123456789ABCDEF"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 57, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 39, 0, false);
    char char0 = readerBasedJsonParser0.getNextChar(""0123456789ABCDEF"");
    assertEquals('0', char0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test01616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    readerBasedJsonParser0.getInputSource();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"public int getColumnNr() {
    return _columnNr;
}","public void test01717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""exM*tBz6;Ush"", false);
    StringReader stringReader0 = new StringReader(""cg5J<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(3, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test01718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""exM*tBz6;Ush"", false);
    StringReader stringReader0 = new StringReader(""cg5J<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(2L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test01719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""exM*tBz6;Ush"", false);
    StringReader stringReader0 = new StringReader(""cg5J<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test01720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""exM*tBz6;Ush"", false);
    StringReader stringReader0 = new StringReader(""cg5J<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test01821() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-464L), jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test01822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test01823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test01824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-463), jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test01925() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Illegal character '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals(""{"", string0);
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test02026() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", true);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 42, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test02127() throws Throwable {
    StringReader stringReader0 = new StringReader(""C"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 97, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-1658), 33, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1658
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02228() throws Throwable {
    TextBuffer textBuffer0 = mock(TextBuffer.class, new ViolatedAssumptionAnswer());
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn(textBuffer0).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""d-Ab, s&(&"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02329() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, false);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02430() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextLongValue(1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02531() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""END_OBJECT"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1077, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue((-767L));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'END_OBJECT': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 21]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test02632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextIntValue((-93));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test02733() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""PUbu!sgUHcd,"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    IOContext iOContext0 = new IOContext(bufferRecycler0, jsonToken0, true);
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-3089), 33, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextIntValue((-1507));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3089
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test02834() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.BufferRecycler"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 93, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'com': was expecting ('true', 'false' or 'null')
        //  at [Source: java.io.StringReader@0000000016; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test02935() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{SPa0Upf-4=\""dp'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    iOContext0.allocTokenBuffer((-831));
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    readerBasedJsonParser0._handleApos();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Trying to release buffer not owned by the context
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test03036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""ucw1hC>t"");
    stringReader0.close();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    SerializedString serializedString0 = new SerializedString(""ALLOW_UNQUOTED_FIELD_NAMES"");
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test03137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 44, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 241, 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test03238() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", true);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 42, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test03339() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("">"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 52, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-3451), 3434, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3451
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test03440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""0aT|;,"");
    stringReader0.close();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test03541() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("")f"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-643), stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2000, 76, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.loadMore();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test03642() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 80, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar(""^/w6!AHT|_?9\""HS"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test03743() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""$g2F .-q-"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test03844() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    charArray0[2] = 'Z';
    charArray0[3] = 'o';
    charArray0[4] = 'M';
    charArray0[5] = '^';
    charArray0[6] = 'u';
    charArray0[7] = 'y';
    charArray0[8] = '~';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 102, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test03945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Unexpected end-of-input within/between "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 37, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 37, 0, true);
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test04046() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""Expected space separating root-level values"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1628), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken((String) null, ""Expected space separating root-level values"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test04147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("") in base64 content"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1833), 3, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken("") in base64 content"", "") in base64 content"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1833
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test04248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "" entries"", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken("" entries"", "" entries"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test04349() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""AGA>WK6e]DB"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test04450() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, false);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.ByteArrayBuilder"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-4584), (-3406), false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken("""");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -4584
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test04551() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Sr@Z0NMVAHrq!5$"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    stringReader0.close();
    try {
        readerBasedJsonParser0._reportInvalidToken(""Sr@Z0NMVAHrq!5$"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"@Override
protected void _releaseBuffers() throws IOException {
    super._releaseBuffers();
    // merge new symbols, if any
    _symbols.release();
    // and release buffers, if they are recyclable ones
    if (_bufferRecyclable) {
        char[] buf = _inputBuffer;
        if (buf != null) {
            _inputBuffer = null;
            _ioContext.releaseTokenBuffer(buf);
        }
    }
}","public void test04652() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._releaseBuffers();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}","/**
 * Method called to release internal buffers owned by the base
 * reader. This may be called along with {@link #_closeInput} (for
 * example, when explicitly closing this reader instance), or
 * separately (if need be).
 */"
"@Override
protected void _releaseBuffers() throws IOException {
    super._releaseBuffers();
    // merge new symbols, if any
    _symbols.release();
    // and release buffers, if they are recyclable ones
    if (_bufferRecyclable) {
        char[] buf = _inputBuffer;
        if (buf != null) {
            _inputBuffer = null;
            _ioContext.releaseTokenBuffer(buf);
        }
    }
}","public void test04753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""]LaKF/X[ 7ir8a|h\"""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    iOContext0.allocTokenBuffer();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-791), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-2395), true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._releaseBuffers();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Trying to release buffer not owned by the context
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}","/**
 * Method called to release internal buffers owned by the base
 * reader. This may be called along with {@link #_closeInput} (for
 * example, when explicitly closing this reader instance), or
 * separately (if need be).
 */"
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test04854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""ALLOW_UNQUOTED_CONTROL_CHARS"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parsePosNumber(2574);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test04955() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""': expected '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 612, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test05056() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-1677), 33, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1677
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test05157() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""9SxjiGjL){%"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test05258() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Unrecognized token '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 2, false);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test05359() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test05460() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2774, 2, true);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test05561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", true);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 123, 1583, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""No native support for writing Object Ids"", 1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test05662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""Leading zeroes not allowed"");
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-250), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1049), 1359, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""Leading zeroes not allowed"", 91);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1049
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test05763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    stringReader0.close();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, (-651), true);
    try {
        readerBasedJsonParser0._matchToken("""", (-1628));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test05864() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""c4M`oY="", true);
    StringReader stringReader0 = new StringReader(""Unexpected end-of-input within/between "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 262111, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 50, (-1628), false);
    try {
        readerBasedJsonParser0._matchToken(""Unexpected end-of-input within/between "", 3);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'UneUnexpected': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000017; line: 1, column: -1617]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected JsonToken _handleOddValue(int i) throws IOException {
    // Most likely an error, unless we are to allow single-quote-strings
    switch(i) {
        case '\'':
            /* [JACKSON-173]: allow single quotes. Unlike with regular
             * Strings, we'll eagerly parse contents; this so that there's
             * no need to store information on quote char used.
             *
             * Also, no separation to fast/slow parsing; we'll just do
             * one regular (~= slowish) parsing, to keep code simple
             */
            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
                return _handleApos();
            }
            break;
        case 'N':
            _matchToken(""NaN"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""NaN"", Double.NaN);
            }
            _reportError(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case 'I':
            _matchToken(""Infinity"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""Infinity"", Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case // note: '-' is taken as number
        '+':
            if (_inputPtr >= _inputEnd) {
                if (!loadMore()) {
                    _reportInvalidEOFInValue();
                }
            }
            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);
    }
    // [Issue#77] Try to decode most likely token
    if (Character.isJavaIdentifierStart(i)) {
        _reportInvalidToken("""" + ((char) i), ""('true', 'false' or 'null')"");
    }
    // but if it doesn't look like a token:
    _reportUnexpectedChar(i, ""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    return null;
}","public void test05965() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader("": expected close marker for "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 52, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-488), true);
    try {
        readerBasedJsonParser0._handleOddValue(2);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 2)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method for handling cases where first non-space character
 * of an expected value token is not legal for standard JSON content.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test06066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Pbyz7~!Ld0!"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-707), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 5, 1092, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleOddName((-3366));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3366
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {
    if (ch == 'I') {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOFInValue();
            }
        }
        ch = _inputBuffer[_inputPtr++];
        if (ch == 'N') {
            String match = negative ? ""-INF"" : ""+INF"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        } else if (ch == 'n') {
            String match = negative ? ""-Infinity"" : ""+Infinity"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        }
    }
    reportUnexpectedNumberChar(ch, ""expected digit (0-9) to follow minus sign, for valid numeric value"");
    return null;
}","public void test06167() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""}"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 278, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleInvalidNumberStart(0, false);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000018; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called if expected numeric value (due to leading sign) does not
 * look like a number
 */"
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test06268() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test06369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""LONG"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1659, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2), 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test06470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-18), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test06571() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 3, 1491, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test06672() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 4306, 3471, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test06773() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""u0SEW x@'eK&^kn"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test07177() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2371), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Base method defs, overrides
    /**********************************************************
     */
@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test07278() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(objectCodec0).toString();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 224, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = readerBasedJsonParser0.getCodec();
    assertSame(objectCodec1, objectCodec0);
}",""
"public int getLineNr() {
    return _lineNr;
}","public void test07379() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test07380() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test07381() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(0L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test07382() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test07483() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test07484() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals((-1L), jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test07485() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals(0, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test07486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 200, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test07587() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""JSON"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken("""", 7);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test07688() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""c4M`oY="", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 262144, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 50, (-1628), false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken("""", 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test07789() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2345, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1583, (-1072), false);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: UNKNOWN; line: 1, column: 512]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test07890() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""fIQW_s"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('\f', char0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test07991() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""l}pT@=^i#iE7\""4(ELY"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, (-1705), (-1705), false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test08092() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.BufferRecycler"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 93, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertTrue(boolean0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test08093() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.BufferRecycler"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 93, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('c', char0);
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test08194() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[6];
    charArray0[0] = ' ';
    charArray0[1] = 'T';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2843, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2843, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 6
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test08295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[6];
    charArray0[0] = ' ';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2843, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2843, false);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test08396() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2843, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2843, false);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test08497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""CGJH~jCSix\""<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2751), 226, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2751
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test08598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""Leading zeroes not allowed"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.Object@0000000019; line: 1, column: 53]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test08699() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("": 3Pu}b<Sk2:aXr"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 5, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000020; line: 1, column: 31]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test087100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""f.5):l?YuDHA~"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2091), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.getNextChar(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000021; line: 1, column: 27]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test088101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", false);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 42, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test089102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (':' (code 58)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000022; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test090103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""ItgL7&BPR'If"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2282, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'ItgL7': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000023; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test091104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('!' (code 33)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: java.lang.String@0000000024; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test092105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe(39, """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: java.lang.String@0000000025; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test093106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._parseAposName();
    assertEquals("": was expecting closing "", string0);
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test094107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""8t9z*>z]*"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 51, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 2, true);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: UNKNOWN; line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test095108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Malformed numeric value '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-4066), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000026; line: 1, column: 51]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test096109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1100, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2323), 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2323
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test097110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""JF,RkA_3PQ}d65nKt6B"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = '{';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('{' (code 123)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000027; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test098111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    try {
        readerBasedJsonParser0._parsePosNumber(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): Expected space separating root-level values
        //  at [Source: java.lang.String@0000000028; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test099112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1165, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 1, true);
    try {
        readerBasedJsonParser0._parsePosNumber(3);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputNo digit following minus sign
        //  at [Source: java.lang.String@0000000029; line: 1, column: 34]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test100113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2371), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test101114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(33);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test101115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(33);
    assertEquals(33L, long0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test102116() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 984, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(2760);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test102117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 984, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(2760);
    assertEquals(2760, int0);
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test103118() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""8w1h>t"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    SerializedString serializedString0 = new SerializedString(""ALLOW_UNQUOTED_FIELD_NAMES"");
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('w' (code 119)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000030; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    // usually true
    if (_currToken == JsonToken.VALUE_STRING) {
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test104119() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    charArray0[0] = '\""';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    SerializedString serializedString0 = new SerializedString(""8=c|A'"");
    readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
    assertTrue(readerBasedJsonParser0.hasTextCharacters());
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test105120() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe((-1089), (String) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1089
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test106121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{SPa0Upf-4=\""dp'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    readerBasedJsonParser0._handleApos();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test107122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{SPa0Upf-4=\""dp'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    readerBasedJsonParser0.nextFieldName((SerializableString) null);
    assertEquals(2L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test108123() throws Throwable {
    StringReader stringReader0 = new StringReader(""fIQW_s"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1382), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'fIQW_s': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 13]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test109124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""0aT|;,"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('a' (code 97)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer@0000000031; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.clearAndGetParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test110125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""JF,RkA_3PQ}d65nKt6B"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000032; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    // usually true
    if (_currToken == JsonToken.VALUE_STRING) {
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test111126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    charArray0[0] = '\""';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    readerBasedJsonParser0.nextToken();
    assertTrue(readerBasedJsonParser0.hasTextCharacters());
}",""
"protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {
    int outputPtr = 0;
    final int outputEnd = buffer.length - 3;
    int outputCount = 0;
    while (true) {
        // first, we'll skip preceding white space, if any
        char ch;
        do {
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            ch = _inputBuffer[_inputPtr++];
        } while (ch <= INT_SPACE);
        int bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            // reached the end, fair and square?
            if (ch == '""') {
                break;
            }
            bits = _decodeBase64Escape(b64variant, ch, 0);
            if (bits < 0) {
                // white space to skip
                continue;
            }
        }
        // enough room? If not, flush
        if (outputPtr > outputEnd) {
            outputCount += outputPtr;
            out.write(buffer, 0, outputPtr);
            outputPtr = 0;
        }
        int decodedData = bits;
        // then second base64 char; can't get padding yet, nor ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            bits = _decodeBase64Escape(b64variant, ch, 1);
        }
        decodedData = (decodedData << 6) | bits;
        // third base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        // First branch: can get padding (-> 1 byte)
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 4;
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 2);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // Ok, must get padding
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                ch = _inputBuffer[_inputPtr++];
                if (!b64variant.usesPaddingChar(ch)) {
                    throw reportInvalidBase64Char(b64variant, ch, 3, ""expected padding character '"" + b64variant.getPaddingChar() + ""'"");
                }
                // Got 12 bits, only need 8, need to shift
                decodedData >>= 4;
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // Nope, 2 or 3 bytes
        decodedData = (decodedData << 6) | bits;
        // fourth and last base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 2;
                    buffer[outputPtr++] = (byte) (decodedData >> 8);
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 3);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                /* With padding we only get 2 bytes; but we have
                     * to shift it a bit so it is identical to triplet
                     * case with partial output.
                     * 3 chars gives 3x6 == 18 bits, of which 2 are
                     * dummies, need to discard:
                     */
                decodedData >>= 2;
                buffer[outputPtr++] = (byte) (decodedData >> 8);
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // otherwise, our triplet is now complete
        decodedData = (decodedData << 6) | bits;
        buffer[outputPtr++] = (byte) (decodedData >> 16);
        buffer[outputPtr++] = (byte) (decodedData >> 8);
        buffer[outputPtr++] = (byte) decodedData;
    }
    _tokenIncomplete = false;
    if (outputPtr > 0) {
        outputCount += outputPtr;
        out.write(buffer, 0, outputPtr);
    }
    return outputCount;
}","public void test112127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Decimal point not followed by a digit"", true);
    StringReader stringReader0 = new StringReader(""Leading zeroes not allowed"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 40, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._readBinary((Base64Variant) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"public int readBinaryValue(OutputStream out) throws IOException {
    return readBinaryValue(Base64Variants.getDefaultVariant(), out);
}","public void test113128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    try {
        readerBasedJsonParser0.readBinaryValue((OutputStream) byteArrayBuilder0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that can be used as an alternative to {@link #getBigIntegerValue()},
 * especially when value can be large. The main difference (beyond method
 * of returning content using {@link OutputStream} instead of as byte array)
 * is that content will NOT remain accessible after method returns: any content
 * processed will be consumed and is not buffered in any way. If caller needs
 * buffering, it has to implement it.
 *
 * @param out Output stream to use for passing decoded binary data
 *
 * @return Number of bytes that were decoded and written via {@link OutputStream}
 *
 * @since 2.1
 */"
"@Override
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {
        _reportError(""Current token ("" + _currToken + "") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"");
    }
    /* To ensure that we won't see inconsistent data, better clear up
         * state...
         */
    if (_tokenIncomplete) {
        try {
            _binaryValue = _decodeBase64(b64variant);
        } catch (IllegalArgumentException iae) {
            throw _constructError(""Failed to decode VALUE_STRING as base64 ("" + b64variant + ""): "" + iae.getMessage());
        }
        /* let's clear incomplete only now; allows for accessing other
             * textual content in error cases
             */
        _tokenIncomplete = false;
    } else {
        // may actually require conversion...
        if (_binaryValue == null) {
            @SuppressWarnings(""resource"")
            ByteArrayBuilder builder = _getByteArrayBuilder();
            _decodeBase64(getText(), builder, b64variant);
            _binaryValue = builder.toByteArray();
        }
    }
    return _binaryValue;
}","public void test114129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""$g2F .-q-"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.getBinaryValue((Base64Variant) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: java.lang.Object@0000000033; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test115130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("")f"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-643), stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2000, 76, true);
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test116131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""%eq=-#$> K%q5"", false);
    StringReader stringReader0 = new StringReader(""%eq=-#$> K%q5"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 108, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(0, int0);
}",""
"@Override
public final char[] getTextCharacters() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test117132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    char[] charArray1 = readerBasedJsonParser0.getTextCharacters();
    assertNull(charArray1);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test118133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test119134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertNull(string0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test120135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""E4&OL`r@"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2095), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString(""q"");
    assertNotNull(string0);
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(null);
}","public void test121137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString();
    assertNull(string0);
}",""
"/*
    /**********************************************************
    /* Public API, data access
    /**********************************************************
     */
/**
 * Method for accessing textual representation of the current event;
 * if no current event (before first call to {@link #nextToken}, or
 * after encountering end-of-input), returns null.
 * Method can be called for any event.
 */
@Override
public final String getText() throws IOException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return _getText2(t);
}","public void test122138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""]LaKF/X[ 7ir8a|h\"""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-791), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-2395), true);
    String string0 = readerBasedJsonParser0.getText();
    assertNull(string0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test123139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 10, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 51, 0, false);
    readerBasedJsonParser0.nextFieldName();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test124140() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2900, 33, true);
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 46]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test125141() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""': expected '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 612, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test126142() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", true);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 42, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar("":tJlpjcwY!cYj.ZQG"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test127143() throws Throwable {
    char[] charArray0 = new char[0];
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn(charArray0).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn(false).when(iOContext0).isResourceManaged();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(3);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test128144() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    readerBasedJsonParser0._releaseBuffers();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test129145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    StringWriter stringWriter0 = new StringWriter(268);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
    assertEquals(0, int0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test130146() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    StringWriter stringWriter0 = new StringWriter(33);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.StringWriter"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test131147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""u0SEW x@'eK&^kn"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2230, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'u0SEW': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000034; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    // usually true
    if (_currToken == JsonToken.VALUE_STRING) {
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test132148() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    readerBasedJsonParser0.setCodec(objectCodec1);
    assertFalse(readerBasedJsonParser0.hasTextCharacters());
}",""
"@Override
public Object getInputSource() {
    return _reader;
}","public void test133149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""No native support for writing Object Ids"", false);
    StringReader stringReader0 = new StringReader(""No native support for writing Object Ids"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 42, false);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertSame(stringReader0, object0);
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test134150() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken("""");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
