focal_method,test_prefix,docstring
"protected JsonToken _handleOddValue(int i) throws IOException {
    // Most likely an error, unless we are to allow single-quote-strings
    switch(i) {
        case '\'':
            /* [JACKSON-173]: allow single quotes. Unlike with regular
             * Strings, we'll eagerly parse contents; this so that there's
             * no need to store information on quote char used.
             *
             * Also, no separation to fast/slow parsing; we'll just do
             * one regular (~= slowish) parsing, to keep code simple
             */
            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
                return _handleApos();
            }
            break;
        case 'N':
            _matchToken(""NaN"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""NaN"", Double.NaN);
            }
            _reportError(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case 'I':
            _matchToken(""Infinity"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""Infinity"", Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case // note: '-' is taken as number
        '+':
            if (_inputPtr >= _inputEnd) {
                if (!loadMore()) {
                    _reportInvalidEOFInValue();
                }
            }
            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);
    }
    // [Issue#77] Try to decode most likely token
    if (Character.isJavaIdentifierStart(i)) {
        _reportInvalidToken("""" + ((char) i), ""('true', 'false' or 'null')"");
    }
    // but if it doesn't look like a token:
    _reportUnexpectedChar(i, ""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    return null;
}","public void test000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Illegal character (code 0x"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 73, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddValue(73);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'IIllegal': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000007; line: 1, column: 8]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method for handling cases where first non-space character
 * of an expected value token is not legal for standard JSON content.
 */"
"protected void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inputPtr = _inputPtr;
    int inputLen = _inputEnd;
    char[] inputBuffer = _inputBuffer;
    while (true) {
        if (inputPtr >= inputLen) {
            _inputPtr = inputPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inputPtr = _inputPtr;
            inputLen = _inputEnd;
        }
        char c = inputBuffer[inputPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inputPtr;
                c = _decodeEscaped();
                inputPtr = _inputPtr;
                inputLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inputPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inputPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""': was expecting "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000008; line: 1, column: 35]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000009; line: 1, column: 39]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""M%>[y:*%H"", false);
    StringReader stringReader0 = new StringReader(""M%>[y:*%H"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: java.lang.String@0000000010; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public long nextLongValue(long defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "":Uhxdjbv"", true);
    StringReader stringReader0 = new StringReader("":Uhxdjbv"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.read();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    char[] charArray0 = new char[7];
    stringReader0.read(charArray0);
    try {
        readerBasedJsonParser0.nextLongValue(777L);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 127)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: java.lang.String@0000000011; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* JsonParser impl
    /**********************************************************
     */
/**
 * Method that can be called to get the name associated with
 * the current event.
 */
@Override
public String getCurrentName() throws IOException, JsonParseException {
    // [JACKSON-395]: start markers require information from parent
    if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {
        JsonReadContext parent = _parsingContext.getParent();
        return parent.getCurrentName();
    }
    return _parsingContext.getCurrentName();
}","public void test055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""OBJECT"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._closeInput();
    assertNull(readerBasedJsonParser0.getCurrentName());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Failed to decode VALUE_STRING as bas,64 ("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ByteBuffer byteBuffer0 = ByteBuffer.allocateDirect(2000);
    CharBuffer charBuffer0 = byteBuffer0.asCharBuffer();
    stringReader0.read(charBuffer0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2848), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(0L);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1104, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertFalse(boolean0);
}",""
"// @since 2.1
@Override
public String getValueAsString(String defValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(defValue);
}","public void test088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""l9"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString((String) null);
    assertNull(string0);
}",""
"// @since 2.1
@Override
public String getValueAsString(String defValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(defValue);
}","public void test099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString("""");
    assertEquals("""", string0);
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test1010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("" zZBACc*"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2600), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0.getNextChar("" zZBACc*"");
    assertEquals(' ', char0);
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test1111() throws Throwable {
    StringReader stringReader0 = new StringReader(""0ew#"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, objectCodec0, true);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 58, stringReader0, objectCodec1, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0.getNextChar(""0ew#"");
    assertEquals('0', char0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2125, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    readerBasedJsonParser0.getInputSource();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"public boolean isNumeric() {
    return (this == VALUE_NUMBER_INT) || (this == VALUE_NUMBER_FLOAT);
}","public void test1313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.getNextChar(""uUW7Cq]lCp-"");
    JsonToken jsonToken0 = readerBasedJsonParser0._parseNumber(33);
    assertTrue(jsonToken0.isNumeric());
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test1414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 126, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._parseAposName();
    assertEquals(""Non-standard token "", string0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test1515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('4', char0);
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public JsonToken nextToken() throws IOException, JsonParseException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        if (i != INT_COMMA) {
            _reportUnexpectedChar(i, ""was expecting comma to separate "" + _parsingContext.getTypeDesc() + "" entries"");
        }
        i = _skipWS();
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = _parseName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipWS();
        if (i != INT_COLON) {
            _reportUnexpectedChar(i, ""was expecting a colon to separate field name and value"");
        }
        i = _skipWS();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchToken(""true"", 1);
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchToken(""false"", 1);
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchToken(""null"", 1);
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
        /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parseNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test1616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""NaN"", true);
    StringReader stringReader0 = new StringReader(""4Z6yB)PM{?>1Dj:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public long nextLongValue(long defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test1717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""': was expecting "");
    stringReader0.close();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public int nextIntValue(int defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test1818() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.TreeCodec"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextIntValue((-1659));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public int nextIntValue(int defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test1919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""g(nZ&kh(h0-QI="");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(9);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'g': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000012; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public Boolean nextBooleanValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    switch(nextToken()) {
        case VALUE_TRUE:
            return Boolean.TRUE;
        case VALUE_FALSE:
            return Boolean.FALSE;
        default:
            return null;
    }
}","public void test2020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1104, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test2121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "":Uhxdjbv"", false);
    StringReader stringReader0 = new StringReader("":Uhxdjbv"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.loadMore();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test2222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""m/Fby#QZC/nFa.Hvj_"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    stringReader0.close();
    try {
        readerBasedJsonParser0.loadMore();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test2323() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""i8z2/__"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 296, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar(""i8z2/__"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test2424() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    stringReader0.close();
    try {
        readerBasedJsonParser0.getNextChar(""uUW7Cq]lCp-"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"protected void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inputPtr = _inputPtr;
    int inputLen = _inputEnd;
    char[] inputBuffer = _inputBuffer;
    while (true) {
        if (inputPtr >= inputLen) {
            _inputPtr = inputPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inputPtr = _inputPtr;
            inputLen = _inputEnd;
        }
        char c = inputBuffer[inputPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inputPtr;
                c = _decodeEscaped();
                inputPtr = _inputPtr;
                inputLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inputPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inputPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test2525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""i8z2/__"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 296, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "");
}","public void test2626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""rt?jlWqx_x_~"", true);
    StringReader stringReader0 = new StringReader(""rt?jlWqx_x_~"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken((String) null, ""rt?jlWqx_x_~"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "");
}","public void test2727() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader(""$h$"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 102, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken(""_Idvf k"", ""$h$"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '_Idvf k$h$': was expecting
        //  at [Source: UNKNOWN; line: 1, column: 7]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected JsonToken _parseNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    boolean negative = (ch == INT_MINUS);
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    dummy_loop: do {
        // dummy loop, to be able to break out
        if (negative) {
            // need to read the next digit
            if (ptr >= _inputEnd) {
                break dummy_loop;
            }
            ch = _inputBuffer[ptr++];
            // First check: must have a digit to follow minus sign
            if (ch > INT_9 || ch < INT_0) {
                _inputPtr = ptr;
                return _handleInvalidNumberStart(ch, true);
            }
            /* (note: has been checked for non-negative already, in
                 * the dispatching code that determined it should be
                 * a numeric value)
                 */
        }
        // One special case, leading zero(es):
        if (ch == INT_0) {
            break dummy_loop;
        }
        /* First, let's see if the whole number is contained within
             * the input buffer unsplit. This should be the common case;
             * and to simplify processing, we will just reparse contents
             * in the alternative case (number split on buffer boundary)
             */
        // already got one
        int intLen = 1;
        // First let's get the obligatory integer part:
        int_loop: while (true) {
            if (ptr >= _inputEnd) {
                break dummy_loop;
            }
            ch = (int) _inputBuffer[ptr++];
            if (ch < INT_0 || ch > INT_9) {
                break int_loop;
            }
            ++intLen;
        }
        int fractLen = 0;
        // And then see if we get other parts
        if (ch == '.') {
            // yes, fraction
            fract_loop: while (true) {
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
                if (ch < INT_0 || ch > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(ch, ""Decimal point not followed by a digit"");
            }
        }
        int expLen = 0;
        if (ch == 'e' || ch == 'E') {
            // and/or exponent
            if (ptr >= inputLen) {
                break dummy_loop;
            }
            // Sign indicator?
            ch = (int) _inputBuffer[ptr++];
            if (ch == INT_MINUS || ch == INT_PLUS) {
                // yup, skip for now
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            while (ch <= INT_9 && ch >= INT_0) {
                ++expLen;
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(ch, ""Exponent indicator not followed by a digit"");
            }
        }
        // Got it all: let's add to text buffer for parsing, access
        // need to push back following separator
        --ptr;
        _inputPtr = ptr;
        // As per #105, need separating space between root values; check here
        int len = ptr - startPtr;
        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
        return reset(negative, intLen, fractLen, expLen);
    } while (false);
    _inputPtr = negative ? (startPtr + 1) : startPtr;
    return _parseNumber2(negative);
}","public void test2828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextIntValue(593);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseNumber(660);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// caller had pushed it back, before calling; reset
/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected String _parseName(int i) throws IOException {
    if (i != INT_QUOTE) {
        return _handleOddName(i);
    }
    /* First: let's try to see if we have a simple name: one that does
         * not cross input buffer boundary, and does not contain escape
         * sequences.
         */
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    int start = _inputPtr;
                    // to skip the quote
                    _inputPtr = ptr + 1;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test2929() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2105), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseName(2000);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\u07D0' (code 2000 / 0x7d0)): was expecting double-quote to start field name
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 *  Method called to ensure that a root-value is followed by a space
 *  token.
 * <p>
 *  NOTE: caller MUST ensure there is at least one character available;
 *  and that input pointer is AT given char (not past)
 */"
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test3030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader(""+brY,WVp0pa,'b"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2125, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test3131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Infinity"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken((String) null, 2000);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test3232() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2099), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleOddName((-2099));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2099
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test3333() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(127);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {
    if (ch == 'I') {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOFInValue();
            }
        }
        ch = _inputBuffer[_inputPtr++];
        if (ch == 'N') {
            String match = negative ? ""-INF"" : ""+INF"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        } else if (ch == 'n') {
            String match = negative ? ""-Infinity"" : ""+Infinity"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        }
    }
    reportUnexpectedNumberChar(ch, ""expected digit (0-9) to follow minus sign, for valid numeric value"");
    return null;
}","public void test3434() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""FLOAT"", false);
    StringReader stringReader0 = new StringReader(""{EuF,"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleInvalidNumberStart(43, true);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('+' (code 43)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: java.lang.String@0000000013; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called if expected numeric value (due to leading sign) does not
 * look like a number
 */"
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test3535() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000014; line: 1, column: 39]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test3636() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test3737() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""BPH+jQOno],+t:3"");
    stringReader0.close();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test4040() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, Integer.MAX_VALUE, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Base method defs, overrides
    /**********************************************************
     */
@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test4141() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(objectCodec0).toString();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 126, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = readerBasedJsonParser0.getCodec();
    assertSame(objectCodec1, objectCodec0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test4242() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""WRITE_CONCAT_BUFFER"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.close();
    assertFalse(readerBasedJsonParser0.hasCurrentToken());
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test4343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""O"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken("""");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'O': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Binary access
    /**********************************************************
     */
/**
 * Efficient handling for incremental parsing of base64-encoded
 * textual content.
 */
@SuppressWarnings(""resource"")
protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {
    ByteArrayBuilder builder = _getByteArrayBuilder();
    //main_loop:
    while (true) {
        // first, we'll skip preceding white space, if any
        char ch;
        do {
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            ch = _inputBuffer[_inputPtr++];
        } while (ch <= INT_SPACE);
        int bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (ch == '""') {
                // reached the end, fair and square?
                return builder.toByteArray();
            }
            bits = _decodeBase64Escape(b64variant, ch, 0);
            if (bits < 0) {
                // white space to skip
                continue;
            }
        }
        int decodedData = bits;
        // then second base64 char; can't get padding yet, nor ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            bits = _decodeBase64Escape(b64variant, ch, 1);
        }
        decodedData = (decodedData << 6) | bits;
        // third base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        // First branch: can get padding (-> 1 byte)
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 4;
                    builder.append(decodedData);
                    return builder.toByteArray();
                }
                bits = _decodeBase64Escape(b64variant, ch, 2);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // Ok, must get more padding chars, then
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                ch = _inputBuffer[_inputPtr++];
                if (!b64variant.usesPaddingChar(ch)) {
                    throw reportInvalidBase64Char(b64variant, ch, 3, ""expected padding character '"" + b64variant.getPaddingChar() + ""'"");
                }
                // Got 12 bits, only need 8, need to shift
                decodedData >>= 4;
                builder.append(decodedData);
                continue;
            }
            // otherwise we got escaped other char, to be processed below
        }
        // Nope, 2 or 3 bytes
        decodedData = (decodedData << 6) | bits;
        // fourth and last base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 2;
                    builder.appendTwoBytes(decodedData);
                    return builder.toByteArray();
                }
                bits = _decodeBase64Escape(b64variant, ch, 3);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // With padding we only get 2 bytes; but we have
                // to shift it a bit so it is identical to triplet
                // case with partial output.
                // 3 chars gives 3x6 == 18 bits, of which 2 are
                // dummies, need to discard:
                decodedData >>= 2;
                builder.appendTwoBytes(decodedData);
                continue;
            }
            // otherwise we got escaped other char, to be processed below
        }
        // otherwise, our triplet is now complete
        decodedData = (decodedData << 6) | bits;
        builder.appendThreeBytes(decodedData);
    }
}","public void test4444() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""=Bo9qZ`J}ywF"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 73, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeBase64((Base64Variant) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test4545() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "": was expecting closing '"", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-140), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""vu"", 10);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test4646() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""km,-HymY7xiqJagA7"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 774, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._matchToken(""km,-HymY7xiqJagA7"", 11);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'km,-HymY7xkm': was expecting
        //  at [Source: java.lang.Object@0000000016; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test4747() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000017; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public long nextLongValue(long defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test4848() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    BufferRecycler.CharBufferType bufferRecycler_CharBufferType0 = BufferRecycler.CharBufferType.CONCAT_BUFFER;
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler_CharBufferType0, false);
    StringReader stringReader0 = new StringReader(""/"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2122, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue((-1408L));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in a comment
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler$CharBufferType@0000000018; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test4949() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("" #L[{"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('#' (code 35)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000019; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test5050() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""/"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('/' (code 47)): maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000020; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test5151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test5252() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.BufferRecycler$ByteBufferType"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('c', char0);
}",""
"protected void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inputPtr = _inputPtr;
    int inputLen = _inputEnd;
    char[] inputBuffer = _inputBuffer;
    while (true) {
        if (inputPtr >= inputLen) {
            _inputPtr = inputPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inputPtr = _inputPtr;
            inputLen = _inputEnd;
        }
        char c = inputBuffer[inputPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inputPtr;
                c = _decodeEscaped();
                inputPtr = _inputPtr;
                inputLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inputPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inputPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test5353() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000021; line: 1, column: 39]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test5454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""maybe a (non-standard) comment? (not recognized as one since Feature 'A\""LOW_COMMENTS' not enabled for parser)"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2105), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._finishString();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
protected void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test5555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""i8z2/__"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 296, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000022; line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test5656() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000023; line: 1, column: 29]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, generic accessors:
    /**********************************************************
     */
public int size() {
    return _size;
}","public void test5757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""HE"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(127);
    assertEquals(1, charsToNameCanonicalizer0.size());
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test5758() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""HE"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(127);
    assertEquals(""HE"", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test5859() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = readerBasedJsonParser0._handleApos();
    assertEquals(JsonToken.VALUE_STRING, jsonToken0);
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test5960() throws Throwable {
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, fileSystemHandling0, false);
    StringReader stringReader0 = new StringReader(""FgC\u0005Av:t|iJJRE*~@"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 5)): has to be escaped using backslash to be included in string value
        //  at [Source: org.evosuite.runtime.testdata.FileSystemHandling@0000000024; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public Boolean nextBooleanValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    switch(nextToken()) {
        case VALUE_TRUE:
            return Boolean.TRUE;
        case VALUE_FALSE:
            return Boolean.FALSE;
        default:
            return null;
    }
}","public void test6061() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "":Uhxdjbv"", true);
    StringReader stringReader0 = new StringReader("":Uhxdjbv"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.read();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'Uhxdjbv': was expecting
        //  at [Source: java.lang.String@0000000025; line: 1, column: 17]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public JsonToken nextToken() throws IOException, JsonParseException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        if (i != INT_COMMA) {
            _reportUnexpectedChar(i, ""was expecting comma to separate "" + _parsingContext.getTypeDesc() + "" entries"");
        }
        i = _skipWS();
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = _parseName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipWS();
        if (i != INT_COLON) {
            _reportUnexpectedChar(i, ""was expecting a colon to separate field name and value"");
        }
        i = _skipWS();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchToken(""true"", 1);
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchToken(""false"", 1);
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchToken(""null"", 1);
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
        /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parseNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test6162() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""N|%O"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'N': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000026; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public Boolean nextBooleanValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    switch(nextToken()) {
        case VALUE_TRUE:
            return Boolean.TRUE;
        case VALUE_FALSE:
            return Boolean.FALSE;
        default:
            return null;
    }
}","public void test6263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Invalid input: JSON Pointer expression must start with '/': \"""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 300, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'Invalid': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000027; line: 1, column: 8]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public long nextLongValue(long defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test6364() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""': was expecting "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000028; line: 1, column: 35]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6465() throws Throwable {
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, fileSystemHandling0, false);
    StringReader stringReader0 = new StringReader(""FgC\u0005Av:t|iJJRE*~@"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(50);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('2' (code 50)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: org.evosuite.runtime.testdata.FileSystemHandling@0000000029; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"public boolean maybeDirty() {
    return _dirty;
}","public void test6566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(127);
    assertTrue(charsToNameCanonicalizer0.maybeDirty());
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(127);
    assertEquals(""5F+"", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6668() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""): only regular white space (\r, \n, \t) is allowed between tokens"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-918), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(4);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 4)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6769() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 126, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(2000);
    assertEquals("""", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 85, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(39);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000030; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, and not a number
        firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test6971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 39, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(39);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)): was expecting double-quote to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000031; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test7072() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""'~-9&2qjj)vGY"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 126, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._parseAposName();
    assertEquals("""", string0);
}",""
"// caller had pushed it back, before calling; reset
/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected String _parseName(int i) throws IOException {
    if (i != INT_QUOTE) {
        return _handleOddName(i);
    }
    /* First: let's try to see if we have a simple name: one that does
         * not cross input buffer boundary, and does not contain escape
         * sequences.
         */
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    int start = _inputPtr;
                    // to skip the quote
                    _inputPtr = ptr + 1;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test7173() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseName((-2411));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2411
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 *  Method called to ensure that a root-value is followed by a space
 *  token.
 * <p>
 *  NOTE: caller MUST ensure there is at least one character available;
 *  and that input pointer is AT given char (not past)
 */"
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test7274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader(""+WbrY,WVp0pa,'b"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2125, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('W' (code 87)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: java.lang.String@0000000032; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test7375() throws Throwable {
    StringReader stringReader0 = new StringReader(""0ew#"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, objectCodec0, true);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 58, stringReader0, objectCodec1, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('w' (code 119)) in numeric value: Exponent indicator not followed by a digit
        //  at [Source: com.fasterxml.jackson.core.ObjectCodec$MockitoMock$1469363432@0000000033; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected JsonToken _parseNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    boolean negative = (ch == INT_MINUS);
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    dummy_loop: do {
        // dummy loop, to be able to break out
        if (negative) {
            // need to read the next digit
            if (ptr >= _inputEnd) {
                break dummy_loop;
            }
            ch = _inputBuffer[ptr++];
            // First check: must have a digit to follow minus sign
            if (ch > INT_9 || ch < INT_0) {
                _inputPtr = ptr;
                return _handleInvalidNumberStart(ch, true);
            }
            /* (note: has been checked for non-negative already, in
                 * the dispatching code that determined it should be
                 * a numeric value)
                 */
        }
        // One special case, leading zero(es):
        if (ch == INT_0) {
            break dummy_loop;
        }
        /* First, let's see if the whole number is contained within
             * the input buffer unsplit. This should be the common case;
             * and to simplify processing, we will just reparse contents
             * in the alternative case (number split on buffer boundary)
             */
        // already got one
        int intLen = 1;
        // First let's get the obligatory integer part:
        int_loop: while (true) {
            if (ptr >= _inputEnd) {
                break dummy_loop;
            }
            ch = (int) _inputBuffer[ptr++];
            if (ch < INT_0 || ch > INT_9) {
                break int_loop;
            }
            ++intLen;
        }
        int fractLen = 0;
        // And then see if we get other parts
        if (ch == '.') {
            // yes, fraction
            fract_loop: while (true) {
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
                if (ch < INT_0 || ch > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(ch, ""Decimal point not followed by a digit"");
            }
        }
        int expLen = 0;
        if (ch == 'e' || ch == 'E') {
            // and/or exponent
            if (ptr >= inputLen) {
                break dummy_loop;
            }
            // Sign indicator?
            ch = (int) _inputBuffer[ptr++];
            if (ch == INT_MINUS || ch == INT_PLUS) {
                // yup, skip for now
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            while (ch <= INT_9 && ch >= INT_0) {
                ++expLen;
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(ch, ""Exponent indicator not followed by a digit"");
            }
        }
        // Got it all: let's add to text buffer for parsing, access
        // need to push back following separator
        --ptr;
        _inputPtr = ptr;
        // As per #105, need separating space between root values; check here
        int len = ptr - startPtr;
        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
        return reset(negative, intLen, fractLen, expLen);
    } while (false);
    _inputPtr = negative ? (startPtr + 1) : startPtr;
    return _parseNumber2(negative);
}","public void test7476() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseNumber(660);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test7577() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(33);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public long nextLongValue(long defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test7578() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(33);
    assertEquals(33L, long0);
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public JsonToken nextToken() throws IOException, JsonParseException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        if (i != INT_COMMA) {
            _reportUnexpectedChar(i, ""was expecting comma to separate "" + _parsingContext.getTypeDesc() + "" entries"");
        }
        i = _skipWS();
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = _parseName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipWS();
        if (i != INT_COLON) {
            _reportUnexpectedChar(i, ""was expecting a colon to separate field name and value"");
        }
        i = _skipWS();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchToken(""true"", 1);
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchToken(""false"", 1);
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchToken(""null"", 1);
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
        /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parseNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test7679() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""|"", false);
    StringReader stringReader0 = new StringReader(""nz>U&"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1884, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'nz': was expecting
        //  at [Source: java.lang.String@0000000034; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test7780() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(2, readerBasedJsonParser0.getTokenColumnNr());
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test7881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""1Gu@F/3z&}v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(8);
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public int nextIntValue(int defaultValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test7882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""1Gu@F/3z&}v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(8);
    assertEquals(1, int0);
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test7983() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""i"", false);
    StringReader stringReader0 = new StringReader(""](-`)=,c{yd!"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 841, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected close marker ']': expected '}' (for ROOT starting at [Source: java.lang.String@0000000008; line: 1, column: 0])
        //  at [Source: java.lang.String@0000000035; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException, JsonParseException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public String nextTextValue() throws IOException, JsonParseException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test8084() throws Throwable {
    StringReader stringReader0 = new StringReader(""0e"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, objectCodec0, true);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 58, stringReader0, objectCodec1, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputexpected a digit for number exponent
        //  at [Source: com.fasterxml.jackson.core.ObjectCodec$MockitoMock$1469363432@0000000036; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {
    // if we have already read the token, just use whatever we may have
    if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {
        byte[] b = getBinaryValue(b64variant);
        out.write(b);
        return b.length;
    }
    // otherwise do ""real"" incremental parsing...
    byte[] buf = _ioContext.allocBase64Buffer();
    try {
        return _readBinary(b64variant, out, buf);
    } finally {
        _ioContext.releaseBase64Buffer(buf);
    }
}","public void test8185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""g0*hk7HSCqb"");
    try {
        readerBasedJsonParser0.readBinaryValue((Base64Variant) null, (OutputStream) mockFileOutputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public int getTextOffset() throws IOException, JsonParseException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken) {
            case FIELD_NAME:
                return 0;
            case VALUE_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test8286() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "":Uhxdjbv"", false);
    StringReader stringReader0 = new StringReader("":Uhxdjbv"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public int getTextLength() throws IOException, JsonParseException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken) {
            case FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case VALUE_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test8387() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0.DEFAULT_WRITE_CONCAT_BUFFER_LEN, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 134, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(0, int0);
}",""
"@Override
public char[] getTextCharacters() throws IOException, JsonParseException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken) {
            case FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case VALUE_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test8488() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""BPH+jQOno],+t:3"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    char[] charArray0 = readerBasedJsonParser0.getTextCharacters();
    assertNull(charArray0);
}",""
"protected String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t) {
        case FIELD_NAME:
            return _parsingContext.getCurrentName();
        case VALUE_STRING:
        // fall through
        case VALUE_NUMBER_INT:
        case VALUE_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test8589() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0.DEFAULT_WRITE_CONCAT_BUFFER_LEN, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 134, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t) {
        case FIELD_NAME:
            return _parsingContext.getCurrentName();
        case VALUE_STRING:
        // fall through
        case VALUE_NUMBER_INT:
        case VALUE_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test8690() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t) {
        case FIELD_NAME:
            return _parsingContext.getCurrentName();
        case VALUE_STRING:
        // fall through
        case VALUE_NUMBER_INT:
        case VALUE_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test8791() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0.DEFAULT_WRITE_CONCAT_BUFFER_LEN, true);
    StringReader stringReader0 = new StringReader(""*c;zq<Fj8JUO)"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertNull(string0);
}",""
"protected String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t) {
        case FIELD_NAME:
            return _parsingContext.getCurrentName();
        case VALUE_STRING:
        // fall through
        case VALUE_NUMBER_INT:
        case VALUE_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test8892() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""l9"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals(""["", string0);
}",""
"// @since 2.1
@Override
public String getValueAsString(String defValue) throws IOException, JsonParseException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(defValue);
}","public void test8993() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5F+:E_0INvqf81dB;"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 127, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString(""5F+:E_0INvqf81dB;"");
    assertEquals(""5F+:E_0INvqf81dB;"", string0);
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public String getValueAsString() throws IOException, JsonParseException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(null);
}","public void test9094() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader(""+brY,WVp0pa,'b"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2125, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString();
    assertNull(string0);
}",""
"/*
    /**********************************************************
    /* Public API, data access
    /**********************************************************
     */
/**
 * Method for accessing textual representation of the current event;
 * if no current event (before first call to {@link #nextToken}, or
 * after encountering end-of-input), returns null.
 * Method can be called for any event.
 */
@Override
public String getText() throws IOException, JsonParseException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return _getText2(t);
}","public void test9195() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getText();
    assertNull(string0);
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test9296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-967), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.getNextChar(""TLK .xCO$m"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputTLK .xCO$m
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000037; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    if (_currToken == JsonToken.VALUE_STRING) {
        // usually true
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test9397() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""VR(-V!p`-L^+z4`+}#v"", false);
    StringReader stringReader0 = new StringReader(""VR(-V!p`-L^+z4`+}#v"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.getNextChar(""uUW7Cq]lCp-"");
    readerBasedJsonParser0._skipCR();
    assertFalse(readerBasedJsonParser0.hasTextCharacters());
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test9498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""TU<]{!@.9<s7G"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertTrue(boolean0);
}",""
"protected char getNextChar(String eofMsg) throws IOException, JsonParseException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test9499() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""TU<]{!@.9<s7G"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    char char0 = readerBasedJsonParser0.getNextChar(""j^6[mJ*#^:MF/I*<Irb"");
    assertEquals('T', char0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test95100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    StringWriter stringWriter0 = new StringWriter(2000);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
    assertEquals(0, int0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test96102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^4?cg'r[S.j2Nq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    StringWriter stringWriter0 = new StringWriter((byte) 92);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
    assertEquals(13, int0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test97103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""i8z2/__"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 296, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    readerBasedJsonParser0.setCodec(objectCodec1);
    assertFalse(readerBasedJsonParser0.hasCurrentToken());
}",""
"@Override
public Object getInputSource() {
    return _reader;
}","public void test98104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""i8z2/__"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 296, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertSame(stringReader0, object0);
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test99105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""N|%O"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
