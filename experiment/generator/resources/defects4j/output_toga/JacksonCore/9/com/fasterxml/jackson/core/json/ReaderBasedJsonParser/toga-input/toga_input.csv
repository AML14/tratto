focal_method,test_prefix,docstring
"@SuppressWarnings(""unchecked"")
public <T> T readValueAs(TypeReference<?> valueTypeRef) throws IOException {
    return (T) _codec().readValue(this, valueTypeRef);
}","public void test0011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""0m&w~ y&OD8%Xr#"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(objectCodec0).readValue(any(com.fasterxml.jackson.core.JsonParser.class), any(com.fasterxml.jackson.core.type.TypeReference.class));
    doReturn((String) null).when(objectCodec0).toString();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-629), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 63, false);
    TypeReference<Integer> typeReference0 = (TypeReference<Integer>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    Object object1 = readerBasedJsonParser0.readValueAs((TypeReference<?>) typeReference0);
    assertNull(object1);
}","/**
 *  Method to deserialize JSON content into a Java type, reference
 *  to which is passed as argument. Type is passed using so-called
 *  ""super type token""
 *  and specifically needs to be used if the root type is a
 *  parameterized (generic) container type.
 *  <b>Note</b>: method can only be called if the parser has
 *  an object codec assigned; this is true for parsers constructed
 *  by <code>MappingJsonFactory</code> (defined in 'jackson-databind' bundle)
 *  but not for {@link JsonFactory} (unless its <code>setCodec</code>
 *  method has been explicitly called).
 * <p>
 *  This method may advance the event stream, for structured types
 *  the current token will be the closing end marker (END_ARRAY,
 *  END_OBJECT) of the bound structure. For non-structured Json types
 *  (and for {@link JsonToken#VALUE_EMBEDDED_OBJECT})
 *  stream is not advanced.
 */"
"@Override
public Object getInputSource() {
    return _reader;
}","public void test0022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v 5b 0]~VFQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertSame(stringReader0, object0);
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test0033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v 5b 0]~VFQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.setCodec((ObjectCodec) null);
    assertEquals(0, readerBasedJsonParser0.getCurrentTokenId());
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test0045() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""was expecting either valid name character (foi unquoted name) or double-quote (for quoted) to start field name"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 5, false);
    StringWriter stringWriter0 = new StringWriter(2);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
    assertEquals(5, int0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test0056() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""  bdhV>kQ_P@n-"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) null);
    assertEquals(0, int0);
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test0067() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""7"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-523), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputNo digit following minus sign
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000011; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test0078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""expected a valid value (number, String, array, oEject, 'trueU, 'false' or 'null')"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 33, 3, true);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 3
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test0089() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.JsonLocation"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 2, false);
    char char0 = readerBasedJsonParser0.getNextChar(""com.fasterxml.jackson.core.JsonLocation"");
    assertEquals('\u0000', char0);
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test00910() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""-INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 110, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token '-INF': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000012; line: 1, column: 9]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test01011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = '/';
    charArray0[2] = '/';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 3, false);
    readerBasedJsonParser0.nextBooleanValue();
    assertArrayEquals(new char[] { '(', 'F', 'Q', '3', '5', '9', '@', 'S', 'V' }, charArray0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test01112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-3833), (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, (char[]) null, 3337, 5, true);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test01213() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1303, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0.getValueAsString(""+INF"");
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test01314() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""\""(2<K6<]"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000013; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(null);
}","public void test01415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""u}t"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString();
    assertNull(string0);
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(null);
}","public void test01516() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 51, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getValueAsString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000014; line: 1, column: 17]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test01617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 48, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    readerBasedJsonParser0.getValueAsString();
    assertEquals(6, readerBasedJsonParser0.getCurrentTokenId());
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return super.getValueAsString(defValue);
}","public void test01718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<s"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getValueAsString(""\""Nu2<K6<s"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, data access
    /**********************************************************
     */
/**
 * Method for accessing textual representation of the current event;
 * if no current event (before first call to {@link #nextToken}, or
 * after encountering end-of-input), returns null.
 * Method can be called for any event.
 */
@Override
public final String getText() throws IOException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return _getText2(t);
}","public void test01819() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    String string1 = readerBasedJsonParser0.getText();
    assertNull(string1);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test01920() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""T%Z2kNUCsixNCb]g"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    char[] charArray0 = new char[17];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-785), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 32767, true);
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertNull(string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test02021() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 101, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test02122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""]ALU@_FALSE"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-448), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 126, false);
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test02223() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals(""{"", string0);
}",""
"@Override
public final char[] getTextCharacters() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test02324() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, 2, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0);
    char[] charArray0 = readerBasedJsonParser0.getTextCharacters();
    assertNull(charArray0);
}",""
"@Override
public final char[] getTextCharacters() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test02425() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2K6<"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getTextCharacters();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000016; line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test02526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1308, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0.getTextCharacters();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test02627() throws Throwable {
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""71SujoYi7s7"");
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""71SujoYi7s7"", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[8];
    charArray0[1] = '2';
    charArray0[2] = '1';
    charArray0[3] = '\r';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 50, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 3834, true);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0.getTextCharacters();
    assertEquals(1L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
public boolean isExpectedStartArrayToken() {
    return _currToken == JsonToken.START_ARRAY;
}","public void test02728() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextIntValue(1);
    readerBasedJsonParser0.getTextCharacters();
    assertTrue(readerBasedJsonParser0.isExpectedStartArrayToken());
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test02829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1318), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    readerBasedJsonParser0.nextFieldName();
    readerBasedJsonParser0.getTextCharacters();
    assertEquals(6, readerBasedJsonParser0.getCurrentTokenId());
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test02930() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""],6"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(0, int0);
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test03031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""7"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-523), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(7, readerBasedJsonParser0.getCurrentTokenId());
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test03032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""7"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-523), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(1, int0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test03133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 89, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test03134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 89, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(4, int0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test03235() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1308, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test03236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1308, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(4, int0);
}",""
"@Override
public boolean isExpectedStartArrayToken() {
    return _currToken == JsonToken.START_ARRAY;
}","public void test03337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertTrue(readerBasedJsonParser0.isExpectedStartArrayToken());
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test03338() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(1, int0);
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test03439() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2K6<"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getTextLength();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000017; line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test03540() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("" "");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1565, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test03641() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""2.2250738585072012e-308"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    readerBasedJsonParser0.getTextOffset();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    // usually true
    if (_currToken == JsonToken.VALUE_STRING) {
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test03742() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or daN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1049, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0.getTextOffset();
    assertTrue(readerBasedJsonParser0.hasTextCharacters());
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test03843() throws Throwable {
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""71SujoYi7s7"");
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""71SujoYi7s7"", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    charArray0[1] = '2';
    charArray0[3] = '\r';
    charArray0[2] = '2';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 50, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 3834, true);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(1L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test03844() throws Throwable {
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""71SujoYi7s7"");
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""71SujoYi7s7"", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    charArray0[1] = '2';
    charArray0[3] = '\r';
    charArray0[2] = '2';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 50, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 3834, true);
    readerBasedJsonParser0.nextBooleanValue();
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(1, int0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test03945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextIntValue(3);
    readerBasedJsonParser0.getTextOffset();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test04046() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<s"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""\""Nu2<K6<s"", true);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    try {
        readerBasedJsonParser0.getTextOffset();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000018; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public byte[] getBinaryValue() throws IOException {
    return getBinaryValue(Base64Variants.getDefaultVariant());
}","public void test04147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""\""Nu2K6<"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getBinaryValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Failed to decode VALUE_STRING as base64 (MIME-NO-LINEFEEDS): Illegal character '<' (code 0x3c) in base64 content
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000019; line: 1, column: 8]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Convenience alternative to {@link #getBinaryValue(Base64Variant)}
 * that defaults to using
 * {@link Base64Variants#getDefaultVariant} as the default encoding.
 */"
"public int readBinaryValue(OutputStream out) throws IOException {
    return readBinaryValue(Base64Variants.getDefaultVariant(), out);
}","public void test04248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""v 5b 0[5q]~FQ35r9@S"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    try {
        readerBasedJsonParser0.readBinaryValue((OutputStream) byteArrayBuilder0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000020; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that can be used as an alternative to {@link #getBigIntegerValue()},
 * especially when value can be large. The main difference (beyond method
 * of returning content using {@link OutputStream} instead of as byte array)
 * is that content will NOT remain accessible after method returns: any content
 * processed will be consumed and is not buffered in any way. If caller needs
 * buffering, it has to implement it.
 *
 * @param out Output stream to use for passing decoded binary data
 *
 * @return Number of bytes that were decoded and written via {@link OutputStream}
 *
 * @since 2.1
 */"
"@Override
public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {
    // if we have already read the token, just use whatever we may have
    if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {
        byte[] b = getBinaryValue(b64variant);
        out.write(b);
        return b.length;
    }
    // otherwise do ""real"" incremental parsing...
    byte[] buf = _ioContext.allocBase64Buffer();
    try {
        return _readBinary(b64variant, out, buf);
    } finally {
        _ioContext.releaseBase64Buffer(buf);
    }
}","public void test04349() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("")"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("")"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._tokenIncomplete = true;
    try {
        readerBasedJsonParser0.readBinaryValue((Base64Variant) null, (OutputStream) mockFileOutputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000021; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {
    int outputPtr = 0;
    final int outputEnd = buffer.length - 3;
    int outputCount = 0;
    while (true) {
        // first, we'll skip preceding white space, if any
        char ch;
        do {
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            ch = _inputBuffer[_inputPtr++];
        } while (ch <= INT_SPACE);
        int bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            // reached the end, fair and square?
            if (ch == '""') {
                break;
            }
            bits = _decodeBase64Escape(b64variant, ch, 0);
            if (bits < 0) {
                // white space to skip
                continue;
            }
        }
        // enough room? If not, flush
        if (outputPtr > outputEnd) {
            outputCount += outputPtr;
            out.write(buffer, 0, outputPtr);
            outputPtr = 0;
        }
        int decodedData = bits;
        // then second base64 char; can't get padding yet, nor ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            bits = _decodeBase64Escape(b64variant, ch, 1);
        }
        decodedData = (decodedData << 6) | bits;
        // third base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        // First branch: can get padding (-> 1 byte)
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 4;
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 2);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // Ok, must get padding
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                ch = _inputBuffer[_inputPtr++];
                if (!b64variant.usesPaddingChar(ch)) {
                    throw reportInvalidBase64Char(b64variant, ch, 3, ""expected padding character '"" + b64variant.getPaddingChar() + ""'"");
                }
                // Got 12 bits, only need 8, need to shift
                decodedData >>= 4;
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // Nope, 2 or 3 bytes
        decodedData = (decodedData << 6) | bits;
        // fourth and last base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 2;
                    buffer[outputPtr++] = (byte) (decodedData >> 8);
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 3);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                /* With padding we only get 2 bytes; but we have
                     * to shift it a bit so it is identical to triplet
                     * case with partial output.
                     * 3 chars gives 3x6 == 18 bits, of which 2 are
                     * dummies, need to discard:
                     */
                decodedData >>= 2;
                buffer[outputPtr++] = (byte) (decodedData >> 8);
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // otherwise, our triplet is now complete
        decodedData = (decodedData << 6) | bits;
        buffer[outputPtr++] = (byte) (decodedData >> 16);
        buffer[outputPtr++] = (byte) (decodedData >> 8);
        buffer[outputPtr++] = (byte) decodedData;
    }
    _tokenIncomplete = false;
    if (outputPtr > 0) {
        outputCount += outputPtr;
        out.write(buffer, 0, outputPtr);
    }
    return outputCount;
}","public void test04450() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 10, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2, false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""%dTK8f[04d(t"", false);
    byte[] byteArray0 = new byte[9];
    try {
        readerBasedJsonParser0._readBinary((Base64Variant) null, mockFileOutputStream0, byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in null
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000022; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException {
    int outputPtr = 0;
    final int outputEnd = buffer.length - 3;
    int outputCount = 0;
    while (true) {
        // first, we'll skip preceding white space, if any
        char ch;
        do {
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            ch = _inputBuffer[_inputPtr++];
        } while (ch <= INT_SPACE);
        int bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            // reached the end, fair and square?
            if (ch == '""') {
                break;
            }
            bits = _decodeBase64Escape(b64variant, ch, 0);
            if (bits < 0) {
                // white space to skip
                continue;
            }
        }
        // enough room? If not, flush
        if (outputPtr > outputEnd) {
            outputCount += outputPtr;
            out.write(buffer, 0, outputPtr);
            outputPtr = 0;
        }
        int decodedData = bits;
        // then second base64 char; can't get padding yet, nor ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            bits = _decodeBase64Escape(b64variant, ch, 1);
        }
        decodedData = (decodedData << 6) | bits;
        // third base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        // First branch: can get padding (-> 1 byte)
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 4;
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 2);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // Ok, must get padding
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                ch = _inputBuffer[_inputPtr++];
                if (!b64variant.usesPaddingChar(ch)) {
                    throw reportInvalidBase64Char(b64variant, ch, 3, ""expected padding character '"" + b64variant.getPaddingChar() + ""'"");
                }
                // Got 12 bits, only need 8, need to shift
                decodedData >>= 4;
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // Nope, 2 or 3 bytes
        decodedData = (decodedData << 6) | bits;
        // fourth and last base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 2;
                    buffer[outputPtr++] = (byte) (decodedData >> 8);
                    buffer[outputPtr++] = (byte) decodedData;
                    break;
                }
                bits = _decodeBase64Escape(b64variant, ch, 3);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                /* With padding we only get 2 bytes; but we have
                     * to shift it a bit so it is identical to triplet
                     * case with partial output.
                     * 3 chars gives 3x6 == 18 bits, of which 2 are
                     * dummies, need to discard:
                     */
                decodedData >>= 2;
                buffer[outputPtr++] = (byte) (decodedData >> 8);
                buffer[outputPtr++] = (byte) decodedData;
                continue;
            }
        }
        // otherwise, our triplet is now complete
        decodedData = (decodedData << 6) | bits;
        buffer[outputPtr++] = (byte) (decodedData >> 16);
        buffer[outputPtr++] = (byte) (decodedData >> 8);
        buffer[outputPtr++] = (byte) decodedData;
    }
    _tokenIncomplete = false;
    if (outputPtr > 0) {
        outputCount += outputPtr;
        out.write(buffer, 0, outputPtr);
    }
    return outputCount;
}","public void test04551() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""8|;EPP~&Dfm-F x"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 33);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._readBinary((Base64Variant) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test04652() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<s"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000023; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test04753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""],6"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected close marker ']': expected '}' (for ROOT starting at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000001; line: 1, column: 0])
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000024; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test04854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""f@e"", true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""{}A8~cp"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 47, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-3374), true);
    readerBasedJsonParser0.nextFieldName();
    readerBasedJsonParser0.nextTextValue();
    assertEquals((-3373), readerBasedJsonParser0.getTokenColumnNr());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test04955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""}"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 391, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected close marker '}': expected ']' (for ROOT starting at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000001; line: 1, column: 0])
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000025; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test05056() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""{zV$()h{f(Q6"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 44, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(0);
    try {
        readerBasedJsonParser0.nextIntValue(3);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('(' (code 40)): was expecting a colon to separate field name and value
        //  at [Source: UNKNOWN; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test05157() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""{\""s*LaMjy,R=]"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 51, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, (-1088), true);
    readerBasedJsonParser0.nextTextValue();
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000026; line: 1, column: -1073]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test05258() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""08->Z]^"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 751, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(2);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('-' (code 45)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000027; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test05359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""3(}_iG?!GwPa?n"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 127)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000028; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test05460() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[1] = '4';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('v' (code 118)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000029; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test05561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""5d` lTq<K;3[}{U5|"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('d' (code 100)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000030; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test05662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""],6"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.skip(2);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(7, readerBasedJsonParser0.getCurrentTokenId());
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test05763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""8"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(33);
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test05764() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""8"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(33);
    assertEquals(8, int0);
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test05865() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertNull(boolean0);
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test05866() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test05867() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"/*
    /**********************************************************
    /* Public API, generic accessors:
    /**********************************************************
     */
public int size() {
    return _size;
}","public void test05968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""expected a valid value (number, String, array, oEject, 'trueb, 'false' or 'numl')"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 47, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(2, charsToNameCanonicalizer0.size());
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test05969() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""expected a valid value (number, String, array, oEject, 'trueb, 'false' or 'numl')"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 47, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(65, readerBasedJsonParser0.getTokenColumnNr());
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test06070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""n"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'n': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000031; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test06171() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""expected a valid value (number, String, array, oEject, 'trueb, 'false' or 'numl')"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 73, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'trueb': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000032; line: 1, column: 62]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test06272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""F*Xfi&5xJP+(EGmUf'2"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    long long0 = readerBasedJsonParser0.nextLongValue((-129L));
    assertEquals(18L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test06273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""F*Xfi&5xJP+(EGmUf'2"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    long long0 = readerBasedJsonParser0.nextLongValue((-129L));
    assertEquals(2L, long0);
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test06374() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null, 'true', 'false' or daN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(9, readerBasedJsonParser0.getCurrentTokenId());
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test06475() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""1e&n;!%=^"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 43, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('&' (code 38)) in numeric value: Exponent indicator not followed by a digit
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000033; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test06576() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""3@(}_iG?!GwPa?n"", false);
    StringReader stringReader0 = new StringReader(""[8ttR}v{%C@S8"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 45, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test06677() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""0m&w~ y&OD8%Xr#"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[8];
    charArray0[1] = '1';
    charArray0[2] = '.';
    charArray0[3] = '1';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3031, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 63, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000034; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test06778() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""28E9yj8~BR"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('y' (code 121)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000035; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test06879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""08->Z]^"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Invalid numeric value: Leading zeroes not allowed
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000036; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test06980() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\""' (code 34)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000037; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07081() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""28E9yj8z~B!"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('y' (code 121)): Expected space separating root-level values
        //  at [Source: java.io.StringReader@0000000038; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07182() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""\""2<K6<s"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[1] = '2';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 249, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 2, true);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\""' (code 34)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000039; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, 2, false);
    StringReader stringReader0 = new StringReader(""2/+"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-661), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('/' (code 47)): Expected space separating root-level values
        //  at [Source: java.lang.Integer@0000000040; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07384() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""0m&w~ y&OD8%Xr#"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[8];
    charArray0[1] = '1';
    charArray0[2] = '.';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3031, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 63, true);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: Decimal point not followed by a digit
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000041; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07485() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\""' (code 34)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000042; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07586() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""59.cS(=;%<-,2*G~!"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1500, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('c' (code 99)) in numeric value: Decimal point not followed by a digit
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000043; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test07687() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""28E9yj8zYBR"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0.BYTE_WRITE_ENCODING_BUFFER, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 51, 34, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('y' (code 121)): Expected space separating root-level values
        //  at [Source: java.lang.Integer@0000000044; line: 1, column: 40]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""28Ey0j8~r"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""28Ey0j8~r"", false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('y' (code 121)) in numeric value: Exponent indicator not followed by a digit
        //  at [Source: java.lang.String@0000000045; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test07889() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    StringReader stringReader0 = new StringReader(""0&.~ y&OD8%Xr#"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, true);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('&' (code 38)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000046; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test07990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""*tuF@_t5K(bq9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[0] = '0';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 8000, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000047; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08091() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""t0uE"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2151, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('u' (code 117)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000048; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test08192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""]ALU@_FALSE"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    charArray0[2] = '0';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 3, false);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (']' (code 93)): Expected space separating root-level values
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000049; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test08293() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 33, 0, false);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertNull(boolean0);
}",""
"public int getTokenLineNr() {
    return _tokenInputRow;
}","public void test08294() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 33, 0, false);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test08295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 33, 0, false);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test08296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""+INF"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8000, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 33, 0, false);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08397() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    charArray0[1] = 'I';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 60, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in a value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000050; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test08498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-Infinity"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token '-Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000051; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test08599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""+I*)"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4408, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('*' (code 42)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000052; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test086100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""+Infinity"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 102, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token '+Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: java.lang.Object@0000000053; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public final boolean isScalarValue() {
    return _isScalar;
}","public void test087101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""Infinity"");
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 832, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = readerBasedJsonParser0._parseNegNumber();
    assertTrue(jsonToken0.isScalarValue());
}","/**
 * Method that can be used to check whether this token represents
 * a valid non-structured value. This means all tokens other than
 * Object/Array start/end markers all field names.
 */"
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test088102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, false);
    StringReader stringReader0 = new StringReader(""+Infinity"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 285, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    readerBasedJsonParser0._skipCR();
    assertEquals(8, readerBasedJsonParser0.getCurrentTokenId());
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test089103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    charArray0[1] = '\t';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 3, true);
    JsonToken jsonToken0 = readerBasedJsonParser0._parsePosNumber(1);
    assertEquals(JsonToken.VALUE_NUMBER_INT, jsonToken0);
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test090104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""\""(2<K6<]"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    charArray0[2] = ' ';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3547, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 12, false);
    JsonToken jsonToken0 = readerBasedJsonParser0._parsePosNumber(0);
    assertEquals(JsonToken.VALUE_NUMBER_INT, jsonToken0);
}",""
"/*
    /**********************************************************
    /* Public API, generic accessors:
    /**********************************************************
     */
public int size() {
    return _size;
}","public void test091105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._finishString();
    String string1 = readerBasedJsonParser0._parseName();
    assertEquals(1, charsToNameCanonicalizer0.size());
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test091106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._finishString();
    String string1 = readerBasedJsonParser0._parseName();
    assertEquals(""@rPqB"", string1);
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test092107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: java.lang.String@0000000054; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test093108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""was expecting either valid name character (foi unquoted name) or double-quote (for quoted) to start field name"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 5, false);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in name
        //  at [Source: java.lang.Object@0000000055; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test094109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(39);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)): was expecting double-quote to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000056; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test095110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    StringReader stringReader0 = new StringReader(""3@(}_iG?!GwPa?n"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 5758, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(39);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000057; line: 1, column: 33]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test096111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 56, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(772);
    assertEquals("""", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test097112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""08->Z]^"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 751, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(2);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 2)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000058; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test098113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_YAML_CmOMMENTS"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-22), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.loadMore();
    String string0 = readerBasedJsonParser0._handleOddName(89);
    assertEquals("""", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test099114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: java.lang.String@0000000059; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test100115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("" in a value"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    charArray0[0] = '\t';
    charArray0[1] = '\t';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 2, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'in': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000060; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test101116() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""'"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000061; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test102117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""NaN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000062; line: 1, column: 7]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenLineNr() {
    return _tokenInputRow;
}","public void test103118() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-159), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(1, readerBasedJsonParser0.getTokenLineNr());
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test103119() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-159), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test103120() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-159), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertNull(boolean0);
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test103121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-159), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    Boolean boolean0 = readerBasedJsonParser0.nextBooleanValue();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test104122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Infinity"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue((-1083));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000063; line: 1, column: 17]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test105123() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-Infinity"");
    stringReader0.read();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1370, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test106124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""+"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in a value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000064; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test107125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""': was expecting "");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-933), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000065; line: 1, column: 35]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test108126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000066; line: 1, column: 35]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test109127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""^K!\r\"":31Z|u-m"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 13)): has to be escaped using backslash to be included in string value
        //  at [Source: java.lang.Object@0000000067; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public boolean maybeDirty() {
    return _dirty;
}","public void test110128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_YAML_CmOMMENTS"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-22), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(89);
    assertTrue(charsToNameCanonicalizer0.maybeDirty());
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test110129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_YAML_CmOMMENTS"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-22), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(89);
    assertEquals(""ALLOW_YAML_CmOMMENTS"", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test111130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5hj3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2120, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0._handleOddName(98);
    assertEquals("""", string0);
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test112131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextIntValue(1);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000068; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test113132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    readerBasedJsonParser0._finishString();
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test114133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[wVl5}hw3"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""[wVl5}hw3"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000068; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test115134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-)uHgP\b^["");
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 8)): has to be escaped using backslash to be included in string value
        //  at [Source: UNKNOWN; line: 1, column: 8]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test116135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v 5b 0]~VFQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000069; line: 1, column: 33]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"@Override
public boolean isExpectedStartObjectToken() {
    return _currToken == JsonToken.START_OBJECT;
}","public void test117136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    String string0 = ""yA5hS-D\""@rPqB\""L\\u"";
    StringReader stringReader0 = new StringReader(string0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipString();
    assertFalse(readerBasedJsonParser0.isExpectedStartObjectToken());
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test118137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""co>.fasterxml.jacksonhcore.JsonLocation"");
    char[] charArray0 = new char[1];
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 1, false);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000070; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test119138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""#O4*8irZ7R-2;O~"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(53);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('#' (code 35)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000071; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test120139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("" "");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1565, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test121140() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\r';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 1475, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: UNKNOWN; line: 2, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test122141() throws Throwable {
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""71SujoYi7s7"");
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""71SujoYi7s7"", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 50, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 3834, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: java.lang.String@0000000072; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test123142() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\r';
    charArray0[3] = '\r';
    charArray0[4] = '1';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 1475, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): Expected space separating root-level values
        //  at [Source: UNKNOWN; line: 3, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test124143() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("" /F-X7f,Q7n5#"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, "" /F-X7f,Q7n5#"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('/' (code 47)): maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)
        //  at [Source: java.lang.String@0000000073; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test125144() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader("" #(from "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('#' (code 35)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000074; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test126145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""  bdhV>kQ_P@n-"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'bdhV': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000075; line: 1, column: 7]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test127146() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    charArray0[0] = '\n';
    charArray0[1] = '\n';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 2, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test128147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""#[@`,%JW1Es pm~\""="");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 69, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test129148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = '/';
    charArray0[2] = '/';
    charArray0[3] = '/';
    charArray0[4] = ')';
    charArray0[5] = ')';
    charArray0[6] = '\r';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 480, false);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000076; line: 2, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    @Override
    public boolean nextFieldName(SerializableString str)
         throws IOException
     */
// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test130149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[2] = '/';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 3, true);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('v' (code 118)): was expecting either '*' or '/' for a comment
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000077; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test132151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = '/';
    charArray0[2] = '/';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 33, false);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000079; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test133152() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 101, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000080; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test134153() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""\""Nu2<K6<s"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('\""', char0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test135154() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""/r2w"");
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2722), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('/', char0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test136155() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""v b 0]~V(FQ359@S"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized character escape 'v' (code 118)
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000081; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test137156() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""n"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('\n', char0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test138157() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""u*etua@1Z5q9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('*' (code 42)): expected a hex-digit for character escape sequence
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000082; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test139158() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""tn~+c).v"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""tn~+c).v"", false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 58, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'tn': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000083; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test140159() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""tr ue"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'tr': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000084; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test141160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""false"", true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""false"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(10, readerBasedJsonParser0.getCurrentTokenId());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test142161() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""f23>}~1l(;B"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'f23': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000085; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
   /**********************************************************
   /* Public API, traversal
   /**********************************************************
    */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    _numTypesValid = NR_UNKNOWN;
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    /* First, need to ensure we know the starting location of token
         * after skipping leading white space
         */
    _tokenInputTotal = _currInputProcessed + _inputPtr - 1;
    _tokenInputRow = _currInputRow;
    _tokenInputCol = _inputPtr - _currInputRowStart - 1;
    // finally: clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    /* And should we now have a name? Always true for
         * Object contexts, since the intermediate 'expect-value'
         * state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test143162() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""fa+lse"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""fa+lse"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'fa': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000086; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test144163() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""fal|Dse"", true);
    StringReader stringReader0 = new StringReader(""fal|Dse"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 180, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'fal': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000087; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test145164() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""fals2e"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""fals2e"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, false);
    readerBasedJsonParser0.loadMore();
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'fals2e': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000088; line: 1, column: 46]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test146165() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test147166() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""nX}UXX,6=1^U4"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'nX': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000089; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test148167() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""expected a valid value (number, String, array, oEject, 'true', 'false' or 'null')"");
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 0, true);
    readerBasedJsonParser0._parseAposName();
    readerBasedJsonParser0.nextBooleanValue();
    assertEquals(56L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"/*
    /**********************************************************
    /* Binary access
    /**********************************************************
     */
/**
 * Efficient handling for incremental parsing of base64-encoded
 * textual content.
 */
@SuppressWarnings(""resource"")
protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {
    ByteArrayBuilder builder = _getByteArrayBuilder();
    //main_loop:
    while (true) {
        // first, we'll skip preceding white space, if any
        char ch;
        do {
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            ch = _inputBuffer[_inputPtr++];
        } while (ch <= INT_SPACE);
        int bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (ch == '""') {
                // reached the end, fair and square?
                return builder.toByteArray();
            }
            bits = _decodeBase64Escape(b64variant, ch, 0);
            if (bits < 0) {
                // white space to skip
                continue;
            }
        }
        int decodedData = bits;
        // then second base64 char; can't get padding yet, nor ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            bits = _decodeBase64Escape(b64variant, ch, 1);
        }
        decodedData = (decodedData << 6) | bits;
        // third base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        // First branch: can get padding (-> 1 byte)
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 4;
                    builder.append(decodedData);
                    return builder.toByteArray();
                }
                bits = _decodeBase64Escape(b64variant, ch, 2);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // Ok, must get more padding chars, then
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                ch = _inputBuffer[_inputPtr++];
                if (!b64variant.usesPaddingChar(ch)) {
                    throw reportInvalidBase64Char(b64variant, ch, 3, ""expected padding character '"" + b64variant.getPaddingChar() + ""'"");
                }
                // Got 12 bits, only need 8, need to shift
                decodedData >>= 4;
                builder.append(decodedData);
                continue;
            }
            // otherwise we got escaped other char, to be processed below
        }
        // Nope, 2 or 3 bytes
        decodedData = (decodedData << 6) | bits;
        // fourth and last base64 char; can be padding, but not ws
        if (_inputPtr >= _inputEnd) {
            loadMoreGuaranteed();
        }
        ch = _inputBuffer[_inputPtr++];
        bits = b64variant.decodeBase64Char(ch);
        if (bits < 0) {
            if (bits != Base64Variant.BASE64_VALUE_PADDING) {
                // as per [JACKSON-631], could also just be 'missing'  padding
                if (ch == '""' && !b64variant.usesPadding()) {
                    decodedData >>= 2;
                    builder.appendTwoBytes(decodedData);
                    return builder.toByteArray();
                }
                bits = _decodeBase64Escape(b64variant, ch, 3);
            }
            if (bits == Base64Variant.BASE64_VALUE_PADDING) {
                // With padding we only get 2 bytes; but we have
                // to shift it a bit so it is identical to triplet
                // case with partial output.
                // 3 chars gives 3x6 == 18 bits, of which 2 are
                // dummies, need to discard:
                decodedData >>= 2;
                builder.appendTwoBytes(decodedData);
                continue;
            }
            // otherwise we got escaped other char, to be processed below
        }
        // otherwise, our triplet is now complete
        decodedData = (decodedData << 6) | bits;
        builder.appendThreeBytes(decodedData);
    }
}","public void test149168() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader("" (from "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeBase64((Base64Variant) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"public byte[] getBinaryValue() throws IOException {
    return getBinaryValue(Base64Variants.getDefaultVariant());
}","public void test150169() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""\""(2KK6<]"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    try {
        readerBasedJsonParser0.getBinaryValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Failed to decode VALUE_STRING as base64 (MIME-NO-LINEFEEDS): Illegal character (code 0x7f) in base64 content
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000001; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Convenience alternative to {@link #getBinaryValue(Base64Variant)}
 * that defaults to using
 * {@link Base64Variants#getDefaultVariant} as the default encoding.
 */"
