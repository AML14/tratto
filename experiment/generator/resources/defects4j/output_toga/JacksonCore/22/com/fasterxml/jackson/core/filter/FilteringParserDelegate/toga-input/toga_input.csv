focal_method,test_prefix,docstring
"@Override
public boolean getValueAsBoolean(boolean defaultValue) throws IOException {
    return delegate.getValueAsBoolean(defaultValue);
}","public void test0000() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsBoolean(true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public boolean isExpectedStartArrayToken() {
    return _currToken == JsonToken.START_ARRAY;
}","public void test0011() throws Throwable {
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate((JsonParser) null);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserDelegate0, tokenFilter0, false, false);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    filteringParserDelegate0._currToken = jsonToken0;
    boolean boolean0 = filteringParserDelegate0.isExpectedStartArrayToken();
    assertFalse(boolean0);
}",""
"@Override
public final boolean hasToken(JsonToken t) {
    return (_currToken == t);
}","public void test0022() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    filteringParserDelegate0._currToken = jsonToken0;
    boolean boolean0 = filteringParserDelegate0.hasToken((JsonToken) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean hasTokenId(int id) {
    final JsonToken t = _currToken;
    if (t == null) {
        return (JsonTokenId.ID_NO_TOKEN == id);
    }
    return t.id() == id;
}","public void test0033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader(""^9a}P7053/!aNDw/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    boolean boolean0 = filteringParserDelegate0.hasTokenId(1);
    assertFalse(boolean0);
}",""
"/*
    /**********************************************************
    /* Capability introspection
    /**********************************************************
     */
/**
 * Method that can be called to determine if a custom
 * {@link ObjectCodec} is needed for binding data parsed
 * using {@link JsonParser} constructed by this factory
 * (which typically also implies the same for serialization
 * with {@link JsonGenerator}).
 *
 * @return True if custom codec is needed with parsers and
 *   generators created by this factory; false if a general
 *   {@link ObjectCodec} is enough
 *
 * @since 2.1
 */
public boolean requiresCustomCodec() {
    return false;
}","public void test0044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0, 3);
    IOContext iOContext0 = new IOContext(bufferRecycler0, pipedInputStream0, true);
    StringReader stringReader0 = new StringReader(""88|)~rvgY"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    JsonParser jsonParser0 = filteringParserDelegate0.skipChildren();
    assertFalse(jsonParser0.requiresCustomCodec());
}",""
"public boolean canReadTypeId() {
    return false;
}","public void test0055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader(""^9a}P705m93/!aNDw/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-24), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, (-24), true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    JsonParser jsonParser0 = filteringParserDelegate0.skipChildren();
    assertFalse(jsonParser0.canReadTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 * <p>
 *  Default implementation returns true; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public String getValueAsString(String defaultValue) throws IOException {
    return delegate.getValueAsString(defaultValue);
}","public void test0066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.util.Separators"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    String string0 = filteringParserDelegate0.getValueAsString((String) null);
    assertNull(string0);
}",""
"@Override
public String getValueAsString(String defaultValue) throws IOException {
    return delegate.getValueAsString(defaultValue);
}","public void test0077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream((InputStream) null);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, false);
    StringReader stringReader0 = new StringReader(""r<wx0;u"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    String string0 = filteringParserDelegate0.getValueAsString(""qT1#Xni?%d_"");
    assertEquals(""qT1#Xni?%d_"", string0);
}",""
"@Override
public String getValueAsString() throws IOException {
    return delegate.getValueAsString();
}","public void test0088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""i(vw"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3446, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-5273), 2, true);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    String string0 = filteringParserDelegate0.getValueAsString();
    assertNull(string0);
}",""
"@Override
public long getValueAsLong(long defaultValue) throws IOException {
    return delegate.getValueAsLong(defaultValue);
}","public void test0099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0, 3);
    IOContext iOContext0 = new IOContext(bufferRecycler0, pipedInputStream0, true);
    StringReader stringReader0 = new StringReader(""88|)~rvgY"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    long long0 = filteringParserDelegate0.getValueAsLong((long) 33);
    assertEquals(33L, long0);
}",""
"@Override
public long getValueAsLong() throws IOException {
    return delegate.getValueAsLong();
}","public void test01010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1334), 0, true);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    long long0 = filteringParserDelegate0.getValueAsLong();
    assertEquals(0L, long0);
}",""
"@Override
public int getValueAsInt(int defaultValue) throws IOException {
    return delegate.getValueAsInt(defaultValue);
}","public void test01111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    int int0 = filteringParserDelegate0.getValueAsInt(0);
    assertEquals(0, int0);
}",""
"@Override
public int getValueAsInt(int defaultValue) throws IOException {
    return delegate.getValueAsInt(defaultValue);
}","public void test01212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader(""^9a}P7053/!aNDw/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    int int0 = filteringParserDelegate0.getValueAsInt((-2350));
    assertEquals((-2350), int0);
}",""
"@Override
public double getValueAsDouble(double defaultValue) throws IOException {
    return delegate.getValueAsDouble(defaultValue);
}","public void test01313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""k{M%k_#7sKB_'?cBA"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 32, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    double double0 = filteringParserDelegate0.getValueAsDouble(1.0);
    assertEquals(1.0, double0, 0.01);
}",""
"@Override
public double getValueAsDouble(double defaultValue) throws IOException {
    return delegate.getValueAsDouble(defaultValue);
}","public void test01414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""["");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 128, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    double double0 = filteringParserDelegate0.getValueAsDouble((-947.637));
    assertEquals((-947.637), double0, 0.01);
}",""
"@Override
public double getValueAsDouble() throws IOException {
    return delegate.getValueAsDouble();
}","public void test01515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""uq'K| e,P9b"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 1, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, false);
    double double0 = filteringParserDelegate0.getValueAsDouble();
    assertEquals(0.0, double0, 0.01);
}",""
"@Override
public boolean getValueAsBoolean(boolean defaultValue) throws IOException {
    return delegate.getValueAsBoolean(defaultValue);
}","public void test01616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0, 3);
    IOContext iOContext0 = new IOContext(bufferRecycler0, pipedInputStream0, true);
    StringReader stringReader0 = new StringReader(""88|)~rvgY"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    boolean boolean0 = filteringParserDelegate0.getValueAsBoolean(true);
    assertTrue(boolean0);
}",""
"@Override
public boolean getValueAsBoolean(boolean defaultValue) throws IOException {
    return delegate.getValueAsBoolean(defaultValue);
}","public void test01717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""bMlm$-|h;|"", false);
    StringReader stringReader0 = new StringReader(""Unexpected problem: chain of filtered context broken"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-3591), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, false);
    boolean boolean0 = filteringParserDelegate0.getValueAsBoolean(false);
    assertFalse(boolean0);
}",""
"@Override
public boolean getValueAsBoolean() throws IOException {
    return delegate.getValueAsBoolean();
}","public void test01818() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
    IOContext iOContext0 = new IOContext((BufferRecycler) null, pipedInputStream0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4742, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 4742, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    boolean boolean0 = filteringParserDelegate0.getValueAsBoolean();
    assertFalse(boolean0);
}",""
"@Override
public int getTextLength() throws IOException {
    return delegate.getTextLength();
}","public void test01919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, sequenceInputStream0, false);
    ByteQuadsCanonicalizer byteQuadsCanonicalizer0 = ByteQuadsCanonicalizer.createRoot();
    byte[] byteArray0 = new byte[6];
    UTF8StreamJsonParser uTF8StreamJsonParser0 = new UTF8StreamJsonParser(iOContext0, 1, sequenceInputStream0, (ObjectCodec) null, byteQuadsCanonicalizer0, byteArray0, 1, (-2854), true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(uTF8StreamJsonParser0, tokenFilter0, true, true);
    int int0 = filteringParserDelegate0.getTextLength();
    assertEquals(0, int0);
}",""
"/*
    /**********************************************************
    /* Extended API
    /**********************************************************
     */
public TokenFilter getFilter() {
    return rootFilter;
}","public void test02020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    ByteQuadsCanonicalizer byteQuadsCanonicalizer0 = ByteQuadsCanonicalizer.createRoot();
    byte[] byteArray0 = new byte[9];
    UTF8StreamJsonParser uTF8StreamJsonParser0 = new UTF8StreamJsonParser(iOContext0, 3, sequenceInputStream0, (ObjectCodec) null, byteQuadsCanonicalizer0, byteArray0, 8, (byte) 0, true);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(uTF8StreamJsonParser0, (TokenFilter) null, true, true);
    TokenFilter tokenFilter0 = filteringParserDelegate0.getFilter();
    assertNull(tokenFilter0);
}",""
"/*
    /**********************************************************
    /* Public API, access to token values, other
    /**********************************************************
     */
@Override
public Object getEmbeddedObject() throws IOException {
    return delegate.getEmbeddedObject();
}","public void test02121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    PipedInputStream pipedInputStream0 = new PipedInputStream(128);
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    ByteQuadsCanonicalizer byteQuadsCanonicalizer0 = ByteQuadsCanonicalizer.createRoot();
    UTF8DataInputJsonParser uTF8DataInputJsonParser0 = new UTF8DataInputJsonParser(iOContext0, 0, dataInputStream0, (ObjectCodec) null, byteQuadsCanonicalizer0, 1);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(uTF8DataInputJsonParser0, (TokenFilter) null, true, false);
    Object object1 = filteringParserDelegate0.getEmbeddedObject();
    assertNull(object1);
}",""
"public int getLineNr() {
    return _lineNr;
}","public void test02222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, true);
    JsonLocation jsonLocation0 = filteringParserDelegate0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public boolean hasCurrentIndex() {
    return _index >= 0;
}","public void test02323() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    JsonStreamContext jsonStreamContext0 = filteringParserDelegate0._filterContext();
    assertFalse(jsonStreamContext0.hasCurrentIndex());
}","/**
 * Method that may be called to verify whether this context has valid index:
 * will return `false` before the first entry of Object context or before
 * first element of Array context; otherwise returns `true`.
 *
 * @since 2.9
 */"
"@Override
public JsonToken nextValue() throws IOException {
    // Re-implemented same as ParserMinimalBase:
    JsonToken t = nextToken();
    if (t == JsonToken.FIELD_NAME) {
        t = nextToken();
    }
    return t;
}","public void test02424() throws Throwable {
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, (TokenFilter) null, true, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.nextValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public JsonToken nextValue() throws IOException {
    // Re-implemented same as ParserMinimalBase:
    JsonToken t = nextToken();
    if (t == JsonToken.FIELD_NAME) {
        t = nextToken();
    }
    return t;
}","public void test02525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1334), 0, true);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.nextValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1334
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public JsonToken nextValue() throws IOException {
    // Re-implemented same as ParserMinimalBase:
    JsonToken t = nextToken();
    if (t == JsonToken.FIELD_NAME) {
        t = nextToken();
    }
    return t;
}","public void test02626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    PipedInputStream pipedInputStream0 = new PipedInputStream(128);
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    ByteQuadsCanonicalizer byteQuadsCanonicalizer0 = ByteQuadsCanonicalizer.createRoot();
    UTF8DataInputJsonParser uTF8DataInputJsonParser0 = new UTF8DataInputJsonParser(iOContext0, 0, dataInputStream0, (ObjectCodec) null, byteQuadsCanonicalizer0, 1);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(uTF8DataInputJsonParser0, (TokenFilter) null, true, false);
    try {
        filteringParserDelegate0.nextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"@Override
public JsonToken nextValue() throws IOException {
    // Re-implemented same as ParserMinimalBase:
    JsonToken t = nextToken();
    if (t == JsonToken.FIELD_NAME) {
        t = nextToken();
    }
    return t;
}","public void test02727() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader(""^9a}P7053/!aNDw/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.nextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('^' (code 94)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test02828() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.nextToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test02929() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
    IOContext iOContext0 = new IOContext((BufferRecycler) null, pipedInputStream0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1), 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.nextToken();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test03030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader(""?8xd7?d>uVrFzA9"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(true, (JsonParser) readerBasedJsonParser0, (JsonParser) readerBasedJsonParser0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserSequence0, tokenFilter0, false, true);
    try {
        filteringParserDelegate0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('?' (code 63)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasTextCharacters() {
    return delegate.hasTextCharacters();
}","public void test03131() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.hasTextCharacters();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public String getValueAsString(String defaultValue) throws IOException {
    return delegate.getValueAsString(defaultValue);
}","public void test03232() throws Throwable {
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate((JsonParser) null);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserDelegate0, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsString(""Y-8_)Xx"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.JsonParserDelegate"", e);
    }
}",""
"@Override
public int getValueAsInt(int defaultValue) throws IOException {
    return delegate.getValueAsInt(defaultValue);
}","public void test03333() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsInt(1422);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, coercion/conversion
    /**********************************************************
     */
@Override
public int getValueAsInt() throws IOException {
    return delegate.getValueAsInt();
}","public void test03434() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsInt();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public double getValueAsDouble(double defaultValue) throws IOException {
    return delegate.getValueAsDouble(defaultValue);
}","public void test03535() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsDouble((-469.0));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public JsonLocation getTokenLocation() {
    return delegate.getTokenLocation();
}","public void test03636() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getTokenLocation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public int getTextOffset() throws IOException {
    return delegate.getTextOffset();
}","public void test03737() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getTextOffset();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public char[] getTextCharacters() throws IOException {
    return delegate.getTextCharacters();
}","public void test03838() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getTextCharacters();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text
    /**********************************************************
     */
@Override
public String getText() throws IOException {
    return delegate.getText();
}","public void test03939() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getText();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public short getShortValue() throws IOException {
    return delegate.getShortValue();
}","public void test04040() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getShortValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public Number getNumberValue() throws IOException {
    return delegate.getNumberValue();
}","public void test04141() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getNumberValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public NumberType getNumberType() throws IOException {
    return delegate.getNumberType();
}","public void test04242() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getNumberType();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public long getLongValue() throws IOException {
    return delegate.getLongValue();
}","public void test04343() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getLongValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public int getIntValue() throws IOException {
    return delegate.getIntValue();
}","public void test04444() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getIntValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public float getFloatValue() throws IOException {
    return delegate.getFloatValue();
}","public void test04545() throws Throwable {
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate((JsonParser) null);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserDelegate0, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getFloatValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.JsonParserDelegate"", e);
    }
}",""
"@Override
public double getDoubleValue() throws IOException {
    return delegate.getDoubleValue();
}","public void test04646() throws Throwable {
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, (TokenFilter) null, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getDoubleValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public BigDecimal getDecimalValue() throws IOException {
    return delegate.getDecimalValue();
}","public void test04747() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getDecimalValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public JsonLocation getCurrentLocation() {
    return delegate.getCurrentLocation();
}","public void test04848() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getCurrentLocation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public byte getByteValue() throws IOException {
    return delegate.getByteValue();
}","public void test04949() throws Throwable {
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, (TokenFilter) null, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getByteValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public boolean getBooleanValue() throws IOException {
    return delegate.getBooleanValue();
}","public void test05050() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getBooleanValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, numeric
    /**********************************************************
     */
@Override
public BigInteger getBigIntegerValue() throws IOException {
    return delegate.getBigIntegerValue();
}","public void test05151() throws Throwable {
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(false, (JsonParser) null, (JsonParser) null);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserSequence0, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getBigIntegerValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.JsonParserDelegate"", e);
    }
}",""
"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            return t;
        }
        TokenFilter f;
        // One simplification here: we know for a fact that the item filter is
        // neither null nor 'include all', for most cases; the only exception
        // being FIELD_NAME handling
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
        }
    }
}","public void test05252() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0._nextTokenWithBuffering((TokenFilterContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}","/**
 * Method called when a new potentially included context is found.
 */"
"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            return t;
        }
        TokenFilter f;
        // One simplification here: we know for a fact that the item filter is
        // neither null nor 'include all', for most cases; the only exception
        // being FIELD_NAME handling
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
        }
    }
}","public void test05353() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-2890), 0, true);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, true, true);
    TokenFilterContext tokenFilterContext0 = filteringParserDelegate0._headContext;
    // Undeclared exception!
    try {
        filteringParserDelegate0._nextTokenWithBuffering(tokenFilterContext0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2890
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when a new potentially included context is found.
 */"
"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            return t;
        }
        TokenFilter f;
        // One simplification here: we know for a fact that the item filter is
        // neither null nor 'include all', for most cases; the only exception
        // being FIELD_NAME handling
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
        }
    }
}","public void test05454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, true);
    try {
        filteringParserDelegate0._nextTokenWithBuffering((TokenFilterContext) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when a new potentially included context is found.
 */"
"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            return t;
        }
        TokenFilter f;
        // One simplification here: we know for a fact that the item filter is
        // neither null nor 'include all', for most cases; the only exception
        // being FIELD_NAME handling
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
        }
    }
}","public void test05555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""aEq"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 49, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, pipedOutputStream0, byteArray0, 33, false);
    FilteringGeneratorDelegate filteringGeneratorDelegate0 = new FilteringGeneratorDelegate(uTF8JsonGenerator0, tokenFilter0, false, false);
    TokenFilterContext tokenFilterContext0 = filteringGeneratorDelegate0._filterContext;
    try {
        filteringParserDelegate0._nextTokenWithBuffering(tokenFilterContext0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'aEq': was expecting ('true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when a new potentially included context is found.
 */"
"protected final JsonToken _nextToken2() throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            _currToken = t;
            return t;
        }
        TokenFilter f;
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        if (_includePath) {
                            return (_currToken = t);
                        }
                        //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
        }
    }
}","public void test05656() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0._nextToken2();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}","/**
 * Offlined handling for cases where there was no buffered token to
 * return, and the token read next could not be returned as-is,
 * at least not yet, but where we have not yet established that
 * buffering is needed.
 */"
"protected final JsonToken _nextToken2() throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            _currToken = t;
            return t;
        }
        TokenFilter f;
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        if (_includePath) {
                            return (_currToken = t);
                        }
                        //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
        }
    }
}","public void test05757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, true);
    try {
        filteringParserDelegate0._nextToken2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Offlined handling for cases where there was no buffered token to
 * return, and the token read next could not be returned as-is,
 * at least not yet, but where we have not yet established that
 * buffering is needed.
 */"
"protected final JsonToken _nextToken2() throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            _currToken = t;
            return t;
        }
        TokenFilter f;
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        if (_includePath) {
                            return (_currToken = t);
                        }
                        //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
        }
    }
}","public void test05858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""-.mfBBFyC7"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    try {
        filteringParserDelegate0._nextToken2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('.' (code 46)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Offlined handling for cases where there was no buffered token to
 * return, and the token read next could not be returned as-is,
 * at least not yet, but where we have not yet established that
 * buffering is needed.
 */"
"public abstract boolean hasCurrentToken();","public void test05959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader(""^9a}P7053/!aNDw/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    JsonParser jsonParser0 = filteringParserDelegate0.skipChildren();
    assertFalse(jsonParser0.hasCurrentToken());
}","/**
 * Method for checking whether parser currently points to
 * a token (and data for that token is available).
 * Equivalent to check for <code>parser.getCurrentToken() != null</code>.
 *
 * @return True if the parser just returned a valid
 *   token via {@link #nextToken}; false otherwise (parser
 *   was just constructed, encountered end-of-input
 *   and returned null from {@link #nextToken}, or the token
 *   has been consumed)
 */"
"@Override
public JsonToken nextValue() throws IOException {
    // Re-implemented same as ParserMinimalBase:
    JsonToken t = nextToken();
    if (t == JsonToken.FIELD_NAME) {
        t = nextToken();
    }
    return t;
}","public void test06060() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    filteringParserDelegate0.nextValue();
}",""
"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot) throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            return t;
        }
        TokenFilter f;
        // One simplification here: we know for a fact that the item filter is
        // neither null nor 'include all', for most cases; the only exception
        // being FIELD_NAME handling
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        return _nextBuffered(buffRoot);
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
        }
    }
}","public void test06161() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    TokenFilterContext tokenFilterContext0 = filteringParserDelegate0._exposedContext;
    filteringParserDelegate0._nextTokenWithBuffering(tokenFilterContext0);
}","/**
 * Method called when a new potentially included context is found.
 */"
"protected final JsonToken _nextToken2() throws IOException {
    main_loop: while (true) {
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // is this even legal?
            _currToken = t;
            return t;
        }
        TokenFilter f;
        switch(t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) {
                    // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;
            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;
            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) {
                        // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    _itemFilter = f;
                    if (f == TokenFilter.INCLUDE_ALL) {
                        if (_includePath) {
                            return (_currToken = t);
                        }
                        //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;
            default:
                // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                        return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
        }
    }
}","public void test06262() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    filteringParserDelegate0._nextToken2();
}","/**
 * Offlined handling for cases where there was no buffered token to
 * return, and the token read next could not be returned as-is,
 * at least not yet, but where we have not yet established that
 * buffering is needed.
 */"
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test06363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""\"""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    try {
        filteringParserDelegate0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test06464() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    filteringParserDelegate0.nextToken();
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
@Override
public JsonToken nextToken() throws IOException {
    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
    //    conditionals; and it seems odd to return `null` but NOT considering input
    //    as closed... would love a rewrite to simplify/clear up logic here.
    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
    // check for no buffered context _exposedContext - null
    // If all the conditions matches then check for scalar / non-scalar property
    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
        // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
        // matched once, return null
        if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
            return (_currToken = null);
        }
    }
    // Anything buffered?
    TokenFilterContext ctxt = _exposedContext;
    if (ctxt != null) {
        while (true) {
            JsonToken t = ctxt.nextTokenToRead();
            if (t != null) {
                _currToken = t;
                return t;
            }
            // all done with buffered stuff?
            if (ctxt == _headContext) {
                _exposedContext = null;
                if (ctxt.inArray()) {
                    t = delegate.getCurrentToken();
                    // Is this guaranteed to work without further checks?
                    //                        if (t != JsonToken.START_ARRAY) {
                    _currToken = t;
                    return t;
                }
                // Almost! Most likely still have the current token;
                // with the sole exception of
                /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                break;
            }
            // If not, traverse down the context chain
            ctxt = _headContext.findChildOf(ctxt);
            _exposedContext = ctxt;
            if (ctxt == null) {
                // should never occur
                throw _constructError(""Unexpected problem: chain of filtered context broken"");
            }
        }
    }
    // If not, need to read more. If we got any:
    JsonToken t = delegate.nextToken();
    if (t == null) {
        // no strict need to close, since we have no state here
        _currToken = t;
        return t;
    }
    // otherwise... to include or not?
    TokenFilter f;
    switch(t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;
        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) {
                // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;
        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;
        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            // returns START_OBJECT but also marks it handled
                            t = _headContext.nextTokenToRead();
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }
        default:
            // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                f = _headContext.checkValue(f);
                if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) {
                    return (_currToken = t);
                }
            }
            // Otherwise not included (leaves must be explicitly included)
            break;
    }
    // We get here if token was not yet found; offlined handling
    return _nextToken2();
}","public void test06565() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, true);
    try {
        filteringParserDelegate0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public JsonToken getLastClearedToken() {
    return _lastClearedToken;
}","public void test06666() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    filteringParserDelegate0.clearCurrentToken();
    assertNull(filteringParserDelegate0.getLastClearedToken());
}",""
"// !!! TODO: Verify it works as expected: copied from standard JSON parser impl
@Override
public String getCurrentName() throws IOException {
    JsonStreamContext ctxt = _filterContext();
    if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {
        JsonStreamContext parent = ctxt.getParent();
        return (parent == null) ? null : parent.getCurrentName();
    }
    return ctxt.getCurrentName();
}","public void test06767() throws Throwable {
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate((JsonParser) null);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParserDelegate0, tokenFilter0, false, false);
    String string0 = filteringParserDelegate0.getCurrentName();
    assertNull(string0);
}",""
"@Override
public boolean isExpectedStartObjectToken() {
    return _currToken == JsonToken.START_OBJECT;
}","public void test06868() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    boolean boolean0 = filteringParserDelegate0.isExpectedStartObjectToken();
    assertFalse(boolean0);
}",""
"@Override
public final boolean hasToken(JsonToken t) {
    return (_currToken == t);
}","public void test06969() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    boolean boolean0 = filteringParserDelegate0.hasToken((JsonToken) null);
    assertTrue(boolean0);
}",""
"@Override
public final boolean hasToken(JsonToken t) {
    return (_currToken == t);
}","public void test07070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    boolean boolean0 = filteringParserDelegate0.hasToken(jsonToken0);
    assertFalse(boolean0);
}",""
"@Override
public boolean hasTokenId(int id) {
    final JsonToken t = _currToken;
    if (t == null) {
        return (JsonTokenId.ID_NO_TOKEN == id);
    }
    return t.id() == id;
}","public void test07171() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    boolean boolean0 = filteringParserDelegate0.hasTokenId((-54));
    assertFalse(boolean0);
}",""
"@Override
public boolean hasTokenId(int id) {
    final JsonToken t = _currToken;
    if (t == null) {
        return (JsonTokenId.ID_NO_TOKEN == id);
    }
    return t.id() == id;
}","public void test07272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    boolean boolean0 = filteringParserDelegate0.hasTokenId(0);
    assertTrue(boolean0);
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test07373() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    boolean boolean0 = filteringParserDelegate0.hasCurrentToken();
    assertFalse(boolean0);
}",""
"@Override
public final int currentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test07474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    int int0 = filteringParserDelegate0.currentTokenId();
    assertEquals(0, int0);
}",""
"@Override
public final int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test07575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    int int0 = filteringParserDelegate0.getCurrentTokenId();
    assertEquals(0, int0);
}",""
"@Override
public double getValueAsDouble(double defaultValue) throws IOException {
    return delegate.getValueAsDouble(defaultValue);
}","public void test07676() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    double double0 = filteringParserDelegate0.getValueAsDouble(0.0);
    assertEquals(0.0, double0, 0.01);
}",""
"@Override
public long getValueAsLong(long defaultValue) throws IOException {
    return delegate.getValueAsLong(defaultValue);
}","public void test07777() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsLong(0L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, coercion/conversion
    /**********************************************************
     */
@Override
public int getValueAsInt() throws IOException {
    return delegate.getValueAsInt();
}","public void test07878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, true);
    int int0 = filteringParserDelegate0.getValueAsInt();
    assertEquals(0, int0);
}",""
"@Override
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    return delegate.getBinaryValue(b64variant);
}","public void test07979() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getBinaryValue((Base64Variant) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public short getShortValue() throws IOException {
    return delegate.getShortValue();
}","public void test08080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.getShortValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public int getTextLength() throws IOException {
    return delegate.getTextLength();
}","public void test08181() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getTextLength();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {
    return delegate.readBinaryValue(b64variant, out);
}","public void test08282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    try {
        filteringParserDelegate0.readBinaryValue((Base64Variant) null, (OutputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public long getLongValue() throws IOException {
    return delegate.getLongValue();
}","public void test08383() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""={o0L|mch"");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2497), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-2154), (-2497), true);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, false);
    try {
        filteringParserDelegate0.getLongValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: -2153]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean getValueAsBoolean() throws IOException {
    return delegate.getValueAsBoolean();
}","public void test08484() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsBoolean();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"/*
    /**********************************************************
    /* Extended API
    /**********************************************************
     */
public TokenFilter getFilter() {
    return rootFilter;
}","public void test08585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    TokenFilter tokenFilter1 = filteringParserDelegate0.getFilter();
    assertSame(tokenFilter0, tokenFilter1);
}",""
"@Override
public char[] getTextCharacters() throws IOException {
    return delegate.getTextCharacters();
}","public void test08686() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    char[] charArray0 = filteringParserDelegate0.getTextCharacters();
    assertNull(charArray0);
}",""
"public long getByteOffset() {
    return _totalBytes;
}","public void test08787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    JsonLocation jsonLocation0 = filteringParserDelegate0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"@Override
public NumberType getNumberType() throws IOException {
    return delegate.getNumberType();
}","public void test08888() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    try {
        filteringParserDelegate0.getNumberType();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public double getValueAsDouble() throws IOException {
    return delegate.getValueAsDouble();
}","public void test08989() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsDouble();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public JsonLocation getTokenLocation() {
    return delegate.getTokenLocation();
}","public void test09090() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    JsonLocation jsonLocation0 = filteringParserDelegate0.getTokenLocation();
    assertEquals(500, JsonLocation.MAX_CONTENT_SNIPPET);
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, numeric
    /**********************************************************
     */
@Override
public BigInteger getBigIntegerValue() throws IOException {
    return delegate.getBigIntegerValue();
}","public void test09191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.getBigIntegerValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean getBooleanValue() throws IOException {
    return delegate.getBooleanValue();
}","public void test09292() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.getBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not of boolean type
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getMatchCount() {
    return _matchCount;
}","public void test09393() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, false);
    int int0 = filteringParserDelegate0.getMatchCount();
    assertEquals(0, int0);
}","/**
 * Accessor for finding number of matches, where specific token and sub-tree
 * starting (if structured type) are passed.
 */"
"@Override
public int getValueAsInt(int defaultValue) throws IOException {
    return delegate.getValueAsInt(defaultValue);
}","public void test09494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    int int0 = filteringParserDelegate0.getValueAsInt(1481);
    assertEquals(1481, int0);
}",""
"@Override
public JsonToken getLastClearedToken() {
    return _lastClearedToken;
}","public void test09595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    filteringParserDelegate0.getLastClearedToken();
}",""
"@Override
public int getTextOffset() throws IOException {
    return delegate.getTextOffset();
}","public void test09696() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    int int0 = filteringParserDelegate0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public void overrideCurrentName(String name) {
    /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,
         *    what to do with it... Delegation won't work for sure, so let's for
         *    now throw an exception
         */
    throw new UnsupportedOperationException(""Can not currently override name during filtering read"");
}","public void test09797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.overrideCurrentName(""~0#;X%@"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Can not currently override name during filtering read
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public int getIntValue() throws IOException {
    return delegate.getIntValue();
}","public void test09898() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader(""kE"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2840, 33, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, false);
    try {
        filteringParserDelegate0.getIntValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 2841]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasTextCharacters() {
    return delegate.hasTextCharacters();
}","public void test09999() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    boolean boolean0 = filteringParserDelegate0.hasTextCharacters();
    assertFalse(boolean0);
}",""
"@Override
public BigDecimal getDecimalValue() throws IOException {
    return delegate.getDecimalValue();
}","public void test100100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    try {
        filteringParserDelegate0.getDecimalValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text
    /**********************************************************
     */
@Override
public String getText() throws IOException {
    return delegate.getText();
}","public void test101101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    String string0 = filteringParserDelegate0.getText();
    assertNull(string0);
}",""
"@Override
public long getValueAsLong() throws IOException {
    return delegate.getValueAsLong();
}","public void test102102() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsLong();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"public final boolean inRoot() {
    return _type == TYPE_ROOT;
}","public void test103103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    JsonStreamContext jsonStreamContext0 = filteringParserDelegate0.getParsingContext();
    assertTrue(jsonStreamContext0.inRoot());
}","/**
 * Method that returns true if this context is a Root context;
 * that is, content is being read from or written to without
 * enclosing array or object structure.
 */"
"/*
    /**********************************************************
    /* Public API, access to token values, other
    /**********************************************************
     */
@Override
public Object getEmbeddedObject() throws IOException {
    return delegate.getEmbeddedObject();
}","public void test104104() throws Throwable {
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getEmbeddedObject();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public byte getByteValue() throws IOException {
    return delegate.getByteValue();
}","public void test105105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 726, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, true);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.getByteValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public double getDoubleValue() throws IOException {
    return delegate.getDoubleValue();
}","public void test106106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Unexpected problem: chain of filtered context broken"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1063, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    try {
        filteringParserDelegate0.getDoubleValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, token accessors
    /**********************************************************
     */
@Override
public JsonToken getCurrentToken() {
    return _currToken;
}","public void test107107() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, false, false);
    filteringParserDelegate0.getCurrentToken();
}",""
"@Override
public String getValueAsString(String defaultValue) throws IOException {
    return delegate.getValueAsString(defaultValue);
}","public void test108108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""-.mfBBFyC7"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    TokenFilter tokenFilter0 = new TokenFilter();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, false, false);
    String string0 = filteringParserDelegate0.getValueAsString("""");
    assertEquals("""", string0);
}",""
"@Override
public JsonToken currentToken() {
    return _currToken;
}","public void test109109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, false);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    filteringParserDelegate0.currentToken();
}",""
"@Override
public float getFloatValue() throws IOException {
    return delegate.getFloatValue();
}","public void test110110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1545, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, (TokenFilter) null, false, false);
    try {
        filteringParserDelegate0.getFloatValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String getValueAsString() throws IOException {
    return delegate.getValueAsString();
}","public void test111111() throws Throwable {
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        filteringParserDelegate0.getValueAsString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.filter.FilteringParserDelegate"", e);
    }
}",""
"@Override
public Number getNumberValue() throws IOException {
    return delegate.getNumberValue();
}","public void test112112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""YzRdC3V0K!)*"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1155, 0, true);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);
    try {
        filteringParserDelegate0.getNumberValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not numeric, can not use numeric value accessors
        //  at [Source: UNKNOWN; line: 1, column: 1156]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
