focal_method,test_prefix,docstring
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", true);
    File file0 = MockFile.createTempFile(""RyxR&5%n*9%D1/z|"", ""4"", (File) null);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(file0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0);
    int int0 = uTF8JsonGenerator0.getOutputBuffered();
    assertEquals(0, int0);
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0001() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", true);
    File file0 = MockFile.createTempFile(""RyxR&5%n*9%D1/z|"", ""4"", (File) null);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(file0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0);
    int int0 = uTF8JsonGenerator0.getOutputBuffered();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayBuilder0);
    Object object0 = uTF8JsonGenerator0.getOutputTarget();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Overridden configuration methods
    /**********************************************************
     */
@Override
public Object getOutputTarget() {
    return _outputStream;
}","public void test0025() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayBuilder0);
    Object object0 = uTF8JsonGenerator0.getOutputTarget();
    assertNotNull(object0);
}",""
"// @since 2.7.5: default impl that should work fine
public void writeArray(int[] array, int offset, int length) throws IOException {
    writeStartArray();
    for (int i = offset, end = offset + length; i < end; ++i) {
        writeNumber(array[i]);
    }
    writeEndArray();
}","public void test0036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    JsonGenerator jsonGenerator0 = uTF8JsonGenerator0.useDefaultPrettyPrinter();
    int[] intArray0 = new int[5];
    // Undeclared exception!
    try {
        jsonGenerator0.writeArray(intArray0, 56319, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 56319
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0047() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeNullField("""");
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(7, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    if (_cfgPrettyPrinter != null) {
        _writePPFieldName(name);
        return;
    }
    final int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {
        // need comma
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_COMMA;
    }
    /* To support [JACKSON-46], we'll do this:
         * (Question: should quoting of spaces (etc) still be enabled?)
         */
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    // Does it fit in buffer?
    if (len > _charBufferLength) {
        // no, offline
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(name, 0, len);
    } else {
        _writeStringSegments(name, 0, len);
    }
    // and closing quotes; need room for one more char:
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0058() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""9&w"", false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2610), (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeBooleanField(""9&w"", false);
    try {
        uTF8JsonGenerator0.writeFieldName(""?L.y+#mX<i~*"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not write a field name, expecting a value
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"public final void writeBinaryField(String fieldName, byte[] data) throws IOException {
    writeFieldName(fieldName);
    writeBinary(data);
}","public void test0069() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""%"");
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 353, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    // Undeclared exception!
    uTF8JsonGenerator0.writeBinaryField(""%"", (byte[]) null);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that contains specified data in base64-encoded form.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeBinary(value);
 * </pre>
 */"
"public final void writeBinaryField(String fieldName, byte[] data) throws IOException {
    writeFieldName(fieldName);
    writeBinary(data);
}","public void test00710() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[2];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeBinaryField("".OopaW8G[R#4"", byteArray0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.ByteArrayOutputStream"", e);
    }
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that contains specified data in base64-encoded form.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeBinary(value);
 * </pre>
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    if (_cfgPrettyPrinter != null) {
        _writePPFieldName(name);
        return;
    }
    final int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {
        // need comma
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_COMMA;
    }
    /* To support [JACKSON-46], we'll do this:
         * (Question: should quoting of spaces (etc) still be enabled?)
         */
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    // Does it fit in buffer?
    if (len > _charBufferLength) {
        // no, offline
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(name, 0, len);
    } else {
        _writeStringSegments(name, 0, len);
    }
    // and closing quotes; need room for one more char:
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test00811() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""%"");
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName("""");
    assertArrayEquals(new byte[] { (byte) 34, (byte) 44, (byte) 34 }, byteArray0);
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test00812() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""%"");
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName("""");
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test01115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream(pipedInputStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, pipedOutputStream0);
    uTF8JsonGenerator0.writeNumber(1.0F);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test01217() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""%"");
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeStartObject();
    SerializedString serializedString0 = new SerializedString(""%"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test01623() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArray((int[]) null, 1, 0);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public final void writeEndArray() throws IOException {
    if (!_writeContext.inArray()) {
        _reportError(""Current context not an ARRAY but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_RBRACKET;
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test01724() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, false);
    try {
        uTF8JsonGenerator0.writeEndArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current context not an ARRAY but ROOT
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(text, offset, len);
    } else {
        _writeStringSegments(text, offset, len);
    }
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test01825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    JsonGenerator jsonGenerator0 = uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeStartObject();
    char[] charArray0 = iOContext0.allocTokenBuffer(981);
    SerializedString serializedString0 = new SerializedString(""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    jsonGenerator0.writeFieldName((SerializableString) serializedString0);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString(charArray0, 931, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4000
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"@Override
public final void writeEndObject() throws IOException {
    if (!_writeContext.inObject()) {
        _reportError(""Current context not an object but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_RCURLY;
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test02028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    try {
        uTF8JsonGenerator0.writeEndObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current context not an object but ROOT
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"protected final void _writePPFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {
        _cfgPrettyPrinter.writeObjectEntrySeparator(this);
    } else {
        _cfgPrettyPrinter.beforeObjectEntries(this);
    }
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    if (len > _charBufferLength) {
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    name.getChars(0, len, _charBuffer, 0);
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(_charBuffer, 0, len);
    } else {
        _writeStringSegments(_charBuffer, 0, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    try {
        uTF8JsonGenerator0._writePPFieldName(""pAc!_U]ga(C7v"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not write a field name, expecting a value
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Specialized version of <code>_writeFieldName</code>, off-lined
 * to keep the ""fast path"" as simple (and hopefully fast) as possible.
 */"
"protected final void _writePPFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {
        _cfgPrettyPrinter.writeObjectEntrySeparator(this);
    } else {
        _cfgPrettyPrinter.beforeObjectEntries(this);
    }
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    if (len > _charBufferLength) {
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    name.getChars(0, len, _charBuffer, 0);
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(_charBuffer, 0, len);
    } else {
        _writeStringSegments(_charBuffer, 0, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02230() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 0);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0._writePPFieldName(""LDp?Z6>o?]`c$Ut?h"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}","/**
 * Specialized version of <code>_writeFieldName</code>, off-lined
 * to keep the ""fast path"" as simple (and hopefully fast) as possible.
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    if (_cfgPrettyPrinter != null) {
        _writePPFieldName(name);
        return;
    }
    final int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {
        // need comma
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_COMMA;
    }
    /* To support [JACKSON-46], we'll do this:
         * (Question: should quoting of spaces (etc) still be enabled?)
         */
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    // Does it fit in buffer?
    if (len > _charBufferLength) {
        // no, offline
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(name, 0, len);
    } else {
        _writeStringSegments(name, 0, len);
    }
    // and closing quotes; need room for one more char:
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02331() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""%"");
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeStartObject();
    // Undeclared exception!
    uTF8JsonGenerator0.writeFieldName("" bytes (out of "");
}",""
"protected final void _writePPFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {
        _cfgPrettyPrinter.writeObjectEntrySeparator(this);
    } else {
        _cfgPrettyPrinter.beforeObjectEntries(this);
    }
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    if (len > _charBufferLength) {
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    name.getChars(0, len, _charBuffer, 0);
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(_charBuffer, 0, len);
    } else {
        _writeStringSegments(_charBuffer, 0, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02432() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    try {
        uTF8JsonGenerator0._writePPFieldName(serializedString0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not write a field name, expecting a value
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Specialized version of <code>_writeFieldName</code>, off-lined
 * to keep the ""fast path"" as simple (and hopefully fast) as possible.
 */"
"protected final void _writePPFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {
        _cfgPrettyPrinter.writeObjectEntrySeparator(this);
    } else {
        _cfgPrettyPrinter.beforeObjectEntries(this);
    }
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    if (len > _charBufferLength) {
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    name.getChars(0, len, _charBuffer, 0);
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(_charBuffer, 0, len);
    } else {
        _writeStringSegments(_charBuffer, 0, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02533() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((double) 2);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    // Undeclared exception!
    try {
        uTF8JsonGenerator0._writePPFieldName(serializedString0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}","/**
 * Specialized version of <code>_writeFieldName</code>, off-lined
 * to keep the ""fast path"" as simple (and hopefully fast) as possible.
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    // First: if we can't guarantee it all fits, quoted, within output, offline
    final int len = text.length();
    if (len > _outputMaxContiguous) {
        // nope: off-line handling
        _writeStringSegments(text, true);
        return;
    }
    if ((_outputTail + len) >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // we checked space already above
    _writeStringSegment(text, 0, len);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02736() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeString(""oFW-E/GNu3&kS#O"");
    assertArrayEquals(new byte[] { (byte) 117, (byte) 51, (byte) 38, (byte) 107, (byte) 83, (byte) 35, (byte) 79, (byte) 34, (byte) 78 }, byteArray0);
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test02737() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeString(""oFW-E/GNu3&kS#O"");
    assertEquals(8, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    // First: if we can't guarantee it all fits, quoted, within output, offline
    final int len = text.length();
    if (len > _outputMaxContiguous) {
        // nope: off-line handling
        _writeStringSegments(text, true);
        return;
    }
    if ((_outputTail + len) >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // we checked space already above
    _writeStringSegment(text, 0, len);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02838() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString((String) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    // First: if we can't guarantee it all fits, quoted, within output, offline
    final int len = text.length();
    if (len > _outputMaxContiguous) {
        // nope: off-line handling
        _writeStringSegments(text, true);
        return;
    }
    if ((_outputTail + len) >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // we checked space already above
    _writeStringSegment(text, 0, len);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test02940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeString("""");
    assertArrayEquals(new byte[] { (byte) 34 }, byteArray0);
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(text, offset, len);
    } else {
        _writeStringSegments(text, offset, len);
    }
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test03041() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    char[] charArray0 = iOContext0.allocTokenBuffer(981);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString(charArray0, 931, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4000
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test03160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test03161() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public char[] allocNameCopyBuffer(int minSize) {
    _verifyAlloc(_nameCopyBuffer);
    return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, minSize));
}","public void test03162() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    assertEquals(200, charArray0.length);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test03172() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test03173() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test03190() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test03191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test03194() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test03195() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test03196() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test03197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test03198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test03199() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test031100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test031101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test031102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test031103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(text, offset, len);
    } else {
        _writeStringSegments(text, offset, len);
    }
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test031104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertEquals(200, charArray0.length);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test031117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test031118() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test031121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test031122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test031123() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test031124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test031125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test031126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test031127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test031128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test031129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test031130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    char[] charArray0 = iOContext0.allocNameCopyBuffer(0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeString(charArray0, 1, 3);
    assertEquals(20, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test032151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test032152() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertNull(iOContext0.getEncoding());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test032153() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test032184() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test032185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertNull(iOContext0.getEncoding());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test032186() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test032187() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test032188() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test032189() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test032190() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test032191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test032192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test032193() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(333, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test032194() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test032195() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test032197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    SerializedString serializedString0 = new SerializedString(""#j+lVyQ79t"");
    assertEquals(10, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test032198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    SerializedString serializedString0 = new SerializedString(""#j+lVyQ79t"");
    assertEquals(""#j+lVyQ79t"", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test032199() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    SerializedString serializedString0 = new SerializedString(""#j+lVyQ79t"");
    assertEquals(""#j+lVyQ79t"", serializedString0.getValue());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test033219() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test033220() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test033225() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    assertEquals(""Qqj_MZWi|R<Ys"", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test033226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    assertEquals(13, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test033227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    assertEquals(""Qqj_MZWi|R<Ys"", serializedString0.toString());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test033243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test033244() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test033247() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test033248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertEquals(55296, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test033249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test033250() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test033251() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertEquals(55296, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test033252() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test033253() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test033254() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test033255() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test033256() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    SerializedString serializedString0 = new SerializedString(""Qqj_MZWi|R<Ys"");
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 55296, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 55296, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test034276() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test034277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test034296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test034297() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test034300() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test034301() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(4, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test034302() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test034303() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test034304() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test034305() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test034306() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test034307() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test034308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test034309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test034313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test034314() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test034315() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Output method implementations, unprocessed (""raw"")
    /**********************************************************
     */
@Override
public void writeRaw(String text) throws IOException {
    final int len = text.length();
    final char[] buf = _charBuffer;
    if (len <= buf.length) {
        text.getChars(0, len, buf, 0);
        writeRaw(buf, 0, len);
    } else {
        writeRaw(text, 0, len);
    }
}","public void test034316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertArrayEquals(new byte[] { (byte) 115, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test034330() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test034331() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test034334() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test034335() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertEquals(4, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test034336() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test034337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test034338() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test034339() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test034340() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test034341() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test034342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test034343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test034358() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test034359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test034362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test034363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(4, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test034364() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test034365() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test034366() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test034367() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test034368() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test034369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test034370() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test034371() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test034372() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test034373() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test034374() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3137);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    SerializedString serializedString0 = (SerializedString) uTF8JsonGenerator0._rootValueSeparator;
    uTF8JsonGenerator0.writeRaw(""s"");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test035393() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test035394() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test035411() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test035412() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test035415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test035416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test035417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test035418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test035419() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test035420() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test035421() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test035422() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test035423() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test035424() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test035426() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    assertEquals(""lehtU'S("", serializedString0.toString());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test035427() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    assertEquals(8, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test035428() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    assertEquals(""lehtU'S("", serializedString0.getValue());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test035441() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test035442() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test035445() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test035446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test035447() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test035448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test035449() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test035450() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test035451() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(10, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test035452() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test035453() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test035454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test035455() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(""lehtU'S("", serializedString0.toString());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test035456() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(8, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test035457() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""lehtU'S("");
    uTF8JsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(""lehtU'S("", serializedString0.getValue());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test036480() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test036495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test036496() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test036513() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals((-797), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test036514() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test036515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test036516() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test036517() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test036518() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test036519() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test036520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test036521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test036522() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    _writeBytes(text, offset, length);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test036523() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 0, (byte) 0, (byte) 34 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test036537() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test036538() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test036555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertEquals((-797), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test036556() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test036557() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test036558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test036559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test036560() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test036561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test036562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test036563() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test036564() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    byte[] byteArray0 = new byte[4];
    MockFile mockFile0 = new MockFile(""~k>>S%\""5HLfkrblp"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-797), (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test037583() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test037584() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test037587() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test037602() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test037603() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test037620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test037621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test037622() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test037623() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test037624() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test037625() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test037626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test037627() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test037628() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test037629() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    _writeBytes(text, offset, length);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test037630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertArrayEquals(new byte[] { (byte) 34 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test037644() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test037645() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test037662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test037663() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test037664() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test037665() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test037666() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test037667() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test037668() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test037669() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test037670() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test037671() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 2, 779);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test038691() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test038692() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test038693() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test038708() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test038709() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test038710() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test038711() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test038712() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(333, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test038713() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test038714() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test038715() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test038716() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test038717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test038718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test038719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test038720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertArrayEquals(new byte[] { (byte) 92, (byte) 34, (byte) 34, (byte) 117, (byte) 48, (byte) 48, (byte) 48, (byte) 48, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test038734() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test038735() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test038736() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test038737() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test038738() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test038739() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(333, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test038740() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test038741() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test038742() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test038743() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test038744() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test038745() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test039784() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test039785() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test039788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test039789() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(1222, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test039790() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test039791() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test039792() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test039793() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test039794() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test039795() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test039796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test039797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test039798() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertArrayEquals(new byte[] { (byte) 34 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test039812() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test039813() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test039816() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test039817() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertEquals(1222, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test039818() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test039819() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test039820() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test039821() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test039822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test039823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test039824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test039825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1222, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 1, 0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test040862() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test040863() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test040866() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test040867() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test040868() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test040869() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test040870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test040871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test040872() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test040873() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test040874() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test040875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeRaw(String text, int offset, int len) throws IOException {
    final char[] buf = _charBuffer;
    // minor optimization: see if we can just get and copy
    if (len <= buf.length) {
        text.getChars(offset, offset + len, buf, 0);
        writeRaw(buf, 0, len);
        return;
    }
    // If not, need segmented approach. For speed, let's also use input buffer
    // size that is guaranteed to fit in output buffer; each char can expand to
    // at most 3 bytes, so at most 1/3 of buffer size.
    // == (1/4 + 1/16) == 5/16
    final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4);
    final int maxBytes = maxChunk * 3;
    while (len > 0) {
        int len2 = Math.min(maxChunk, len);
        text.getChars(offset, offset + len2, buf, 0);
        if ((_outputTail + maxBytes) > _outputEnd) {
            _flushBuffer();
        }
        // If this is NOT the last segment and if the last character looks like
        // split surrogate second half, drop it
        if (len > 0) {
            char ch = buf[len2 - 1];
            if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {
                --len2;
            }
        }
        _writeRawSegment(buf, 0, len2);
        offset += len2;
        len -= len2;
    }
}","public void test040876() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeRaw(""Too few bytes available: missing "", 55296, 55296);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test041915() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test041916() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test041919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test041920() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test041921() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test041922() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test041923() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test041924() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test041925() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test041926() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test041927() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test041928() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeRaw(String text, int offset, int len) throws IOException {
    final char[] buf = _charBuffer;
    // minor optimization: see if we can just get and copy
    if (len <= buf.length) {
        text.getChars(offset, offset + len, buf, 0);
        writeRaw(buf, 0, len);
        return;
    }
    // If not, need segmented approach. For speed, let's also use input buffer
    // size that is guaranteed to fit in output buffer; each char can expand to
    // at most 3 bytes, so at most 1/3 of buffer size.
    // == (1/4 + 1/16) == 5/16
    final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4);
    final int maxBytes = maxChunk * 3;
    while (len > 0) {
        int len2 = Math.min(maxChunk, len);
        text.getChars(offset, offset + len2, buf, 0);
        if ((_outputTail + maxBytes) > _outputEnd) {
            _flushBuffer();
        }
        // If this is NOT the last segment and if the last character looks like
        // split surrogate second half, drop it
        if (len > 0) {
            char ch = buf[len2 - 1];
            if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {
                --len2;
            }
        }
        _writeRawSegment(buf, 0, len2);
        offset += len2;
        len -= len2;
    }
}","public void test041929() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertArrayEquals(new byte[] { (byte) 76 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test041943() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test041944() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test041947() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test041948() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test041949() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test041950() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test041951() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test041952() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test041953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test041954() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test041955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test041956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeRaw(""LSczc;<-3rzo^z"", 0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test042975() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test042976() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test042980() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals(0, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test042981() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals("""", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test042982() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals("""", serializedString0.getValue());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0421013() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0421014() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0421031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0421032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0421033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0421034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0421035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0421036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0421037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0421038() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0421039() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0421040() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0421053() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0421054() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test0421071() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals(0, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test0421072() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals("""", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test0421073() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals("""", serializedString0.getValue());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0421074() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0421075() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0421076() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0421077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0421078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0421079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0421080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0421081() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0421082() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0421083() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    MockFile mockFile0 = new MockFile("""", ""Split surrogate on writeRaw() input (last character): first character 0x%4x"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    SerializedString serializedString0 = new SerializedString("""");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockPrintStream0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, bufferedOutputStream0);
    uTF8JsonGenerator0.writeRaw((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0431102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0431103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0431120() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0431121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0431124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0431125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0431126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0431127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0431128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0431129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0431130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0431131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0431132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0431133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test0431135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals(0, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test0431136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals("""", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test0431137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    assertEquals("""", serializedString0.getValue());
}",""
"// since 2.5
@Override
public void writeRawValue(SerializableString text) throws IOException {
    _verifyValueWrite(WRITE_RAW);
    byte[] raw = text.asUnquotedUTF8();
    if (raw.length > 0) {
        _writeBytes(raw);
    }
}","public void test0431138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0431150() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0431151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0431154() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0431155() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0431156() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0431157() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0431158() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0431159() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0431160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0431161() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0431162() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0431163() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test0431164() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test0431165() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals("""", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test0431166() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString("""");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals("""", serializedString0.getValue());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0441185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0441186() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0441203() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0441204() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0441207() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0441208() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0441209() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0441210() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0441211() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0441212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(115, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0441213() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0441214() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0441215() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0441216() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public final int charLength() {
    return _value.length();
}","public void test0441218() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test0441219() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    assertEquals(""8"", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test0441220() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    assertEquals(""8"", serializedString0.getValue());
}",""
"// since 2.5
@Override
public void writeRawValue(SerializableString text) throws IOException {
    _verifyValueWrite(WRITE_RAW);
    byte[] raw = text.asUnquotedUTF8();
    if (raw.length > 0) {
        _writeBytes(raw);
    }
}","public void test0441221() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0441233() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0441234() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0441237() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0441238() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0441239() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0441240() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0441241() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0441242() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0441243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(115, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0441244() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0441245() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0441246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public final int charLength() {
    return _value.length();
}","public void test0441247() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test0441248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(""8"", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test0441249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 115, (ObjectCodec) null, byteArrayOutputStream0);
    SerializedString serializedString0 = new SerializedString(""8"");
    uTF8JsonGenerator0.writeRawValue((SerializableString) serializedString0);
    assertEquals(""8"", serializedString0.getValue());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0451268() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0451269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0451286() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0451287() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0451290() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0451291() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0451292() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0451293() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0451294() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0451295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0451296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0451297() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0451298() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0451299() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, unprocessed (""raw"")
    /**********************************************************
     */
@Override
public void writeRaw(String text) throws IOException {
    final int len = text.length();
    final char[] buf = _charBuffer;
    if (len <= buf.length) {
        text.getChars(0, len, buf, 0);
        writeRaw(buf, 0, len);
    } else {
        writeRaw(text, 0, len);
    }
}","public void test0451300() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0451312() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0451313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0451316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0451317() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0451318() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0451319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0451320() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0451321() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0451322() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0451323() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0451324() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0451325() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw("""");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0461362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0461363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0461366() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0461367() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0461368() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0461369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0461370() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0461371() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0461372() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0461373() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0461374() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0461375() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"// @TODO: rewrite for speed...
@Override
public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {
    // First: if we have 3 x charCount spaces, we know it'll fit just fine
    {
        int len3 = len + len + len;
        if ((_outputTail + len3) > _outputEnd) {
            // maybe we could flush?
            if (_outputEnd < len3) {
                // wouldn't be enough...
                _writeSegmentedRaw(cbuf, offset, len);
                return;
            }
            // yes, flushing brings enough space
            _flushBuffer();
        }
    }
    // now marks the end
    len += offset;
    // Note: here we know there is enough room, hence no output boundary checks
    main_loop: while (offset < len) {
        inner_loop: while (true) {
            int ch = (int) cbuf[offset];
            if (ch > 0x7F) {
                break inner_loop;
            }
            _outputBuffer[_outputTail++] = (byte) ch;
            if (++offset >= len) {
                break main_loop;
            }
        }
        char ch = cbuf[offset++];
        if (ch < 0x800) {
            // 2-byte?
            _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));
            _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));
        } else {
            offset = _outputRawMultiByteChar(ch, cbuf, offset, len);
        }
    }
}","public void test0461376() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    char[] charArray0 = new char[5];
    charArray0[3] = '\u0097';
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeRaw(charArray0, 3, 235);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"@Override
public void writeRaw(char ch) throws IOException {
    if ((_outputTail + 3) >= _outputEnd) {
        _flushBuffer();
    }
    final byte[] bbuf = _outputBuffer;
    if (ch <= 0x7F) {
        bbuf[_outputTail++] = (byte) ch;
    } else if (ch < 0x800) {
        // 2-byte?
        bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));
        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));
    } else {
        /*offset =*/
        _outputRawMultiByteChar(ch, null, 0, 0);
    }
}","public void test0471427() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0471439() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0471440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0471443() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0471444() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0471445() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0471446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0471447() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0471448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0471449() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0471450() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0471451() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0471452() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeRaw('\u0097');
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0481471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0481472() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0481474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0481489() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0481490() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0481491() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0481492() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0481493() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0481494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0481495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0481496() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0481497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0481498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0481499() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0481500() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"// @TODO: rewrite for speed...
@Override
public final void writeRaw(char[] cbuf, int offset, int len) throws IOException {
    // First: if we have 3 x charCount spaces, we know it'll fit just fine
    {
        int len3 = len + len + len;
        if ((_outputTail + len3) > _outputEnd) {
            // maybe we could flush?
            if (_outputEnd < len3) {
                // wouldn't be enough...
                _writeSegmentedRaw(cbuf, offset, len);
                return;
            }
            // yes, flushing brings enough space
            _flushBuffer();
        }
    }
    // now marks the end
    len += offset;
    // Note: here we know there is enough room, hence no output boundary checks
    main_loop: while (offset < len) {
        inner_loop: while (true) {
            int ch = (int) cbuf[offset];
            if (ch > 0x7F) {
                break inner_loop;
            }
            _outputBuffer[_outputTail++] = (byte) ch;
            if (++offset >= len) {
                break main_loop;
            }
        }
        char ch = cbuf[offset++];
        if (ch < 0x800) {
            // 2-byte?
            _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));
            _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));
        } else {
            offset = _outputRawMultiByteChar(ch, cbuf, offset, len);
        }
    }
}","public void test0481501() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertArrayEquals(new byte[] { (byte) (-62), (byte) (-119), (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0481517() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0481518() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0481519() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0481520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0481521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0481522() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0481523() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0481524() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0481525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0481526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0481527() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0481528() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""["", false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""["");
    byte[] byteArray0 = new byte[5];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    char[] charArray0 = new char[7];
    charArray0[2] = '\u0089';
    uTF8JsonGenerator0.writeRaw(charArray0, 1, 2);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0491558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0491572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0491573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0491574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0491575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0491576() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertEquals((-730), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0491577() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0491578() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0491579() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0491580() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0491581() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0491582() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0491583() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertEquals(229, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0491584() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public void writeBinary(byte[] data, int offset, int len) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);
}","public void test0491585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-730), (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 229, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 0, 4);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0501624() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0501625() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0501628() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0501629() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0501630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0501631() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0501632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0501633() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0501634() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(41, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0501635() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0501636() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0501637() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public void writeBinary(byte[] data, int offset, int len) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);
}","public void test0501638() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 65, (byte) 61, (byte) 61 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0501652() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0501653() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0501656() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0501657() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0501658() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0501659() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0501660() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0501661() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0501662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0501663() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertEquals(41, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0501664() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0501665() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeBinary(byteArray0, 1, 1);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0511708() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0511709() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0511712() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0511713() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0511714() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0511715() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0511716() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0511717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0511718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0511719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertEquals(278, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0511720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0511721() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test0511722() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 67, (byte) 73, (byte) 65 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0511737() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0511738() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0511742() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0511743() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0511744() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0511745() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0511746() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0511747() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0511748() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0511749() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertEquals(278, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0511750() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0511751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeNumber(String encodedValue) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(encodedValue);
    } else {
        writeRaw(encodedValue);
    }
}","public void test0511752() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertArrayEquals(new byte[] { (byte) 62, (byte) 45, (byte) 51, (byte) 124 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0511766() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0511767() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0511770() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0511771() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0511772() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0511773() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0511774() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0511775() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0511776() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0511777() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertEquals(278, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0511778() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0511779() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test0511780() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertArrayEquals(new byte[] { (byte) 34, (byte) 65, (byte) 61, (byte) 61 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0511796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0511797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0511801() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0511802() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0511803() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0511804() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0511805() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0511806() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0511807() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0511808() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertEquals(278, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0511809() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0511810() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(244);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 278, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, true);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 3);
    uTF8JsonGenerator0.writeNumber(""`R;[jlIS3|>-3"");
    int int1 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-399));
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0521851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0521852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0521855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0521856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0521857() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0521858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0521859() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0521860() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0521861() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0521862() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0521863() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0521864() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(16, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test0521865() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    try {
        uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (int) (byte) 16);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Too few bytes available: missing 8 bytes (out of 16)
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"/*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */
@Override
public void writeNumber(short s) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 5 digits and possible minus sign
    if ((_outputTail + 6) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedShort(s);
        return;
    }
    _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
}","public void test0531931() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockFile mockFile0 = new MockFile(""Z"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeNumber((short) 1065);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 3
        //
        verifyException(""com.fasterxml.jackson.core.io.NumberOutput"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0541970() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0541971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0541974() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0541975() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0541976() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0541977() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0541978() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0541979() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertEquals((-1445), uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0541980() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0541981() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertEquals(1587, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0541982() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0541983() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */
@Override
public void writeNumber(short s) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 5 digits and possible minus sign
    if ((_outputTail + 6) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedShort(s);
        return;
    }
    _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
}","public void test0541984() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1587, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (-1445), true);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeNumber((short) 16);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1445
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0552023() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0552024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0552027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(36, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0552028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0552029() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0552030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0552031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0552032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0552033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0552034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0552035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0552036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */
@Override
public void writeNumber(short s) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 5 digits and possible minus sign
    if ((_outputTail + 6) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedShort(s);
        return;
    }
    _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
}","public void test0552037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 49, (byte) 55, (byte) 34, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0552051() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0552052() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0552055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertEquals(36, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0552056() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0552057() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0552058() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0552059() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0552060() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0552061() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0552062() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0552063() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0552064() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""RyxR&5%n*9%D1/z|"", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[7];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 36, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumber((short) (byte) 17);
    assertEquals(4, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0562101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0562102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0562105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0562106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0562107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0562108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0562109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0562110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0562111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0562112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0562113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0562114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(255, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test0562115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0562127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0562128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0562131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0562132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0562133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0562134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0562135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0562136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0562137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0562138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0562139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0562140() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(255);
    assertEquals(255, uTF8JsonGenerator0.getFeatureMask());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0572159() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0572160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0572163() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0572178() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0572179() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0572196() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0572197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0572198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0572199() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0572200() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0572201() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0572202() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0572203() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0572204() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0572205() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"// @since 2.7.5: default impl that should work fine
public void writeArray(long[] array, int offset, int length) throws IOException {
    writeStartArray();
    for (int i = offset, end = offset + length; i < end; ++i) {
        writeNumber(array[i]);
    }
    writeEndArray();
}","public void test0572206() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""C_n not currentlr override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""C_n not currentlr override name during filtering read"", ""C_n not currentlr override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    long[] longArray0 = new long[2];
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeArray(longArray0, 0, 339);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0582245() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0582246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0582249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0582250() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0582251() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0582252() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0582253() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0582254() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0582255() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0582256() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0582257() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0582258() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(63, uTF8JsonGenerator0.getFeatureMask());
}",""
"public final void writeNumberField(String fieldName, long value) throws IOException {
    writeFieldName(fieldName);
    writeNumber(value);
}","public void test0582259() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 50, (byte) 34, (byte) 34 }, byteArray0);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that has the specified numeric value. Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeNumber(value);
 * </pre>
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0582273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0582274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0582277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0582278() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0582279() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0582280() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0582281() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0582282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0582283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0582284() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0582285() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0582286() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(229);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 63, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    uTF8JsonGenerator0.writeNumberField("""", (long) 2);
    assertEquals(63, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(long l) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedLong(l);
        return;
    }
    if ((_outputTail + 21) >= _outputEnd) {
        // up to 20 digits, minus sign
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);
}","public void test0592337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0592349() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0592350() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0592353() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0592354() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0592355() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0592356() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0592357() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0592358() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0592359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0592360() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0592361() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0592362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((long) 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0602381() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0602382() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0602392() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0602406() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0602407() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0602408() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0602409() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0602410() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0602411() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0602412() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0602413() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0602414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0602415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0602416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0602417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals((-15), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0602418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeNumber(long l) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedLong(l);
        return;
    }
    if ((_outputTail + 21) >= _outputEnd) {
        // up to 20 digits, minus sign
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);
}","public void test0602419() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0602431() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0602432() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0602433() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0602434() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0602435() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0602436() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0602437() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0602438() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0602439() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals(6, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0602440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0602441() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0602442() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals((-15), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0602443() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber((-745L));
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test0612497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0612509() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0612510() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0612513() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0612514() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0612515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0612516() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0612517() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0612518() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0612519() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0612520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(255, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0612521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0612522() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0622561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0622562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0622565() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0622566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0622567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0622568() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0622569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0622570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0622571() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0622572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0622573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0622574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test0622575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0622587() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0622588() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0622591() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0622592() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0622593() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0622594() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0622595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0622596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0622597() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0622598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(4, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0622599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0622600() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test0632654() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0632666() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0632667() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0632670() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0632671() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0632672() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0632673() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0632674() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0632675() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0632676() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0632677() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0632678() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0632679() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    uTF8JsonGenerator0.writeNumber(bigInteger0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0642700() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0642701() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0642718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0642719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0642722() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0642723() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0642724() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0642725() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0642726() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0642727() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0642728() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0642729() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0642730() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0642731() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test0642732() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0642744() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0642745() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0642748() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0642749() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0642750() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0642751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0642752() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0642753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0642754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0642755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0642756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0642757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.NaN);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test0652808() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0652820() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0652821() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0652824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0652825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0652826() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0652827() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0652828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0652829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0652830() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(8, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0652831() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0652832() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0652833() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0662870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0662871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0662874() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0662875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0662876() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0662877() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0662878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0662879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0662880() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0662881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(21, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0662882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0662883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test0662884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0662896() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0662897() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0662900() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0662901() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0662902() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0662903() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0662904() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0662905() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0662906() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(10, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0662907() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertEquals(21, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0662908() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0662909() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2047);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 21, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber(Double.POSITIVE_INFINITY);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0672946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0672947() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0672950() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0672951() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0672952() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0672953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0672954() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0672955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0672956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(877, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0672957() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0672958() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0672959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(float f) throws IOException {
    if (_cfgNumbersAsStrings || // [JACKSON-139]
    (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {
        writeString(String.valueOf(f));
        return;
    }
    // What is the max length for floats?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(f));
}","public void test0672960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0672972() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0672973() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0672976() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0672977() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0672978() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0672979() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0672980() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0672981() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0672982() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertEquals(877, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0672983() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0672984() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0672985() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 877, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeNumber((float) 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0683004() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0683005() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0683007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0683021() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0683022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0683023() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0683024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0683025() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0683026() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0683027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0683028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0683029() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0683030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0683031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0683032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0683033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test0683037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 0, false);
    BigDecimal bigDecimal0 = BigDecimal.ZERO;
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeNumber(bigDecimal0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0693059() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0693074() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0693075() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0693076() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0693077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0693078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0693079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0693080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0693081() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0693082() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0693083() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0693084() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0693085() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test0693086() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""{^`>tHpj*ic"");
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 0, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeNumber((BigDecimal) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0703108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0703122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0703123() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0703124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0703125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertEquals(43, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0703126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0703127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0703128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0703129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0703130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0703131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0703132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0703133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0703134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test0703138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 43, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 2, false);
    BigDecimal bigDecimal0 = BigDecimal.ZERO;
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeNumber(bigDecimal0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test0713198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0713210() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0713211() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0713212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0713213() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0713214() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0713215() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0713216() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0713217() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals((-15), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0713218() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0713219() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0713220() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0713221() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0713222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-15), (ObjectCodec) null, byteArrayBuilder0);
    BigDecimal bigDecimal0 = new BigDecimal(3);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0723243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0723253() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0723254() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0723271() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0723272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0723273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0723274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0723275() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0723276() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0723277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0723278() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0723279() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0723280() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0723281() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0723282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0723283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(78, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test0723284() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0723296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0723297() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0723298() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0723301() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0723302() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0723303() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0723304() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0723305() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0723306() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0723307() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0723308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0723309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0723310() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    BigDecimal bigDecimal0 = new BigDecimal(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 78, (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(78, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(String encodedValue) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(encodedValue);
    } else {
        writeRaw(encodedValue);
    }
}","public void test0733363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertArrayEquals(new byte[] { (byte) 124, (byte) 124, (byte) 86, (byte) 34 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0733377() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0733378() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0733381() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0733382() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0733383() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0733384() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0733385() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertEquals(4, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0733386() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0733387() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0733388() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertEquals(41, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0733389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0733390() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 41, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    uTF8JsonGenerator0.writeNumber(""DCZg4I}d-?+}||V"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0743413() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0743428() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0743429() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0743446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0743447() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0743448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0743449() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0743450() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0743451() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0743452() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0743453() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0743454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0743455() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public void writeBoolean(boolean state) throws IOException {
    _verifyValueWrite(WRITE_BOOLEAN);
    if ((_outputTail + 5) >= _outputEnd) {
        _flushBuffer();
    }
    byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;
    int len = keyword.length;
    System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);
    _outputTail += len;
}","public void test0743456() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile(""Can not currently override name during filtering read"", ""Can not currently override name during filtering read"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, mockPrintStream0, byteArray0, 3, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeBoolean(true);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0753478() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0753479() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0753497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0753498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0753499() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0753500() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0753501() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0753502() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0753503() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0753504() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0753505() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0753506() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertEquals(1624, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0753507() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0753508() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public final void writeStartObject() throws IOException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_LCURLY;
    }
}","public void test0753509() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 123, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0753525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0753526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0753527() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(6, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0753528() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0753529() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0753530() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0753531() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0753532() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0753533() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0753534() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(1624, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0753535() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0753536() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public final void writeStartObject() throws IOException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_LCURLY;
    }
}","public void test0753537() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeStartObject();
    try {
        uTF8JsonGenerator0.writeStartObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not start an object, expecting field name
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"public byte[] allocReadIOBuffer() {
    _verifyAlloc(_readIOBuffer);
    return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER));
}","public void test0763561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    assertEquals(8000, byteArray0.length);
}","/**
 * <p>
 *  Note: the method can only be called once during its life cycle.
 *  This is to protect against accidental sharing.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0763571() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0763572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0763586() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0763587() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0763590() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0763591() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0763592() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(1114111, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0763593() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0763594() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0763595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0763596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0763597() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0763598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0763599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public final void writeObjectFieldStart(String fieldName) throws IOException {
    writeFieldName(fieldName);
    writeStartObject();
}","public void test0763600() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  (that will contain a JSON Object value), and the START_OBJECT marker.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeStartObject();
 * </pre>
 * <p>
 *  Note: caller still has to take care to close the Object
 *  (by calling {#link #writeEndObject}) after writing all
 *  entries of the value Object.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0763612() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0763613() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0763616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0763617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertEquals(1114111, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0763618() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0763619() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0763620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0763621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0763622() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertEquals(8, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0763623() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0763624() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0763625() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public final void writeBinaryField(String fieldName, byte[] data) throws IOException {
    writeFieldName(fieldName);
    writeBinary(data);
}","public void test0763626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertEquals(8000, byteArray0.length);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that contains specified data in base64-encoded form.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeBinary(value);
 * </pre>
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0763639() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0763640() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0763642() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0763643() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertEquals(1114111, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0763644() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0763645() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0763646() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0763647() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0763648() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0763649() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0763650() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertEquals(2701, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0763651() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = iOContext0.allocReadIOBuffer();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1114111, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeObjectFieldStart(""TdV23"");
    uTF8JsonGenerator0.writeBinaryField(""\""@k9u4Dki2z.EZ3&"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0773688() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0773689() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0773692() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0773693() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0773694() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0773695() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0773696() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0773697() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0773698() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0773699() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0773700() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0773701() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""lehtU'S("", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public final void writeArrayFieldStart(String fieldName) throws IOException {
    writeFieldName(fieldName);
    writeStartArray();
}","public void test0793806() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  (that will contain a JSON Array value), and the START_ARRAY marker.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeStartArray();
 * </pre>
 * <p>
 *  Note: caller still has to take care to close the array
 *  (by calling {#link #writeEndArray}) after writing all values
 *  of the value Array.
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0793818() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0793819() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0793822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0793823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0793824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0793825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0793826() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0793827() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0793828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0793829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0793830() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0793831() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeArrayFieldStart(""NZM`WCVO05cB}iX"");
    assertEquals(16, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0803871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0803872() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0803875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0803876() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0803877() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0803878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0803879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0803880() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0803881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0803882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0803883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0803884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public final void writeStartObject() throws IOException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_LCURLY;
    }
}","public void test0803885() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertArrayEquals(new byte[] { (byte) 123, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0803899() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0803900() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0803903() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0803904() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0803905() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0803906() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0803907() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0803908() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0803909() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0803910() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0803911() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0803912() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 0, false);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0813947() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0813948() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0813949() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0813950() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertEquals(4, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0813951() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0813952() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0813953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0813954() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0813955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0813956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0813957() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0813958() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_outputStream != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _outputStream.flush();
        }
    }
}","public void test0813959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0813971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0813972() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0813973() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0813974() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertEquals(4, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0813975() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0813976() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0813977() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0813978() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0813979() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0813980() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0813981() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0813982() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 4, (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0824019() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0824020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0824023() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0824024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0824025() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0824026() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(574, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0824027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0824028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0824029() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0824030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0824031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0824032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_outputStream != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _outputStream.flush();
        }
    }
}","public void test0824033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0824045() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0824046() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0824049() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0824050() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0824051() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0824052() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(574, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0824053() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0824054() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0824055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0824056() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0824057() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0824058() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 574, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0834095() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0834096() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0834099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0834100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0834101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0834102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0834103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0834104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0834105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0834106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(248, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0834107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0834108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_outputStream != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _outputStream.flush();
        }
    }
}","public void test0834109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0834121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0834122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0834125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0834126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0834127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0834128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0834129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0834130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0834131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0834132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(248, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0834133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0834134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.flush();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0844185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0844197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0844198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0844201() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0844202() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0844203() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0844204() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0844205() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0844206() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0844207() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0844208() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(255, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0844209() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0844210() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0844211() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0844223() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0844224() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0844227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0844228() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0844229() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0844230() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0844231() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0844232() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0844233() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0844234() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertEquals(255, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0844235() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0844236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""7.e`"", true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(240);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 255, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0854273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0854274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0854277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0854278() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0854279() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0854280() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0854281() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0854282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0854283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0854284() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0854285() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(28, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0854286() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0854287() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0854299() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0854300() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0854303() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0854304() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0854305() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0854306() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0854307() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0854308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0854309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0854310() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0854311() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(28, uTF8JsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0854312() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 28, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public final void writeStartObject() throws IOException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_LCURLY;
    }
}","public void test0864363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0864375() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0864376() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0864379() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0864380() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0864381() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0864382() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0864383() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0864384() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0864385() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0864386() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0864387() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0864388() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0864389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0864401() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0864402() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0864405() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0864406() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0864407() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0864408() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0864409() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0864410() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0864411() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0864412() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0864413() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0864414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeStartObject();
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0874448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0874449() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0874450() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0874451() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0874452() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0874453() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0874454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0874455() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0874456() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0874457() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertEquals((-4479), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0874458() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0874459() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0874460() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0874472() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0874473() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0874474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0874475() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0874476() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0874477() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0874478() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0874479() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0874480() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0874481() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0874482() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertEquals((-4479), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0874483() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-4479), (ObjectCodec) null, (OutputStream) null);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0884520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0884521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0884524() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0884525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0884526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0884527() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0884528() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0884529() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(175, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0884530() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0884531() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0884532() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0884533() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0884534() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0884546() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0884547() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0884550() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0884551() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0884552() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0884553() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0884554() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0884555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(175, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0884556() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0884557() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0884558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0884559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 175, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.close();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    // just to ensure we don't think there's anything buffered
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_outputStream != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _outputStream.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _outputStream.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test0894612() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0894626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0894627() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0894630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0894631() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0894632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0894633() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0894634() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0894635() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0894636() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0894637() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0894638() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0894639() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[1];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 0, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.close();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0904662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0904677() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0904678() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0904695() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0904696() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0904697() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0904698() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0904699() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0904700() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0904701() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(72, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0904702() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0904703() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0904704() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    _writeBytes(text, offset, length);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0904705() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Can not currently override name during filtering read"", false);
    MockFile mockFile0 = new MockFile("" in character escape sequence"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    byte[] byteArray0 = new byte[3];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 72, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeRawUTF8String(byteArray0, 436, 436);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0914735() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0914749() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0914750() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test0914751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0914752() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertEquals(3, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0914753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0914754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0914755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0914756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0914757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0914758() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertEquals(155, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0914759() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0914760() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0914761() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    // First: if we can't guarantee it all fits, quoted, within output, offline
    final int len = text.length();
    if (len > _outputMaxContiguous) {
        // nope: off-line handling
        _writeStringSegments(text, true);
        return;
    }
    if ((_outputTail + len) >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // we checked space already above
    _writeStringSegment(text, 0, len);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0914762() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 155, false);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString(""5C="");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0924782() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0924783() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertNull(iOContext0.getEncoding());
}",""
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test0924784() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0924799() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0924800() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0924801() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0924802() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0924803() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0924804() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals((-76), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0924805() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0924806() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0924807() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0924808() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0924809() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0924810() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test0924811() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 50, (byte) 34, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0924825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0924826() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0924827() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0924828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0924829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0924830() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals((-76), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0924831() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0924832() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0924833() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0924834() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0924835() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0924836() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    if (_cfgPrettyPrinter != null) {
        _writePPFieldName(name);
        return;
    }
    final int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {
        // need comma
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_COMMA;
    }
    /* To support [JACKSON-46], we'll do this:
         * (Question: should quoting of spaces (etc) still be enabled?)
         */
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    // Does it fit in buffer?
    if (len > _charBufferLength) {
        // no, offline
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(name, 0, len);
    } else {
        _writeStringSegments(name, 0, len);
    }
    // and closing quotes; need room for one more char:
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0924837() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertArrayEquals(new byte[] { (byte) 34, (byte) 50, (byte) 34, (byte) 44, (byte) 87, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0924851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0924852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0924853() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0924854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0924855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertEquals((-76), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0924856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0924857() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0924858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0924859() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0924860() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0924861() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0924862() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test0924863() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 50, (byte) 34, (byte) 44, (byte) 87, (byte) 32, (byte) 34, (byte) 48, (byte) 46, (byte) 48 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0924877() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0924878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0924879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0924880() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0924881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0924882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertEquals((-76), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0924883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0924884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0924885() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0924886() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0924887() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0924888() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-76), (ObjectCodec) null, mockPrintStream0, byteArray0, 1, false);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeFieldName(""W"");
    uTF8JsonGenerator0.writeNumber((double) 0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public final void writeBinaryField(String fieldName, byte[] data) throws IOException {
    writeFieldName(fieldName);
    writeBinary(data);
}","public void test0934941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertArrayEquals(new byte[] { (byte) 99, (byte) 51, (byte) 81, (byte) 61, (byte) 34, (byte) 34, (byte) 115, (byte) 116 }, byteArray0);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that contains specified data in base64-encoded form.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeBinary(value);
 * </pre>
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0934957() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0934958() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0934959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertEquals(5, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0934960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0934961() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0934962() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0934963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0934964() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0934965() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0934966() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertEquals(1624, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0934967() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0934968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!V?3I76gB*]4a+"", false);
    byte[] byteArray0 = new byte[8];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1624, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, (byte) 5, false);
    uTF8JsonGenerator0.writeBinaryField(""write a string"", byteArray0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(text, offset, len);
    } else {
        _writeStringSegments(text, offset, len);
    }
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0945019() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(235);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0);
    char[] charArray0 = new char[5];
    charArray0[3] = '\u0097';
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString(charArray0, 3, 4);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"@Override
public JsonGenerator useDefaultPrettyPrinter() {
    // Should not override a pretty printer if one already assigned.
    if (getPrettyPrinter() != null) {
        return this;
    }
    return setPrettyPrinter(_constructDefaultPrettyPrinter());
}","public void test0955070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertNotNull(uTF8JsonGenerator1);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0955089() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0955090() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0955093() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(248, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0955094() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0955095() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0955096() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0955097() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0955098() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0955099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0955100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0955101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0955102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0955103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertTrue(uTF8JsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0955104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0955105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(127, uTF8JsonGenerator1.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0955106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator1.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0955107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator1.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0955108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(248, uTF8JsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0955109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0955110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertFalse(uTF8JsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0955111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(0, uTF8JsonGenerator1.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0955112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    assertEquals(0, uTF8JsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    if (_cfgPrettyPrinter != null) {
        _writePPFieldName(name);
        return;
    }
    final int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {
        // need comma
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = BYTE_COMMA;
    }
    /* To support [JACKSON-46], we'll do this:
         * (Question: should quoting of spaces (etc) still be enabled?)
         */
    if (_cfgUnqNames) {
        _writeStringSegments(name, false);
        return;
    }
    final int len = name.length();
    // Does it fit in buffer?
    if (len > _charBufferLength) {
        // no, offline
        _writeStringSegments(name, true);
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // But as one segment, or multiple?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(name, 0, len);
    } else {
        _writeStringSegments(name, 0, len);
    }
    // and closing quotes; need room for one more char:
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0955113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertSame(uTF8JsonGenerator0, uTF8JsonGenerator1);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0955126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0955127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0955130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertEquals(248, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0955131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0955132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0955133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0955134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0955135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0955136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0955137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertEquals(17, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0955138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0955139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 248, (ObjectCodec) null, byteArrayOutputStream0);
    UTF8JsonGenerator uTF8JsonGenerator1 = (UTF8JsonGenerator) uTF8JsonGenerator0.useDefaultPrettyPrinter();
    uTF8JsonGenerator0.writeFieldName(""pAc!_U]ga(C7v"");
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0965160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0965161() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0965178() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0965179() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0965182() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0965183() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0965184() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0965185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0965186() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0965187() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0965188() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0965189() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0965190() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0965191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(3478, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        if ((_outputTail + len) > _outputEnd) {
            // caller must ensure enough space
            _flushBuffer();
        }
        _writeStringSegment(text, offset, len);
    } else {
        _writeStringSegments(text, offset, len);
    }
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0965192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Enumeration<FilterInputStream> enumeration0 = (Enumeration<FilterInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferedInputStream0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3478, (ObjectCodec) null, byteArrayOutputStream0);
    char[] charArray0 = new char[8];
    charArray0[5] = '\\';
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeString(charArray0, 1, 55296);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 8
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0975229() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0975230() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0975233() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0975234() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0975235() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0975236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0975237() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0975238() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0975239() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0975240() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0975241() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0975242() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0975243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertArrayEquals(new byte[] { (byte) (-4), (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0975257() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0975258() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0975261() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(15, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0975262() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0975263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test0975264() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0975265() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(1, uTF8JsonGenerator0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0975266() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0975267() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0975268() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0975269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0975270() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-4);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test0985319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertArrayEquals(new byte[] { (byte) 50, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0985333() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0985334() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0985335() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0985336() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0985337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0985338() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0985339() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0985340() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(333, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0985341() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0985342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test0985343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0985344() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0985345() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertArrayEquals(new byte[] { (byte) 50, (byte) 32, (byte) 34, (byte) 50, (byte) 32, (byte) 34, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0985359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0985360() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0985361() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0985362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0985363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test0985364() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0985365() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0985366() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(333, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test0985367() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0985368() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(6, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0985369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0985370() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Z"");
    byte[] byteArray0 = new byte[10];
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 333, (ObjectCodec) null, mockPrintStream0, byteArray0, 1, true);
    uTF8JsonGenerator0.writeNumber(2);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 2);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0995389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0995390() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test0995408() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test0995409() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test0995410() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test0995411() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test0995412() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test0995413() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test0995414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test0995415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0995416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test0995417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test0995418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test0995419() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test0995420() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFW-E/GNu3&kS#O"", true);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""oFW-E/GNu3&kS#O"");
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    byte[] byteArray0 = new byte[9];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, dataOutputStream0, byteArray0, 1, true);
    // Undeclared exception!
    try {
        uTF8JsonGenerator0.writeUTF8String(byteArray0, 3, (byte) 48);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8JsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1005457() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1005458() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1005461() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1005462() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(2819, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1005463() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1005464() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1005465() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1005466() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1005467() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1005468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1005469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1005470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeUTF8String(byte[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
    // One or multiple segments?
    if (len <= _outputMaxContiguous) {
        _writeUTF8Segment(text, offset, len);
    } else {
        _writeUTF8Segments(text, offset, len);
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = BYTE_QUOTE;
}","public void test1005471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertArrayEquals(new byte[] { (byte) 67, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1005485() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1005486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1005489() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1005490() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(2819, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1005491() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1005492() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(15, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1005493() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1005494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1005495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1005496() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1005497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1005498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 67;
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2819, (ObjectCodec) null, byteArrayOutputStream0);
    uTF8JsonGenerator0.writeUTF8String(byteArray0, 0, 3);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1015520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1015534() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1015535() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1015536() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1015537() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1015538() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1015539() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1015540() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1015541() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test1015542() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1015543() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1015544() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1015545() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals((-814), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1015546() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public void writeBinary(byte[] data, int offset, int len) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);
}","public void test1015547() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1015559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1015560() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1015561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1015562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1015563() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1015564() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1015565() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1015566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test1015567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1015568() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1015569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1015570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals((-814), uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1015571() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    uTF8JsonGenerator0.writeBinary(byteArrayBuilder0.NO_BYTES, 2997, 0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1025610() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1025611() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1025614() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1025615() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1025616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1025617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test1025618() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1025619() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1025620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1025621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1025622() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1025623() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test1025632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    long long0 = byteArrayInputStream0.skip(724L);
    try {
        uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 56319);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Too few bytes available: missing 56319 bytes (out of 56319)
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test1035689() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertArrayEquals(new byte[] { (byte) 34, (byte) 65, (byte) 61, (byte) 61 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1035704() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1035705() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1035708() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1035709() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1035710() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1035711() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1035712() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1035713() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1035714() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1035715() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1035716() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertEquals(2, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1035717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[4];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 2, true);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 1);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1045758() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1045759() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1045762() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1045763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1045764() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1045765() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1045766() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1045767() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1045768() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1045769() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1045770() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertEquals(16, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1045771() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test1045772() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertEquals(11, byteArray0.length);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1045786() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1045787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1045791() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1045792() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1045793() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1045794() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1045795() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1045796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1045797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1045798() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertEquals(16, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1045799() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1045800() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    byte[] byteArray0 = new byte[11];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (byte) 16, (ObjectCodec) null, byteArrayOutputStream0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-402));
    assertEquals(18, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1055829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1055830() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1055849() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1055850() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1055851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1055852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1055853() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1055854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1055855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals((-128), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1055856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1055857() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(3, uTF8JsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1055858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1055859() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1055860() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test1055861() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertArrayEquals(new byte[] { (byte) 34, (byte) 103, (byte) 61, (byte) 61 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1055879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1055880() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1055881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1055882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1055883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1055884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1055885() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertEquals(1, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1055886() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertEquals((-128), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1055887() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1055888() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1055889() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1055890() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1);
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, byteArrayInputStream0, false);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-128), (ObjectCodec) null, byteArrayOutputStream0, byteArray0, 3, false);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1306));
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1065914() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1065929() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1065930() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1065931() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1065932() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1065933() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1065934() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1065935() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals((-814), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1065936() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1065937() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1065938() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1065939() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1065940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1065941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test1065942() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1065955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1065956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertNull(iOContext0.getEncoding());
}",""
"public int getCurrentSegmentLength() {
    return _currBlockPtr;
}","public void test1065957() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals(0, byteArrayBuilder0.getCurrentSegmentLength());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1065959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals(127, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1065960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1065961() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1065962() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals((-814), uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1065963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1065964() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1065965() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1065966() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1065967() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test1065968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""oFWE/GNu3&kS#O"", false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArrayBuilder0.NO_BYTES);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-814), (ObjectCodec) null, byteArrayBuilder0);
    int int0 = uTF8JsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1385));
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) {
    super(ctxt, features, codec);
    _outputStream = out;
    _bufferRecyclable = bufferRecyclable;
    _outputTail = outputOffset;
    _outputBuffer = outputBuffer;
    _outputEnd = _outputBuffer.length;
    // up to 6 bytes per char (see above), rounded up to 1/8
    _outputMaxContiguous = (_outputEnd >> 3);
    _charBuffer = ctxt.allocConcatBuffer();
    _charBufferLength = _charBuffer.length;
}","public void test1075990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1076005() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1076006() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1076007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1076008() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1076009() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1076010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1076011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertEquals(3, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1076012() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1076013() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1076014() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertEquals(102, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1076015() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1076016() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test1076018() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    assertEquals(""RS"", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test1076019() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    assertEquals(""RS"", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test1076020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    assertEquals(2, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1076035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1076036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1076037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1076038() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(2, uTF8JsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1076039() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1076040() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1076041() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1076042() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(3, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1076043() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1076044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1076045() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1076046() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test1076047() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(""RS"", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test1076048() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(""RS"", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test1076049() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(2, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"protected final void _outputSurrogates(int surr1, int surr2) throws IOException {
    int c = _decodeSurrogate(surr1, surr2);
    if ((_outputTail + 4) > _outputEnd) {
        _flushBuffer();
    }
    final byte[] bbuf = _outputBuffer;
    bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));
    bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));
    bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));
    bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));
}","public void test1076050() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertArrayEquals(new byte[] { (byte) 82, (byte) 83, (byte) (-8), (byte) (-112), (byte) (-97), (byte) (-65) }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1076064() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1076065() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1076066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test1076067() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test1076068() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1076069() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1076070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(3, uTF8JsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1076071() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1076072() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1076073() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(6, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1076074() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1076075() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    SerializedString serializedString0 = new SerializedString(""RS"");
    uTF8JsonGenerator0.writeFieldName((SerializableString) serializedString0);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"protected final void _outputSurrogates(int surr1, int surr2) throws IOException {
    int c = _decodeSurrogate(surr1, surr2);
    if ((_outputTail + 4) > _outputEnd) {
        _flushBuffer();
    }
    final byte[] bbuf = _outputBuffer;
    bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));
    bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));
    bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));
    bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));
}","public void test1086124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertArrayEquals(new byte[] { (byte) (-8), (byte) (-112), (byte) (-97), (byte) (-65), (byte) 0, (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test1086138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test1086139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test1086140() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Forward-compatibility additions in 2.7.5: placeholders
    /* for additions that will be in 2.8.0
    /**********************************************************
     */
// @since 2.7.5 (as placeholder, NOT full impl)
public boolean canWriteFormattedNumbers() {
    return false;
}","public void test1086141() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteFormattedNumbers());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test1086142() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(0, uTF8JsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test1086143() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(3, uTF8JsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test1086144() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test1086145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test1086146() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertFalse(uTF8JsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test1086147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertTrue(uTF8JsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail is always valid, set to 0 on close
    return _outputTail;
}","public void test1086148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(4, uTF8JsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test1086149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""RS"");
    byte[] byteArray0 = new byte[6];
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 3, (ObjectCodec) null, mockPrintStream0, byteArray0, 102, false);
    uTF8JsonGenerator0._outputSurrogates(1, 57343);
    assertEquals(0, uTF8JsonGenerator0.getHighestEscapedChar());
}",""
