focal_method,test_prefix,docstring
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    int int0 = writerBasedJsonGenerator0.getOutputBuffered();
    assertEquals(0, int0);
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(3954, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeUTF8String(byte[] text, int offset, int length) throws IOException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1107, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeUTF8String(byteArray0, 55296, 1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Operation not supported by generator of type com.fasterxml.jackson.core.json.WriterBasedJsonGenerator
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeRawUTF8String(byteArray0, 1, 2514);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Operation not supported by generator of type com.fasterxml.jackson.core.json.WriterBasedJsonGenerator
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFu|s#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeFieldName(""Can not write a field name, expecting a value"");
    try {
        writerBasedJsonGenerator0.writeFieldName(""nFu|s#Qt^1:"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not write a field name, expecting a value
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    writerBasedJsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2322, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0);
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator0._rootValueSeparator;
    writerBasedJsonGenerator0.writeFieldName((SerializableString) serializedString0);
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getOutputBuffered() {
    return -1;
}","public void test099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    JsonGenerator jsonGenerator0 = writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    jsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(10, jsonGenerator0.getOutputBuffered());
}","/**
 *  Method for verifying amount of content that is buffered by generator
 *  but not yet flushed to the underlying target (stream, writer),
 *  in units (byte, char) that the generator implementation uses for buffering;
 *  or -1 if this information is not available.
 *  Unit used is often the same as the unit of underlying target (that is,
 *  `byte` for {@link java.io.OutputStream}, `char` for {@link java.io.Writer}),
 *  but may differ if buffering is done before encoding.
 *  Default JSON-backed implementations do use matching units.
 * <p>
 *  Note: non-JSON implementations will be retrofitted for 2.6 and beyond;
 *  please report if you see -1 (missing override)
 *
 *  @return Amount of content buffered in internal units, if amount known and
 *     accessible; -1 if not accessible.
 *
 *  @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeFieldName(""Can not write a field name, expecting a value"");
    assertEquals(47, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator0._writeFieldName(defaultPrettyPrinter0.DEFAULT_ROOT_VALUE_SEPARATOR, false);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 8, (ObjectCodec) null, stringWriter0);
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator0._rootValueSeparator;
    writerBasedJsonGenerator0._writeFieldName(serializedString0, false);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getOutputBuffered() {
    return -1;
}","public void test1313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    JsonGenerator jsonGenerator0 = writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    jsonGenerator0.writeStartArray();
    assertEquals(1, jsonGenerator0.getOutputBuffered());
}","/**
 *  Method for verifying amount of content that is buffered by generator
 *  but not yet flushed to the underlying target (stream, writer),
 *  in units (byte, char) that the generator implementation uses for buffering;
 *  or -1 if this information is not available.
 *  Unit used is often the same as the unit of underlying target (that is,
 *  `byte` for {@link java.io.OutputStream}, `char` for {@link java.io.Writer}),
 *  but may differ if buffering is done before encoding.
 *  Default JSON-backed implementations do use matching units.
 * <p>
 *  Note: non-JSON implementations will be retrofitted for 2.6 and beyond;
 *  please report if you see -1 (missing override)
 *
 *  @return Amount of content buffered in internal units, if amount known and
 *     accessible; -1 if not accessible.
 *
 *  @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeEndArray() throws IOException, JsonGenerationException {
    if (!_writeContext.inArray()) {
        _reportError(""Current context not an ARRAY but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = ']';
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test1515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    try {
        writerBasedJsonGenerator0.writeEndArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current context not an ARRAY but ROOT
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test1818() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber((long) 0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeEndObject() throws IOException, JsonGenerationException {
    if (!_writeContext.inObject()) {
        _reportError(""Current context not an object but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '}';
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test1919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    try {
        writerBasedJsonGenerator0.writeEndObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current context not an object but ROOT
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.useDefaultPrettyPrinter();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test2121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    char[] charArray0 = iOContext0.allocNameCopyBuffer(32768);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeString(charArray0, 94, 253);
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(57343, GeneratorBase.SURR2_LAST);
}",""
"protected void _writePPFieldName(String name, boolean commaBefore) throws IOException {
    if (commaBefore) {
        _cfgPrettyPrinter.writeObjectEntrySeparator(this);
    } else {
        _cfgPrettyPrinter.beforeObjectEntries(this);
    }
    if (_cfgUnqNames) {
        // non-standard, omit quotes
        _writeString(name);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '""';
        _writeString(name);
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '""';
    }
}","public void test2222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0._writePPFieldName(""nFs#Qt^1:"", true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}","/**
 * Specialized version of <code>_writeFieldName</code>, off-lined
 * to keep the ""fast path"" as simple (and hopefully fast) as possible.
 */"
"public int getOutputBuffered() {
    return -1;
}","public void test2323() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    JsonGenerator jsonGenerator0 = writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    jsonGenerator0.writeFieldName(""u:UZA>&O:8"");
    assertEquals(13, jsonGenerator0.getOutputBuffered());
}","/**
 *  Method for verifying amount of content that is buffered by generator
 *  but not yet flushed to the underlying target (stream, writer),
 *  in units (byte, char) that the generator implementation uses for buffering;
 *  or -1 if this information is not available.
 *  Unit used is often the same as the unit of underlying target (that is,
 *  `byte` for {@link java.io.OutputStream}, `char` for {@link java.io.Writer}),
 *  but may differ if buffering is done before encoding.
 *  Default JSON-backed implementations do use matching units.
 * <p>
 *  Note: non-JSON implementations will be retrofitted for 2.6 and beyond;
 *  please report if you see -1 (missing override)
 *
 *  @return Amount of content buffered in internal units, if amount known and
 *     accessible; -1 if not accessible.
 *
 *  @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2424() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.useDefaultPrettyPrinter();
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator1._rootValueSeparator;
    writerBasedJsonGenerator0._writeFieldName(serializedString0, true);
    assertEquals(3, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2425() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.useDefaultPrettyPrinter();
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator1._rootValueSeparator;
    writerBasedJsonGenerator0._writeFieldName(serializedString0, true);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 97, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString((String) null);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2627() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    writerBasedJsonGenerator0.writeFieldName(""Can not write a field name, expecting a value"");
    writerBasedJsonGenerator0.writeNumber((short) 115);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    writerBasedJsonGenerator0.writeString(""1"");
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2728() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    SerializedString serializedString0 = new SerializedString(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"");
    writerBasedJsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test2930() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator0._rootValueSeparator;
    writerBasedJsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber((long) 0);
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator0._rootValueSeparator;
    writerBasedJsonGenerator0._writeFieldName(serializedString0, true);
    writerBasedJsonGenerator0.writeString((SerializableString) serializedString0);
    assertEquals(2, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3132() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    SerializedString serializedString0 = new SerializedString(""JF@&7"");
    writerBasedJsonGenerator0.writeString((SerializableString) serializedString0);
    writerBasedJsonGenerator0.writeNumber(""V"");
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeRaw(String text, int start, int len) throws IOException {
    // Nothing to check, can just output as is
    int room = _outputEnd - _outputTail;
    if (room < len) {
        _flushBuffer();
        room = _outputEnd - _outputTail;
    }
    // But would it nicely fit in? If yes, it's easy
    if (room >= len) {
        text.getChars(start, start + len, _outputBuffer, _outputTail);
        _outputTail += len;
    } else {
        writeRawLong(text.substring(start, start + len));
    }
}","public void test3233() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeRaw("""", 1, 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"@Override
public void writeRaw(String text, int start, int len) throws IOException {
    // Nothing to check, can just output as is
    int room = _outputEnd - _outputTail;
    if (room < len) {
        _flushBuffer();
        room = _outputEnd - _outputTail;
    }
    // But would it nicely fit in? If yes, it's easy
    if (room >= len) {
        text.getChars(start, start + len, _outputBuffer, _outputTail);
        _outputTail += len;
    } else {
        writeRawLong(text.substring(start, start + len));
    }
}","public void test3334() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeRaw((String) null, 497, 55296);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3536() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3987);
    byte[] byteArray0 = new byte[5];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 0);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    SerializedString serializedString0 = new SerializedString("", expecting field name"");
    writerBasedJsonGenerator0._writeFieldName(serializedString0, true);
    assertEquals(22, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3637() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    SerializedString serializedString0 = (SerializedString) writerBasedJsonGenerator0._rootValueSeparator;
    writerBasedJsonGenerator0._writeFieldName(serializedString0, true);
    writerBasedJsonGenerator0.writeRaw(',');
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3738() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber((-203.99656708310306));
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public void writeBinary(byte[] data, int offset, int len) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);
}","public void test3839() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber((long) 0);
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    byte[] byteArray0 = new byte[3];
    writerBasedJsonGenerator0.writeStartArray();
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeBinary(byteArray0, 57343, 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 57343
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test3940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    byte[] byteArray0 = new byte[3];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test4041() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = (-2193);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) mockFileInputStream0, 0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test4042() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = (-2193);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) mockFileInputStream0, 0);
    assertEquals(0, int0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test4143() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    try {
        writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 10);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Too few bytes available: missing 4 bytes (out of 10)
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test4244() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._checkStdFeatureChanges(364, 754);
    writerBasedJsonGenerator0.writeNumber((short) 3930);
    assertEquals(6, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test4345() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1{"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    writerBasedJsonGenerator0.writeFieldName(""com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer"");
    writerBasedJsonGenerator0.writeNumber((short) 933);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test4446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    writerBasedJsonGenerator0.writeFieldName(""com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer"");
    writerBasedJsonGenerator0._checkStdFeatureChanges(364, 754);
    writerBasedJsonGenerator0.writeNumber((short) 3930);
    assertEquals(6, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test4556() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test4557() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test4569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test4570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test4572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test4573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test4574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test4575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test4576() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test4577() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test4578() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test4579() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test4581() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test4595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test4596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test4598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test4599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test45100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test45101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test45102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test45103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test45104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test45105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test45107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test45108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(3);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test46129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test46130() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test46142() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test46143() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test46145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test46146() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test46147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test46148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test46149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertEquals(103, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test46150() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test46151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test46152() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test46154() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test46168() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test46169() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test46171() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test46172() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test46173() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test46174() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test46175() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(103, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test46176() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test46177() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test46178() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test46180() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test46181() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 103, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test47208() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test47209() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* Life-cycle
    /**********************************************************
     */
public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) {
    _bufferRecycler = br;
    _sourceRef = sourceRef;
    _managedResource = managedResource;
}","public void test47210() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test47221() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test47222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test47223() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test47224() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test47225() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test47226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test47228() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test47229() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test47230() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test47231() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test47232() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test47248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test47249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test47250() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test47251() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test47252() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test47253() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test47255() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test47256() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test47257() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test47258() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test47259() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test47262() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test47263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test47264() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test47265() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test47266() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test47267() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test47269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test47270() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test47271() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test47272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test47273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(int i) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedInt(i);
        return;
    }
    // up to 10 digits and possible minus sign
    if ((_outputTail + 11) >= _outputEnd) {
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);
}","public void test47274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeNumber(2);
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test48295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test48296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test48308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test48309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test48311() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test48312() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test48313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test48315() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test48316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test48317() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test48318() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test48319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test48320() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test48334() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test48335() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test48337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test48338() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test48339() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test48341() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test48342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test48343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test48344() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test48345() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test48346() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public void writeNumber(long l) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedLong(l);
        return;
    }
    if ((_outputTail + 21) >= _outputEnd) {
        // up to 20 digits, minus sign
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);
}","public void test48347() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((long) 1);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test49368() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test49369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test49381() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test49382() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test49384() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test49385() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test49386() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test49387() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test49388() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test49389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test49390() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertEquals((-940), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test49391() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test49392() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test49410() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test49411() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test49413() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test49414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test49415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test49416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test49417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test49418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test49419() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals((-940), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test49420() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test49421() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"// !!! 05-Aug-2008, tatus: Any ways to optimize these?
@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test49425() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.ONE;
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test50446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test50447() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test50459() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test50460() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test50462() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test50463() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test50464() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test50465() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test50466() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test50468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test50469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertEquals((-2164), writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test50470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test50471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test50485() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test50486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test50488() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test50489() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test50490() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test50491() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test50492() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test50494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertEquals((-2164), writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test50495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test50496() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test50497() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"// !!! 05-Aug-2008, tatus: Any ways to optimize these?
@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test50498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2164), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((BigInteger) null);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test51532() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test51533() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test51535() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test51536() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(110, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test51537() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test51538() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test51540() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test51541() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test51542() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test51543() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test51544() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test51563() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test51564() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test51566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test51567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test51568() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(110, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test51569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test51570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test51572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test51573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test51574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test51575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"// !!! 05-Aug-2008, tatus: Any ways to optimize these?
@Override
public void writeNumber(BigInteger value) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(value.toString());
    } else {
        writeRaw(value.toString());
    }
}","public void test51578() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    writerBasedJsonGenerator0.writeNumber(bigInteger0);
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test52614() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test52615() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test52617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test52618() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test52619() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test52620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertEquals(4000, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test52621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test52623() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test52624() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test52625() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test52626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test52640() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test52641() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test52643() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test52644() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test52645() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertEquals(4000, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test52646() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test52648() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test52649() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test52650() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test52651() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test52652() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || // [JACKSON-139]
    (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test52653() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(0);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4000, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((double) 3);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test53713() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test53714() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test53716() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test53717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertEquals((-940), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test53718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test53719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test53720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test53721() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test53722() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test53723() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test53724() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeNumber(double d) throws IOException {
    if (_cfgNumbersAsStrings || // [JACKSON-139]
    (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {
        writeString(String.valueOf(d));
        return;
    }
    // What is the max length for doubles? 40 chars?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(d));
}","public void test53726() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter((byte) 88);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-940), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(Double.NaN);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test54747() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test54748() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test54749() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test54753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test54754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test54755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test54756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test54757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test54767() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test54768() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test54769() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test54771() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test54772() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test54773() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test54774() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test54775() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test54777() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test54778() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals(1380, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test54779() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test54780() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test54781() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test54782() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Standard method overrides
    /**********************************************************
     */
@Override
public final String toString() {
    return _value;
}","public void test54796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals("" "", serializedString0.toString());
}",""
"/*
    /**********************************************************
    /* API
    /**********************************************************
     */
@Override
public final String getValue() {
    return _value;
}","public void test54797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals("" "", serializedString0.getValue());
}",""
"@Override
public final int charLength() {
    return _value.length();
}","public void test54798() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(1, serializedString0.charLength());
}","/**
 * Returns length of the String as characters
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test54800() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test54801() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test54802() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test54803() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test54804() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test54806() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(6, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test54807() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test54808() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(1380, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test54809() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test54810() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test54811() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeNumber(float f) throws IOException {
    if (_cfgNumbersAsStrings || // [JACKSON-139]
    (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {
        writeString(String.valueOf(f));
        return;
    }
    // What is the max length for floats?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(f));
}","public void test54812() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, serializedString0, false);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1380, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber((float) 33);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test55835() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test55836() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test55847() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test55848() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test55849() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test55850() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test55851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertEquals((-2081), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test55852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test55853() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test55854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test55856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test55857() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test55858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test55873() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test55874() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test55875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test55876() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertEquals((-2081), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test55877() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test55878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test55879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test55881() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test55882() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test55883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test55884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeNumber(float f) throws IOException {
    if (_cfgNumbersAsStrings || // [JACKSON-139]
    (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {
        writeString(String.valueOf(f));
        return;
    }
    // What is the max length for floats?
    _verifyValueWrite(WRITE_NUMBER);
    writeRaw(String.valueOf(f));
}","public void test55885() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2081), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(0.0F);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test56922() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test56923() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test56925() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test56926() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test56927() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test56928() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test56929() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertEquals(2386, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test56930() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test56931() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test56932() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test56933() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test56948() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test56949() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test56953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test56954() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test56955() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test56956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test56957() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test56958() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2386, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test56959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test56960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test56961() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test56963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2386, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test57997() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test57998() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test571000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test571001() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test571002() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test571003() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test571005() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test571006() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test571007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test571008() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test571009() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    assertEquals(52, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test571023() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test571024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test571026() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test571027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test571028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test571030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test571031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test571032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test571033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test571034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test571035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertEquals(52, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {
    writeFieldName(fieldName);
    writeNumber(value);
}","public void test571036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 52, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumberField("""", (BigDecimal) null);
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that has the specified numeric value.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeNumber(value);
 * </pre>
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test581073() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test581074() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test581076() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test581077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test581078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test581079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test581081() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test581082() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test581083() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test581084() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test581085() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test581099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test581100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test581104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test581105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test581106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test581107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test581108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test581110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test581111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test581112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test581113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test581114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test591151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test591152() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test591154() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test591155() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test591156() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test591157() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test591158() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test591159() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test591160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test591162() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertEquals(44, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test591163() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test591177() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test591178() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test591182() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test591183() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test591184() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test591185() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test591186() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test591187() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test591188() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test591190() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(44, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test591191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeNumber(BigDecimal value) throws IOException {
    // Don't really know max length for big decimal, no point checking
    _verifyValueWrite(WRITE_NUMBER);
    if (value == null) {
        _writeNull();
    } else if (_cfgNumbersAsStrings) {
        String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
        _writeQuotedRaw(raw);
    } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
        writeRaw(value.toPlainString());
    } else {
        writeRaw(_asString(value));
    }
}","public void test591192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 44, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(bigDecimal0);
    assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test601226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test601227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test601229() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test601230() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test601231() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test601232() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test601233() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test601234() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test601235() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test601236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test601238() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test601260() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test601261() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test601263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test601264() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test601265() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertEquals(11, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test601266() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test601267() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test601268() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test601269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test601270() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test601272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {
    writeFieldName(fieldName);
    writeNumber(value);
}","public void test601277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigDecimal bigDecimal0 = new BigDecimal(bigInteger0);
    writerBasedJsonGenerator0.writeNumberField(""nFs#Qt^1:"", bigDecimal0);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}","/**
 *  Convenience method for outputting a field entry (""member"")
 *  that has the specified numeric value.
 *  Equivalent to:
 * <pre>
 *   writeFieldName(fieldName);
 *   writeNumber(value);
 * </pre>
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test611311() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test611312() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test611314() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test611315() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test611316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test611317() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test611318() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test611319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test611320() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test611321() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test611323() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    assertEquals(110, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test611337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test611338() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test611340() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test611341() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test611342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test611343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test611344() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test611345() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test611346() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test611347() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertEquals(14, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test611349() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertEquals(110, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public void writeNumber(String encodedValue) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedRaw(encodedValue);
    } else {
        writeRaw(encodedValue);
    }
}","public void test611350() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 110, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeNumber(""write a null"");
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test621431() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test621432() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test621433() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test621434() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test621435() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test621436() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test621437() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test621438() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test621439() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test621440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test621442() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeBoolean(boolean state) throws IOException {
    _verifyValueWrite(WRITE_BOOLEAN);
    if ((_outputTail + 5) >= _outputEnd) {
        _flushBuffer();
    }
    int ptr = _outputTail;
    char[] buf = _outputBuffer;
    if (state) {
        buf[ptr] = 't';
        buf[++ptr] = 'r';
        buf[++ptr] = 'u';
        buf[++ptr] = 'e';
    } else {
        buf[ptr] = 'f';
        buf[++ptr] = 'a';
        buf[++ptr] = 'l';
        buf[++ptr] = 's';
        buf[++ptr] = 'e';
    }
    _outputTail = ptr + 1;
}","public void test621443() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeBoolean(false);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test631510() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test631511() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test631512() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test631513() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test631514() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test631515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test631516() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test631517() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test631518() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test631520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test631521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeStartObject() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '{';
    }
}","public void test631522() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"/*
    /**********************************************************
    /* Output method implementations, structural
    /**********************************************************
     */
@Override
public void writeStartArray() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an array"");
    _writeContext = _writeContext.createChildArrayContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartArray(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '[';
    }
}","public void test631534() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    try {
        writerBasedJsonGenerator0.writeStartArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not start an array, expecting field name
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test641555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test641556() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertNull(iOContext0.getEncoding());
}",""
"public char[] allocTokenBuffer(int minSize) {
    _verifyAlloc(_tokenCBuffer);
    return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, minSize));
}","public void test641557() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}","/**
 * @since 2.4
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test641569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test641570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test641572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test641573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test641574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test641575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test641576() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test641577() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test641578() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test641579() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test641580() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test641595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test641596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test641597() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test641598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(3943, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test641599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test641600() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test641601() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test641602() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test641603() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test641604() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test641605() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test641607() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test641624() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test641625() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test641626() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test641627() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertEquals(3943, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test641628() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test641629() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test641630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test641631() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test641632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test641633() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test641634() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test641636() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test641637() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test641638() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test641639() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test641640() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test641641() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test641642() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(3953, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test641643() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test641644() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test641645() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test641646() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test641649() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0._rootValueSeparator = null;
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651721() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651722() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test651724() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651725() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651726() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651727() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651728() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651729() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651730() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, structural
    /**********************************************************
     */
@Override
public void writeStartArray() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an array"");
    _writeContext = _writeContext.createChildArrayContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartArray(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '[';
    }
}","public void test651731() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651745() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651746() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651747() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651748() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test651750() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651752() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651759() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651760() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651761() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651762() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(2, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test651765() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651766() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651767() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651768() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651769() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651770() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeStartObject() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '{';
    }
}","public void test651771() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651785() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651786() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test651790() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651791() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651792() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651793() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651794() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651795() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test651797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651811() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651812() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651813() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651814() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651815() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(2, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test651817() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651818() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651819() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651820() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651821() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, structural
    /**********************************************************
     */
@Override
public void writeStartArray() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an array"");
    _writeContext = _writeContext.createChildArrayContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartArray(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '[';
    }
}","public void test651823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651837() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651838() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651839() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651840() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test651842() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651843() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651844() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651845() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651846() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651847() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651848() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeEndArray() throws IOException, JsonGenerationException {
    if (!_writeContext.inArray()) {
        _reportError(""Current context not an ARRAY but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = ']';
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test651849() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651863() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651864() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651865() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651866() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651867() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(2, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test651869() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651872() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651873() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651874() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeEndObject() throws IOException, JsonGenerationException {
    if (!_writeContext.inObject()) {
        _reportError(""Current context not an object but "" + _writeContext.getTypeDesc());
    }
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '}';
    }
    _writeContext = _writeContext.clearAndGetParent();
}","public void test651875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test651889() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test651890() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test651891() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test651892() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test651894() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test651895() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test651896() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test651897() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test651898() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test651899() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test651900() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test651901() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""wr2ite a string"");
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.writeEndArray();
    writerBasedJsonGenerator0.writeEndObject();
    writerBasedJsonGenerator0.writeString(""wr2ite a string"");
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test661935() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test661936() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test661938() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test661939() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertEquals((-3300), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test661940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test661941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test661942() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test661944() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test661945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test661946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test661947() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test661961() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test661962() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test661964() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test661965() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals((-3300), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test661966() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test661967() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test661968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test661970() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test661971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test661972() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test661973() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, structural
    /**********************************************************
     */
@Override
public void writeStartArray() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an array"");
    _writeContext = _writeContext.createChildArrayContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartArray(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '[';
    }
}","public void test661974() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test661987() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test661988() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test661990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test661991() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals((-3300), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test661992() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test661993() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test661994() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test661996() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test661997() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test661998() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test661999() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test662000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(0, writerBasedJsonGenerator1.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test662001() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator1.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test662002() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertTrue(writerBasedJsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test662004() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test662005() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(0, writerBasedJsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test662006() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(1, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test662007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals((-3300), writerBasedJsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test662008() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test662009() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertFalse(writerBasedJsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Public API, other configuration
    /**********************************************************
      */
/**
 *  Method for setting a custom pretty printer, which is usually
 *  used to add indentation for improved human readability.
 *  By default, generator does not do pretty printing.
 * <p>
 *  To use the default pretty printer that comes with core
 *  Jackson distribution, call {@link #useDefaultPrettyPrinter}
 *  instead.
 *
 *  @return Generator itself (this), to allow chaining
 */
public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {
    _cfgPrettyPrinter = pp;
    return this;
}","public void test662010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test662029() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test662030() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test662032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test662033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals((-3300), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test662034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test662035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test662036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(21, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test662037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test662039() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test662040() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test662041() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test662042() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(0, writerBasedJsonGenerator1.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test662043() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator1.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test662044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(21, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test662045() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertTrue(writerBasedJsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test662047() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test662048() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(0, writerBasedJsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test662049() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals((-3300), writerBasedJsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test662050() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test662051() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertFalse(writerBasedJsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeNumber(long l) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedLong(l);
        return;
    }
    if ((_outputTail + 21) >= _outputEnd) {
        // up to 20 digits, minus sign
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);
}","public void test662052() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test662070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test662071() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test662073() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test662074() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals((-3300), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test662075() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test662076() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test662077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test662079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test662080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(34, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test662081() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test662082() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test662083() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator1.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test662084() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator1.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test662085() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertTrue(writerBasedJsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test662087() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test662088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test662089() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(34, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test662090() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals((-3300), writerBasedJsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test662091() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test662092() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test662093() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3300), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter();
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setPrettyPrinter(defaultPrettyPrinter0);
    writerBasedJsonGenerator1.writeNumber(9223372036854775807L);
    writerBasedJsonGenerator1.writeString(""nFs#Qt^1:"");
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test672192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test672193() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test672194() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test672195() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test672196() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertEquals(15, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test672197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test672198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test672199() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test672200() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test672202() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test672203() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test672204() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"protected void _verifyPrettyValueWrite(String typeMsg) throws IOException {
    final int status = _writeContext.writeValue();
    if (status == JsonWriteContext.STATUS_EXPECT_NAME) {
        _reportError(""Can not "" + typeMsg + "", expecting field name"");
    }
    // If we have a pretty printer, it knows what to do:
    switch(status) {
        case // array
        JsonWriteContext.STATUS_OK_AFTER_COMMA:
            _cfgPrettyPrinter.writeArrayValueSeparator(this);
            break;
        case JsonWriteContext.STATUS_OK_AFTER_COLON:
            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);
            break;
        case JsonWriteContext.STATUS_OK_AFTER_SPACE:
            _cfgPrettyPrinter.writeRootValueSeparator(this);
            break;
        case JsonWriteContext.STATUS_OK_AS_IS:
            // First entry, but of which context?
            if (_writeContext.inArray()) {
                _cfgPrettyPrinter.beforeArrayValues(this);
            } else if (_writeContext.inObject()) {
                _cfgPrettyPrinter.beforeObjectEntries(this);
            }
            break;
        default:
            _throwInternal();
            break;
    }
}","public void test672216() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.writeFieldName(""write a string"");
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0._verifyPrettyValueWrite("" (R,Q'46;l^"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test682226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test682227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test682237() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test682238() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test682240() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test682241() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test682242() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test682243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test682244() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test682245() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test682246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test682247() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test682248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test682262() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test682263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test682265() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test682266() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test682267() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test682268() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test682269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test682270() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test682271() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test682272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test682273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_writer != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _writer.flush();
        }
    }
}","public void test682274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.flush();
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test692295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test692296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test692308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test692309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test692311() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test692313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test692314() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test692315() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test692316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test692317() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test692318() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertEquals((-1122), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test692319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test692320() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test692334() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test692335() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test692337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test692339() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test692340() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test692341() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test692342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test692343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test692344() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals((-1122), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test692345() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test692346() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_writer != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _writer.flush();
        }
    }
}","public void test692347() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter(3);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-1122), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test702387() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test702388() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test702389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test702390() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test702391() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertEquals(2048, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test702392() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test702393() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test702394() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test702395() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test702397() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test702398() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test702414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test702415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test702416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test702417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test702418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(2048, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test702419() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test702420() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test702421() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test702422() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test702424() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test702425() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */
@Override
public void flush() throws IOException {
    _flushBuffer();
    if (_writer != null) {
        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            _writer.flush();
        }
    }
}","public void test702426() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2048, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.flush();
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test712460() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test712461() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test712463() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test712464() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test712465() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test712466() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test712467() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test712468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test712469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test712470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test712472() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test712486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test712487() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test712489() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test712490() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test712491() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test712492() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test712493() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test712494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test712495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test712496() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test712498() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test712499() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test712511() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test712512() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test712514() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test712515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test712516() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test712517() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test712518() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test712519() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test712520() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test712521() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test712523() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test712524() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    writerBasedJsonGenerator0.close();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test722558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test722559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test722561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test722562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test722564() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertEquals((-2097), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test722565() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test722566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test722567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test722568() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test722569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test722570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test722584() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test722585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test722587() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test722588() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test722590() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals((-2097), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test722591() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test722592() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test722593() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test722594() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test722595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test722596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, structural
    /**********************************************************
     */
@Override
public void writeStartArray() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an array"");
    _writeContext = _writeContext.createChildArrayContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartArray(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '[';
    }
}","public void test722597() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test722609() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test722610() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test722612() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test722613() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test722614() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test722616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertEquals((-2097), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test722617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test722618() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test722619() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test722620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test722621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test722622() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-2097), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartArray();
    writerBasedJsonGenerator0.close();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test732656() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test732657() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test732659() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test732660() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test732661() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test732662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertEquals(2, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test732663() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test732665() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test732666() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test732667() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test732668() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test732682() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test732683() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test732685() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test732686() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test732687() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test732688() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(1, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test732689() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(2, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test732691() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test732692() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test732693() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test732694() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeStartObject() throws IOException, JsonGenerationException {
    _verifyValueWrite(""start an object"");
    _writeContext = _writeContext.createChildObjectContext();
    if (_cfgPrettyPrinter != null) {
        _cfgPrettyPrinter.writeStartObject(this);
    } else {
        if (_outputTail >= _outputEnd) {
            _flushBuffer();
        }
        _outputBuffer[_outputTail++] = '{';
    }
}","public void test732695() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test732707() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test732708() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test732710() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test732711() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test732712() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertEquals(2, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test732713() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test732715() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test732716() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test732717() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test732718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test732719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test732720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 2, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeStartObject();
    writerBasedJsonGenerator0.close();
    assertEquals(3, BufferRecycler.BYTE_BASE64_CODEC_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test742752() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test742753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test742754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test742755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test742756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test742757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test742759() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test742760() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test742761() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test742762() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test742763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test742777() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test742778() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test742779() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test742780() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test742781() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test742782() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test742783() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test742785() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test742786() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test742787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test742788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test742789() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 0, (ObjectCodec) null, (Writer) null);
    writerBasedJsonGenerator0.close();
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test752823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test752824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test752826() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test752827() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test752828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertEquals((-4234), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test752829() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test752830() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test752831() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test752833() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test752834() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test752835() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test752849() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test752850() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test752852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test752853() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test752854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test752855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals((-4234), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test752856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test752857() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test752858() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test752860() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test752861() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void close() throws IOException {
    super.close();
    /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open
         *   scopes.
         */
    // First: let's see that we still have buffers...
    if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {
        while (true) {
            JsonStreamContext ctxt = getOutputContext();
            if (ctxt.inArray()) {
                writeEndArray();
            } else if (ctxt.inObject()) {
                writeEndObject();
            } else {
                break;
            }
        }
    }
    _flushBuffer();
    _outputHead = 0;
    _outputTail = 0;
    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()
         *   on the underlying Reader, unless we ""own"" it, or auto-closing
         *   feature is enabled.
         *   One downside: when using UTF8Writer, underlying buffer(s)
         *   may not be properly recycled if we don't close the writer.
         */
    if (_writer != null) {
        if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {
            _writer.close();
        } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {
            // If we can't close it, we should at least flush
            _writer.flush();
        }
    }
    // Internal buffer(s) generator has can now be released as well
    _releaseBuffers();
}","public void test752862() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-4234), (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.close();
    assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762894() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762895() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public char[] allocTokenBuffer() {
    _verifyAlloc(_tokenCBuffer);
    return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));
}","public void test762896() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762908() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762909() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test762911() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test762912() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test762913() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test762915() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test762916() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test762917() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test762918() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test762919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test762920() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762934() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762935() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test762936() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test762937() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test762938() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test762940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test762941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(3943, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test762942() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test762943() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test762944() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test762945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test762946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test762961() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test762962() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test762963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test762965() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test762966() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test762967() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test762968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test762969() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(3970, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test762970() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test762971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test762984() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test762985() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test762986() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test762987() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test762988() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test762990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test762991() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertEquals(3991, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test762992() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test762993() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test762994() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test762995() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test762996() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test763009() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test763010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test763011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test763012() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test763013() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertEquals(10, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test763014() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test763016() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test763017() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test763018() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test763019() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test763020() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test763021() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#t^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeString(charArray0, (int) 'c', 3);
    writerBasedJsonGenerator0.writeFieldName(""87'AS!yc)e"");
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test773102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test773103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test773104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test773105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test773107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test773108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test773109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test773110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test773111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test773112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test773113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test773114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringWriter stringWriter0 = new StringWriter(2048);
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, mockFileInputStream0, true);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputEnd = 2;
    writerBasedJsonGenerator0.writeFieldName("",!\u0007ExlysP>"");
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test783135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test783136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test783148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test783149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test783151() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test783152() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test783153() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test783154() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test783155() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test783156() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test783157() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test783158() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test783160() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test783174() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[8];
    charArray0[5] = '\u0084';
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeString(charArray0, 2, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 8
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test793223() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""XI"", false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[8];
    charArray0[2] = '0';
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeString(charArray0, 2, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 8
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test803246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test803247() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test803249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test803250() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test803251() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertEquals(596, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test803252() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test803253() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test803254() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test803255() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test803256() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test803257() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test803272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test803273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test803275() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test803276() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test803277() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertEquals(596, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test803278() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test803279() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test803280() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test803281() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test803282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test803283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test803285() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 596, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[3];
    charArray0[2] = '^';
    writerBasedJsonGenerator0.writeString(charArray0, 2, 1);
    assertArrayEquals(new char[] { '\u0000', '\u0000', '^' }, charArray0);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test813308() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test813309() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test813321() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test813322() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test813324() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test813325() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test813326() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test813327() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test813329() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test813330() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test813331() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test813332() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test813333() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test813347() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test813348() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test813350() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test813351() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test813352() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test813353() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test813355() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test813356() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test813357() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test813358() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(3, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test813359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test813360() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test813361() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test813362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test813364() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test813365() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(1, writerBasedJsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test813366() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test813367() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test813368() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertTrue(writerBasedJsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test813369() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(3, writerBasedJsonGenerator1.getHighestEscapedChar());
}",""
"@Override
public JsonGenerator setHighestNonEscapedChar(int charCode) {
    _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;
    return this;
}","public void test813370() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test813389() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test813390() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test813392() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test813393() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test813394() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertEquals(6, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test813395() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test813396() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test813398() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test813399() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test813400() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertEquals(3, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test813401() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test813402() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeFieldName(""^!mQh4s8eN[~(hT5ovd"");
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test823424() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test823425() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test823437() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test823438() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test823440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test823441() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test823443() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test823444() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test823445() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test823446() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test823447() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test823448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test823449() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test823463() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test823464() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test823466() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test823467() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test823469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test823470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test823471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test823472() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test823473() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test823474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test823475() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test823476() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test823477() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test823479() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test823480() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test823482() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test823483() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test823484() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test823485() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test823486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertEquals(21, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test823487() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test823488() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test823489() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    writerBasedJsonGenerator0.writeString(""v[~T2S<Z2b=/_2I.gGF"");
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test833525() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test833526() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test833528() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test833529() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test833530() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test833531() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test833532() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test833533() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test833535() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test833536() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test833537() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test833551() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test833552() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test833554() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test833555() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test833556() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test833557() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test833558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test833559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test833561() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test833562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(3, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test833563() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test833564() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator1.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test833565() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test833566() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test833567() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(0, writerBasedJsonGenerator1.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test833568() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(1, writerBasedJsonGenerator1.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test833570() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test833571() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertTrue(writerBasedJsonGenerator1.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test833572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(3, writerBasedJsonGenerator1.getHighestEscapedChar());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test833573() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertFalse(writerBasedJsonGenerator1.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public JsonGenerator setHighestNonEscapedChar(int charCode) {
    _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;
    return this;
}","public void test833574() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test833593() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test833594() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test833596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test833597() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test833598() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test833599() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test833600() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test833602() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertEquals(20, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test833603() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test833604() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertEquals(3, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test833605() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test833606() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    char[] charArray0 = WriterBasedJsonGenerator.HEX_CHARS;
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    WriterBasedJsonGenerator writerBasedJsonGenerator1 = (WriterBasedJsonGenerator) writerBasedJsonGenerator0.setHighestNonEscapedChar(3);
    writerBasedJsonGenerator0.writeString(charArray0, 2, 3);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test843642() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test843643() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test843645() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test843646() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test843647() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test843649() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test843650() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test843651() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test843652() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test843653() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test843654() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test843668() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[7];
    charArray0[4] = 'M';
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeString(charArray0, 2, 11);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 7
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test853730() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""v[~T2S<Z2b=/_2I.gGF"", true);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    int[] intArray0 = new int[7];
    writerBasedJsonGenerator0._outputEscapes = intArray0;
    char[] charArray0 = new char[9];
    charArray0[2] = '_';
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeString(charArray0, 0, 56320);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test863740() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test863741() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test863753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test863754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test863756() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test863757() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test863758() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test863759() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test863760() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test863761() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test863763() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test863764() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test863765() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test863779() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test863780() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test863782() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test863783() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertEquals(3, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test863784() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test863785() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test863786() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test863787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test863789() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test863790() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test863791() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test863792() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringWriter stringWriter0 = new StringWriter(1);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[2];
    charArray0[0] = '*';
    writerBasedJsonGenerator0.writeString(charArray0, 0, 1);
    assertArrayEquals(new char[] { '*', '\u0000' }, charArray0);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873826() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873827() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertTrue(iOContext0.isResourceManaged());
}",""
"public char[] allocTokenBuffer() {
    _verifyAlloc(_tokenCBuffer);
    return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));
}","public void test873828() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873840() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873841() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test873843() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test873844() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test873845() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test873846() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test873847() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test873848() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test873850() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test873851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test873852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873866() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873867() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test873869() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test873870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test873871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test873872() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test873873() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test873875() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertEquals(4, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test873876() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test873877() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test873878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeBoolean(boolean state) throws IOException {
    _verifyValueWrite(WRITE_BOOLEAN);
    if ((_outputTail + 5) >= _outputEnd) {
        _flushBuffer();
    }
    int ptr = _outputTail;
    char[] buf = _outputBuffer;
    if (state) {
        buf[ptr] = 't';
        buf[++ptr] = 'r';
        buf[++ptr] = 'u';
        buf[++ptr] = 'e';
    } else {
        buf[ptr] = 'f';
        buf[++ptr] = 'a';
        buf[++ptr] = 'l';
        buf[++ptr] = 's';
        buf[++ptr] = 'e';
    }
    _outputTail = ptr + 1;
}","public void test873879() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873891() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873892() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test873893() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(3949, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test873894() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test873895() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test873896() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test873897() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test873898() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test873900() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test873901() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test873902() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test873903() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873916() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873917() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test873918() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test873919() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test873920() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test873921() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test873922() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test873924() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test873925() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(3976, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test873926() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test873927() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test873928() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test873941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test873942() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test873943() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test873944() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test873945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test873946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test873947() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test873949() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test873950() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test873951() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test873952() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test873953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", true);
    char[] charArray0 = iOContext0.allocTokenBuffer();
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBoolean(true);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[16];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, BufferRecycler.BYTE_WRITE_ENCODING_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test883988() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test883989() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public byte[] allocWriteEncodingBuffer() {
    _verifyAlloc(_writeEncodingBuffer);
    return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));
}","public void test883990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test884000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test884001() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test884003() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test884004() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test884006() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test884007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test884008() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test884009() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test884010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test884011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test884012() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test884026() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test884027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test884028() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test884029() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test884031() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test884032() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test884033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(2677, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test884034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test884035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test884036() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test884037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test884038() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test884051() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test884052() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test884064() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test884065() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test884077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test884078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test884079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test884080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test884082() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canOmitFields() {
    return true;
}","public void test884083() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test884084() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertEquals(2405, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test884085() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test884086() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test884087() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test884088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test884090() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 97, 4000);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 1);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) pushbackInputStream0, 2789);
    assertEquals(2789, int0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertNull(iOContext0.getEncoding());
}",""
"public char[] allocTokenBuffer(int minSize) {
    _verifyAlloc(_tokenCBuffer);
    return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, minSize));
}","public void test894126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}","/**
 * @since 2.4
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894141() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894142() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894143() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894146() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894147() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894149() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894150() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894164() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894165() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894166() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894167() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894169() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(3943, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894170() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894171() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894172() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894173() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894174() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894175() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test894176() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894189() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894190() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(3954, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894193() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894195() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894196() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894197() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894198() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894199() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894200() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test894201() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894215() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894216() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894217() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894218() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894220() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894221() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894222() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894223() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894224() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894225() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertEquals(3974, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test894227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894239() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894240() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894241() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894242() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894243() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertEquals(3979, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894245() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894247() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894248() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894250() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"/*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */
@Override
public void writeNumber(short s) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedShort(s);
        return;
    }
    // up to 5 digits and possible minus sign
    if ((_outputTail + 6) >= _outputEnd) {
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
}","public void test894251() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894263() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894264() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894265() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894266() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894267() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertEquals(3980, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894269() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894270() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894271() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894273() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894274() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public void writeRaw(char c) throws IOException {
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = c;
}","public void test894275() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test894295() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test894296() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertNull(iOContext0.getEncoding());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test894297() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test894298() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test894300() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test894301() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test894302() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test894303() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test894304() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test894305() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test894306() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertEquals(3989, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test894307() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    assertEquals(0, BufferRecycler.CHAR_TOKEN_BUFFER);
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test894319() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "")Rb5E.KPv*t/R$q_%s^"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[6];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName("")Rb5E.KPv*t/R$q_%s^"");
    writerBasedJsonGenerator0.writeNumber((short) 2401);
    writerBasedJsonGenerator0.writeRaw('L');
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    int int0 = byteArrayInputStream0.read();
    writerBasedJsonGenerator0.writeString(""u%Th*A"");
    try {
        writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 10);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Too few bytes available: missing 5 bytes (out of 10)
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test904342() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test904343() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public byte[] allocWriteEncodingBuffer() {
    _verifyAlloc(_writeEncodingBuffer);
    return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));
}","public void test904344() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertEquals(1, BufferRecycler.CHAR_CONCAT_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test904354() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test904355() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test904357() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _features;
}","public void test904358() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test904359() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test904360() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test904362() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test904363() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test904364() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test904365() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test904366() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test904380() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test904381() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    assertNull(iOContext0.getEncoding());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test904393() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    try {
        writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 56319);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Too few bytes available: missing 48320 bytes (out of 56319)
        //
        verifyException(""com.fasterxml.jackson.core.JsonGenerator"", e);
    }
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test914416() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test914417() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    assertNull(iOContext0.getEncoding());
}",""
"public byte[] allocWriteEncodingBuffer(int minSize) {
    _verifyAlloc(_writeEncodingBuffer);
    return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, minSize));
}","public void test914418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    assertEquals(2, BufferRecycler.CHAR_TEXT_BUFFER);
}","/**
 * @since 2.4
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test914428() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test914429() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test914431() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test914432() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test914433() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test914434() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test914435() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test914436() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test914437() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test914438() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test914440() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test914454() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test914455() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test914467() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test914468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test914469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test914470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test914471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test914472() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test914473() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertEquals(1267, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test914474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertEquals(2677, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test914475() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test914476() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test914478() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test914480() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""*:"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer(2);
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1267, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, 55296);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-1867));
    assertEquals(7999, int0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test924579() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test924580() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test924581() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test924582() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test924583() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test924584() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test924585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test924586() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test924588() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test924589() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test924590() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertEquals(3958, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public void writeBinary(byte[] data) throws IOException {
    writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);
}","public void test924591() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also
 * assumes that whole byte array is to be output.
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test924605() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test924606() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test924607() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test924608() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(3968, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test924609() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test924610() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test924611() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test924612() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test924613() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test924615() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test924616() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
@Override
public void writeFieldName(String name) throws IOException {
    int status = _writeContext.writeFieldName(name);
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
        _reportError(""Can not write a field name, expecting a value"");
    }
    _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));
}","public void test924617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test924629() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test924630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test924631() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test924632() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test924633() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test924634() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test924635() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test924636() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test924638() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test924639() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test924640() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertEquals(3973, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"/*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */
@Override
public void writeNumber(short s) throws IOException {
    _verifyValueWrite(WRITE_NUMBER);
    if (_cfgNumbersAsStrings) {
        _writeQuotedShort(s);
        return;
    }
    // up to 5 digits and possible minus sign
    if ((_outputTail + 6) >= _outputEnd) {
        _flushBuffer();
    }
    _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);
}","public void test924641() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test924657() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test924658() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test924659() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test924660() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test924661() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertEquals(3985, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test924662() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test924663() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test924664() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test924665() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test924667() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test924668() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */
@Override
public void writeString(String text) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (text == null) {
        _writeNull();
        return;
    }
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test924669() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    assertEquals(3, BufferRecycler.CHAR_NAME_COPY_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test924681() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test924682() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test924683() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test924684() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test924685() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test924686() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test924687() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test924688() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test924690() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test924691() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertEquals(5, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canOmitFields() {
    return true;
}","public void test924692() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test924694() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFs#Qt^1:"", false);
    char[] charArray0 = iOContext0.allocTokenBuffer(0);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0.writeString(charArray0, 3, 3987);
    byte[] byteArray0 = new byte[7];
    writerBasedJsonGenerator0.writeBinary(byteArray0);
    writerBasedJsonGenerator0.writeFieldName(""nFs#Qt^1:"");
    writerBasedJsonGenerator0.writeNumber((short) 2415);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 56319);
    writerBasedJsonGenerator0.writeString(""nFs#Qt^1:"");
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-295));
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test934718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test934719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test934731() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test934732() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public byte[] allocWriteEncodingBuffer() {
    _verifyAlloc(_writeEncodingBuffer);
    return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));
}","public void test934733() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertEquals(2, BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test934743() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test934744() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test934746() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test934747() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test934748() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test934749() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test934750() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test934751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test934753() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test934754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertEquals((-3793), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test934755() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test934769() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test934770() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test934782() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test934783() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertFalse(iOContext0.isResourceManaged());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test934785() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test934786() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertEquals(50, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test934787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test934788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test934789() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"public boolean canWriteObjectId() {
    return false;
}","public void test934790() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test934792() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test934793() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertEquals((-3793), writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test934794() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test934796() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""nFsQt^1{"", false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, (-3793), (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 30, 35);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, (-3793));
    assertEquals(35, int0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test944832() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test944833() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertNull(iOContext0.getEncoding());
}",""
"public byte[] allocWriteEncodingBuffer() {
    _verifyAlloc(_writeEncodingBuffer);
    return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));
}","public void test944834() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    assertEquals(0, BufferRecycler.BYTE_READ_IO_BUFFER);
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test944844() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test944845() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test944848() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test944849() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test944850() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test944851() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test944852() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test944853() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test944854() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test944855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test944856() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test944870() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test944871() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test944883() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test944884() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertNull(iOContext0.getEncoding());
}",""
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test944887() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test944888() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertEquals(6, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test944889() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertEquals(3, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test944890() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test944891() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test944892() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public boolean canWriteTypeId() {
    return false;
}","public void test944893() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test944894() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test944895() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public int writeBinary(InputStream data, int dataLength) throws IOException {
    return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);
}","public void test944897() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    byte[] byteArray0 = iOContext0.allocWriteEncodingBuffer();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 3, (ObjectCodec) null, stringWriter0);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2500, 56319);
    int int0 = writerBasedJsonGenerator0.writeBinary((InputStream) byteArrayInputStream0, 2);
    assertEquals(2, int0);
}","/**
 * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},
 * but assumes default to using the Jackson default Base64 variant
 * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).
 *
 * @param data InputStream to use for reading binary data to write.
 *    Will not be closed after successful write operation
 * @param dataLength (optional) number of bytes that will be available;
 *    or -1 to be indicate it is not known. Note that implementations
 *    need not support cases where length is not known in advance; this
 *    depends on underlying data format: JSON output does NOT require length,
 *    other formats may
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test954933() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test954934() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test954936() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test954937() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test954938() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test954939() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertEquals(4519, writerBasedJsonGenerator0.getFeatureMask());
}",""
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test954940() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test954941() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test954942() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test954943() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test954945() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test954959() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertNull(iOContext0.getEncoding());
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test954960() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertFalse(iOContext0.isResourceManaged());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test954962() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test954963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test954964() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertEquals(127, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test954965() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertEquals(4519, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test954966() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test954967() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test954968() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test954969() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertEquals(56319, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public int getFormatFeatures() {
    return 0;
}","public void test954971() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public void writeNull() throws IOException {
    _verifyValueWrite(WRITE_NULL);
    _writeNull();
}","public void test954972() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 4519, (ObjectCodec) null, stringWriter0);
    writerBasedJsonGenerator0._outputTail = 56319;
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeNull();
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.StringWriter"", e);
    }
}",""
"public boolean isResourceManaged() {
    return _managedResource;
}","public void test964995() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(iOContext0.isResourceManaged());
}",""
"public JsonEncoding getEncoding() {
    return _encoding;
}","public void test964996() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertNull(iOContext0.getEncoding());
}",""
"public boolean canWriteBinaryNatively() {
    return false;
}","public void test964998() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteBinaryNatively());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports ""native"" binary data; that is, an efficient
 *  output of binary content without encoding.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native binary content.
 *
 *  @since 2.3
 */"
"public int getFormatFeatures() {
    return 0;
}","public void test964999() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getFormatFeatures());
}","/**
 * Bulk access method for getting state of all {@link FormatFeature}s, format-specific
 * on/off configuration settings.
 *
 * @return Bit mask that defines current states of all standard {@link FormatFeature}s.
 *
 * @since 2.6
 */"
"@Override
public int getOutputBuffered() {
    // Assuming tail and head are kept but... trust and verify:
    int len = _outputTail - _outputHead;
    return Math.max(0, len);
}","public void test965000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getOutputBuffered());
}",""
"public boolean canWriteObjectId() {
    return false;
}","public void test965001() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteObjectId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Object Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeObjectId} or {@link #writeObjectRef}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Object Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native object ids.
 *
 *  @since 2.3
 */"
"@Override
public int getHighestEscapedChar() {
    return _maximumNonEscapedChar;
}","public void test965002() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(0, writerBasedJsonGenerator0.getHighestEscapedChar());
}",""
"@Override
public int getFeatureMask() {
    return _features;
}","public void test965003() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertEquals(1, writerBasedJsonGenerator0.getFeatureMask());
}",""
"public boolean canWriteTypeId() {
    return false;
}","public void test965004() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.canWriteTypeId());
}","/**
 *  Introspection method that may be called to see if the underlying
 *  data format supports some kind of Type Ids natively (many do not;
 *  for example, JSON doesn't).
 *  This method <b>must</b> be called prior to calling
 *  {@link #writeTypeId}.
 * <p>
 *  Default implementation returns false; overridden by data formats
 *  that do support native Type Ids. Caller is expected to either
 *  use a non-native notation (explicit property or such), or fail,
 *  in case it can not use native type ids.
 *
 *  @since 2.3
 */"
"public boolean canOmitFields() {
    return true;
}","public void test965006() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertTrue(writerBasedJsonGenerator0.canOmitFields());
}","/**
 * Introspection method to call to check whether it is ok to omit
 * writing of Object fields or not. Most formats do allow omission,
 * but certain positional formats (such as CSV) require output of
 * placeholders, even if no real values are to be emitted.
 *
 * @since 2.3
 */"
"@Override
public boolean isClosed() {
    return _closed;
}","public void test965007() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    assertFalse(writerBasedJsonGenerator0.isClosed());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite(WRITE_STRING);
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
    _writeString(text, offset, len);
    // And finally, closing quotes
    if (_outputTail >= _outputEnd) {
        _flushBuffer();
    }
    _outputBuffer[_outputTail++] = '""';
}","public void test965021() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = new WriterBasedJsonGenerator(iOContext0, 1, (ObjectCodec) null, stringWriter0);
    char[] charArray0 = new char[7];
    charArray0[5] = '\""';
    // Undeclared exception!
    try {
        writerBasedJsonGenerator0.writeString(charArray0, 1, 482);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 7
        //
        verifyException(""com.fasterxml.jackson.core.json.WriterBasedJsonGenerator"", e);
    }
}",""
