focal_method,test_prefix,docstring
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test0000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2181, (-2966), false);
    try {
        readerBasedJsonParser0._reportInvalidToken("""", """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '': was expecting
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000004; line: 1, column: -784]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test0011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000005; line: 1, column: 51]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"public final boolean isStructStart() {
    return _isStructStart;
}","public void test0022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1764), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = readerBasedJsonParser0._handleApos();
    assertFalse(jsonToken0.isStructStart());
}","/**
 * Accessor that is functionally equivalent to:
 * <code>
 *    this == JsonToken.START_OBJECT || this == JsonToken.START_ARRAY
 * </code>
 *
 * @since 2.3
 */"
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test0033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""a1w*Z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing ''' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000006; line: 1, column: 11]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test0044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""_r,Ji8EW^9@/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('_' (code 95)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test0055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("" of 4-char base64 unit: can only used between units"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parsePosNumber(2574);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test0066() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, false);
    StringReader stringReader0 = new StringReader(""}N1`"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 33, false);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe(49, ""HO4[<GGgGVmK"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('1' (code 49)): was expecting double-quote to start field name
        //  at [Source: UNKNOWN; line: 1, column: 34]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return null;
    }
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test0077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""u0SEW d@'eK&^kn"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'u0SEW': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000007; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, access to token information, text and similar
    /**********************************************************
     */
@Override
public boolean hasTextCharacters() {
    // usually true
    if (_currToken == JsonToken.VALUE_STRING) {
        return true;
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nameCopied;
    }
    return false;
}","public void test0088() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, false);
    StringReader stringReader0 = new StringReader(""): "");
    char[] charArray0 = new char[6];
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2399), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2399), 22, false);
    readerBasedJsonParser0._closeInput();
    assertFalse(readerBasedJsonParser0.hasTextCharacters());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0099() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""S"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    byte[] byteArray0 = new byte[4];
    ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
    CharBuffer charBuffer0 = byteBuffer0.asCharBuffer();
    stringReader0.read(charBuffer0);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1818, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-2001), false);
    readerBasedJsonParser0.nextLongValue(0);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test01010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""3^lQb/y<.b,KILVa3i8"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1445), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Abstract methods needed from sub-classes
    /**********************************************************
     */
protected abstract boolean loadMore() throws IOException;","public void test01111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, (-1664), false);
    boolean boolean0 = readerBasedJsonParser0.loadMore();
    assertFalse(boolean0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test01212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""\""Na [AVw_`e-v 6If"", true);
    StringReader stringReader0 = new StringReader(""m2g"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2, true);
    String string0 = readerBasedJsonParser0.getValueAsString((String) null);
    assertNull(string0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test01313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString("""");
    assertEquals("""", string0);
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01414() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""': expected '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 57, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 39, 0, false);
    char char0 = readerBasedJsonParser0.getNextChar(""': expected '"");
    assertEquals('\'', char0);
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01515() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""3(SI299"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-2173), true);
    char char0 = readerBasedJsonParser0.getNextChar("""");
    assertArrayEquals(new char[] { '3', '(', 'S', 'I', '2', '9', '9', '\u0000' }, charArray0);
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""f.5):l?YuDHA~"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2091), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0.getNextChar(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
    assertEquals('f', char0);
}",""
"public long getByteOffset() {
    return _totalBytes;
}","public void test01718() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v{[OvNK0^d8z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 111, 2, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test01719() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v{[OvNK0^d8z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 111, 2, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test01720() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v{[OvNK0^d8z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 111, 2, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(112, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test01721() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v{[OvNK0^d8z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 111, 2, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(111L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test01822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-463), jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test01823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-464L), jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test01824() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test01825() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2907, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-464), (-1354), true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test01926() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_NUMERIC_LEADING_ZEROS"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals(""{"", string0);
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02027() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 43, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 48, 56, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 48
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, false);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02229() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, Integer.MAX_VALUE, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 799, 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextLongValue(0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02330() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.type.ResolvedType"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 2928, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextLongValue(0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 33
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test02431() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""$g2F .-q-"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextIntValue(43);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return null;
    }
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test02532() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 44, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 241, 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return null;
    }
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test02633() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""A@RA;dKa*x5P8"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 2046, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 33
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test02734() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("">"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 52, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-3451), 3434, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3451
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test02835() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""QiSON~eFIdi]WTwsEb"");
    stringReader0.close();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test02936() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[9];
    charArray0[2] = 'Z';
    charArray0[3] = 'o';
    charArray0[4] = 'M';
    charArray0[5] = '^';
    charArray0[6] = 'u';
    charArray0[7] = 'y';
    charArray0[8] = '~';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 102, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test03037() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader(""$g2F .-q-"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test03138() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Unexpected end-of-input within/between "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 37, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 37, 0, true);
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test03239() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken((String) null, (String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test03340() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Duplicate field '"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1833), 3, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""Duplicate field '"", ""Duplicate field '"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test03441() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "" entries"", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    stringReader0.close();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken("" entries"", "" entries"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test03542() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""AGA>WK6e]DB"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test03643() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Sr@Z0NMVAHrq!5$"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    stringReader0.close();
    try {
        readerBasedJsonParser0._reportInvalidToken(""Sr@Z0NMVAHrq!5$"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"@Override
protected void _releaseBuffers() throws IOException {
    super._releaseBuffers();
    // merge new symbols, if any
    _symbols.release();
    // and release buffers, if they are recyclable ones
    if (_bufferRecyclable) {
        char[] buf = _inputBuffer;
        if (buf != null) {
            _inputBuffer = null;
            _ioContext.releaseTokenBuffer(buf);
        }
    }
}","public void test03744() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""CM,F*,8W?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 2, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._releaseBuffers();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}","/**
 * Method called to release internal buffers owned by the base
 * reader. This may be called along with {@link #_closeInput} (for
 * example, when explicitly closing this reader instance), or
 * separately (if need be).
 */"
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test03845() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1100, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2323), 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2323
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test03946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Unrecognized token '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 2, false);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test04047() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2774, 2, true);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test04148() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""R?y[B]/$?hq`4h"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, (-3464), 748, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""Wa(&/bk*f ^"", 291);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test04249() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 44, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._matchToken("""", 0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test04350() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Pbyz7~!Ld0!"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-707), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 5, 1092, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleOddName((-3366));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3366
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {
    if (ch == 'I') {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOFInValue();
            }
        }
        ch = _inputBuffer[_inputPtr++];
        if (ch == 'N') {
            String match = negative ? ""-INF"" : ""+INF"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        } else if (ch == 'n') {
            String match = negative ? ""-Infinity"" : ""+Infinity"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        }
    }
    reportUnexpectedNumberChar(ch, ""expected digit (0-9) to follow minus sign, for valid numeric value"");
    return null;
}","public void test04451() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""}"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 278, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleInvalidNumberStart(0, false);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000008; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called if expected numeric value (due to leading sign) does not
 * look like a number
 */"
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test04552() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Null String illegal for SerializedString"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1659, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2), 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test04653() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 3, 1491, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test04754() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 4306, 3471, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test04855() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""l}pT@=^i#iE7\""4(ELY"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, (-1705), (-1705), false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test04956() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("" bytes"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 178, (-637), true);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read -637
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test05360() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""JF,RkA_3PQ}d65nKt6B"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000009; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test05461() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2371), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextToken();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Base method defs, overrides
    /**********************************************************
     */
@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test05562() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""}"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(objectCodec0).toString();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 278, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = readerBasedJsonParser0.getCodec();
    assertSame(objectCodec1, objectCodec0);
}",""
"public long getByteOffset() {
    return _totalBytes;
}","public void test05663() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test05664() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test05665() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(0L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test05666() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    doReturn((Object) null).when(iOContext0).getSourceReference();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    StringBuilder sb = new StringBuilder(matchedPart);
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                break;
            }
        }
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
    }
    _reportError(""Unrecognized token '"" + sb.toString() + ""': was expecting "" + msg);
}","public void test05767() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""AUTO_CLOSE_SOURCE"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken(""AUTO_CLOSE_SOURCE"", ""}-)Y`s:"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'AUTO_CLOSE_SOURCEAUTO_CLOSE_SOURCE': was expecting }-)Y`s:
        //  at [Source: UNKNOWN; line: 1, column: 35]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    do {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidToken(matchStr.substring(0, i));
            }
        }
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    // but let's also ensure we either get EOF, or non-alphanum char...
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            return;
        }
    }
    char c = _inputBuffer[_inputPtr];
    if (c < '0' || c == ']' || c == '}') {
        // expected/allowed chars
        return;
    }
    // if Java letter, it's a problem tho
    if (Character.isJavaIdentifierPart(c)) {
        _reportInvalidToken(matchStr.substring(0, i));
    }
    return;
}","public void test05868() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""c4M`oY="", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 262144, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 50, (-1628), false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken("""", 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF("" in character escape sequence"");
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("" in character escape sequence"");
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test05969() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2345, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1583, (-1072), false);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: UNKNOWN; line: 1, column: 512]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test06070() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("">*3)!w\""55|[vs-x"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-592), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 32, (-1751), false);
    readerBasedJsonParser0._skipCR();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test06171() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-969), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test06272() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""CGJH~jCSix\""<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2751), 226, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2751
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test06373() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""!G0Sa781E$"", false);
    StringReader stringReader0 = new StringReader(""!G0Sa781E$"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: java.lang.String@0000000010; line: 1, column: 21]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    /* Either ran out of input, or bumped into an escape
         * sequence...
         */
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test06474() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""eID^@[)4Y169"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000011; line: 1, column: 25]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected JsonToken _handleOddValue(int i) throws IOException {
    // Most likely an error, unless we are to allow single-quote-strings
    switch(i) {
        case '\'':
            /* [JACKSON-173]: allow single quotes. Unlike with regular
             * Strings, we'll eagerly parse contents; this so that there's
             * no need to store information on quote char used.
             *
             * Also, no separation to fast/slow parsing; we'll just do
             * one regular (~= slowish) parsing, to keep code simple
             */
            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
                return _handleApos();
            }
            break;
        case 'N':
            _matchToken(""NaN"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""NaN"", Double.NaN);
            }
            _reportError(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case 'I':
            _matchToken(""Infinity"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""Infinity"", Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case // note: '-' is taken as number
        '+':
            if (_inputPtr >= _inputEnd) {
                if (!loadMore()) {
                    _reportInvalidEOFInValue();
                }
            }
            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);
    }
    // [Issue#77] Try to decode most likely token
    if (Character.isJavaIdentifierStart(i)) {
        _reportInvalidToken("""" + ((char) i), ""('true', 'false' or 'null')"");
    }
    // but if it doesn't look like a token:
    _reportUnexpectedChar(i, ""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    return null;
}","public void test06575() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("" of 4-char base64 unit: can only used between units"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "" of 4-char base64 unit: can only used between units"", true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddValue(78);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'N': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: java.lang.String@0000000012; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method for handling cases where first non-space character
 * of an expected value token is not legal for standard JSON content.
 */"
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test06676() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""US-ASCII"", true);
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 571, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextFieldName();
    assertTrue(readerBasedJsonParser0.hasCurrentToken());
}",""
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test06777() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""["");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 700, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleOddName(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('!' (code 33)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000013; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test06878() throws Throwable {
    TextBuffer textBuffer0 = mock(TextBuffer.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(textBuffer0).getCurrentSegment();
    doReturn(0).when(textBuffer0).getCurrentSegmentSize();
    doReturn((char[]) null).when(textBuffer0).getTextBuffer();
    doReturn(0).when(textBuffer0).getTextOffset();
    doReturn(0).when(textBuffer0).size();
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn(textBuffer0).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""': expected '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 52, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, (-488), true);
    String string0 = readerBasedJsonParser0._parseAposName();
    assertEquals("""", string0);
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test06979() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""x|R!R5YnYXU%cz3uk "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000014; line: 1, column: 37]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test07080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""VALUE_FALSE"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2047, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._decodeEscaped();
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing '\""' for name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 23]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07181() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Infinity"", false);
    StringReader stringReader0 = new StringReader(""): has to be escaped using backslash to be included in "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (')' (code 41)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: java.lang.String@0000000016; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test07282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""ItgL7&BPR'If"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2282, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('t' (code 116)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000017; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test07383() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1583, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2838), 1583, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parsePosNumber((-2838));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2838
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test07484() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""0aT|;,"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""0aT|;,"", false);
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 32, 2, false);
    try {
        readerBasedJsonParser0._parsePosNumber('T');
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('a' (code 97)): Expected space separating root-level values
        //  at [Source: java.lang.String@0000000018; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test07585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2371), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test07686() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 984, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(2760);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test07687() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 984, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.nextIntValue(2760);
    assertEquals(2760, int0);
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test07788() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("" of 4-char base64 unit: can only used between units"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(78);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'of': was expecting ('true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000019; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test07889() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1089), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test07990() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[2] = '{';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 3, true);
    SerializedString serializedString0 = new SerializedString("""");
    readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
    assertEquals(1, readerBasedJsonParser0.getCurrentTokenId());
}",""
"@Override
public int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test08091() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""["");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 700, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextFieldName();
    assertEquals(3, readerBasedJsonParser0.getCurrentTokenId());
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test08192() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""('true', 'false' or 'null')"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe(0, ""Exponent indicator not followed by a digit"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): was expecting double-quote to start field name
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000020; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return false;
    }
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test08293() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{SPa0Upf-4=\""dp'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    readerBasedJsonParser0._handleApos();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return false;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return false;
    }
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test08394() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""0aT|;,"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""0aT|;,"", false);
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 32, 2, false);
    SerializedString serializedString0 = new SerializedString("""");
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('a' (code 97)): Expected space separating root-level values
        //  at [Source: java.lang.String@0000000021; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test08495() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""tE!Y9p\"""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 56, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(3);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'tE': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000022; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test08596() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-Infinity"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4208, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Non-standard token '-Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000023; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test08697() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""],)+]A:i ~]{WiMRK"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2905, 1918, false);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected close marker ']': expected '}' (for ROOT starting at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000001; line: 1, column: 0])
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000024; line: 1, column: 1920]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_ARRAY);
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        return (_currToken = JsonToken.END_OBJECT);
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test08798() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("": was expecting closing '"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (':' (code 58)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000025; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int readBinaryValue(OutputStream out) throws IOException {
    return readBinaryValue(Base64Variants.getDefaultVariant(), out);
}","public void test08899() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    try {
        readerBasedJsonParser0.readBinaryValue((OutputStream) byteArrayBuilder0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that can be used as an alternative to {@link #getBigIntegerValue()},
 * especially when value can be large. The main difference (beyond method
 * of returning content using {@link OutputStream} instead of as byte array)
 * is that content will NOT remain accessible after method returns: any content
 * processed will be consumed and is not buffered in any way. If caller needs
 * buffering, it has to implement it.
 *
 * @param out Output stream to use for passing decoded binary data
 *
 * @return Number of bytes that were decoded and written via {@link OutputStream}
 *
 * @since 2.1
 */"
"@Override
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {
        _reportError(""Current token ("" + _currToken + "") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"");
    }
    /* To ensure that we won't see inconsistent data, better clear up
         * state...
         */
    if (_tokenIncomplete) {
        try {
            _binaryValue = _decodeBase64(b64variant);
        } catch (IllegalArgumentException iae) {
            throw _constructError(""Failed to decode VALUE_STRING as base64 ("" + b64variant + ""): "" + iae.getMessage());
        }
        /* let's clear incomplete only now; allows for accessing other
             * textual content in error cases
             */
        _tokenIncomplete = false;
    } else {
        // may actually require conversion...
        if (_binaryValue == null) {
            @SuppressWarnings(""resource"")
            ByteArrayBuilder builder = _getByteArrayBuilder();
            _decodeBase64(getText(), builder, b64variant);
            _binaryValue = builder.toByteArray();
        }
    }
    return _binaryValue;
}","public void test089100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""US-ASCII"", true);
    StringReader stringReader0 = new StringReader(""'null', 'true', 'false' or NaN"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1431, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1414, (-2808), true);
    try {
        readerBasedJsonParser0.getBinaryValue((Base64Variant) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: java.lang.String@0000000026; line: 1, column: 1415]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test090101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    StringReader stringReader0 = new StringReader(""com.fasterxml.jackson.core.type.ResolvedType"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 2928, true);
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test091102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(0, int0);
}",""
"@Override
public final char[] getTextCharacters() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test092103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    char[] charArray1 = readerBasedJsonParser0.getTextCharacters();
    assertNull(charArray1);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test093104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 97, true);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertNull(string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test094105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 33, true);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test095106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""0aT|;,"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""0aT|;,"", false);
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 32, 2, false);
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals("""", string0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test096107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""["");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 700, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString(""["");
    assertNotNull(string0);
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(null);
}","public void test097109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString();
    assertNull(string0);
}",""
"/*
    /**********************************************************
    /* Public API, data access
    /**********************************************************
     */
/**
 * Method for accessing textual representation of the current event;
 * if no current event (before first call to {@link #nextToken}, or
 * after encountering end-of-input), returns null.
 * Method can be called for any event.
 */
@Override
public final String getText() throws IOException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return _getText2(t);
}","public void test098110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""eID^@[)4Y169"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-1480), 1, true);
    String string0 = readerBasedJsonParser0.getText();
    assertNull(string0);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test099111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 10, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 51, 0, false);
    readerBasedJsonParser0.nextFieldName();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test100112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-Infinity"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4231, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000027; line: 1, column: 19]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test101113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(2);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test101114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    long long0 = readerBasedJsonParser0.nextLongValue(2);
    assertEquals(2L, long0);
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test102115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""["");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    stringReader0.read(charArray0);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 0, false);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputNo digit following minus sign
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000028; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected char getNextChar(String eofMsg) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!loadMore()) {
            _reportInvalidEOF(eofMsg);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test103116() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 80, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar(""^/w6!AHT|_?9\""HS"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                _inputPtr = inPtr;
                c = _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test104117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""v{[OvNK0^d8z"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 111, 2, false);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"");
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test105118() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2900, 33, true);
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 46]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test106119() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("" of 4-char base64 unit: can only used between units"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 8, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    StringWriter stringWriter0 = new StringWriter(3);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
    assertEquals(0, int0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test107120() throws Throwable {
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext((BufferRecycler) null, object0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 40, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 32, 40, true);
    StringWriter stringWriter0 = new StringWriter();
    // Undeclared exception!
    try {
        readerBasedJsonParser0.releaseBuffered((Writer) stringWriter0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.StringWriter"", e);
    }
}",""
"public long getByteOffset() {
    return _totalBytes;
}","public void test108121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""exM*tBz6;Ush"", false);
    StringReader stringReader0 = new StringReader(""cg5J<"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 2, 33, false);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET) {
        _updateLocation();
        if (!_parsingContext.inArray()) {
            _reportMismatchedEndMarker(i, '}');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_ARRAY;
        return null;
    }
    if (i == INT_RCURLY) {
        _updateLocation();
        if (!_parsingContext.inObject()) {
            _reportMismatchedEndMarker(i, ']');
        }
        _parsingContext = _parsingContext.getParent();
        _currToken = JsonToken.END_OBJECT;
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
    }
    _updateLocation();
    if (!_parsingContext.inObject()) {
        _nextTokenNotInObject(i);
        return null;
    }
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test109122() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""ItgL7&BPR'If"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2282, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'ItgL7': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000029; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean hasCurrentToken() {
    return _currToken != null;
}","public void test110123() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""[Euail03_c"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    readerBasedJsonParser0.setCodec(objectCodec1);
    assertFalse(readerBasedJsonParser0.hasCurrentToken());
}",""
"@Override
public Object getInputSource() {
    return _reader;
}","public void test111124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""Unexpected end-of-input within/between "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 37, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 37, 0, true);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertSame(object0, stringReader0);
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test112125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken("""");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test113126() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 127, 677, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken("""");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
