focal_method,test_prefix,docstring
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test0000() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Numeric value ("", true);
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'Numeric': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 8]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test0011() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("")G;ihw"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 41, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (')' (code 41)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public int getTokenColumnNr() {
    // note: value of -1 means ""not available""; otherwise convert from 0-based to 1-based
    int col = _tokenInputCol;
    return (col < 0) ? col : (col + 1);
}","public void test0022() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""T<;),L'&}K,+B"", false);
    StringReader stringReader0 = new StringReader(""jv%i#IWVpcB'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._skipCR();
    assertEquals(1, readerBasedJsonParser0.getTokenColumnNr());
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test0033() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""zp7|p`M!Vu[mEF1"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1989), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 4337, 3, false);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 20]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    // Either ran out of input, or bumped into an escape sequence...
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test0044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""/'-W"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 10, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 10, 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test0055() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in name
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test0066() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""X],\""h["");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('X' (code 88)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test0077() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 16, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe(187, ""^dX;K"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\u00BB' (code 187)): was expecting double-quote to start field name
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test0088() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(0L);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test0099() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""P"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 4, 1, true);
    String string0 = readerBasedJsonParser0.getValueAsString((String) null);
    assertNull(string0);
}",""
"// @since 2.1
@Override
public final String getValueAsString(String defValue) throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(defValue);
}","public void test01010() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""$|?3QfvU"", false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 118, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString("""");
    assertEquals("""", string0);
}",""
"protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF(eofMsg, forToken);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01111() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    charArray0[0] = '0';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1503, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 68, false);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    char char0 = readerBasedJsonParser0.getNextChar("""", jsonToken0);
    assertEquals('0', char0);
}",""
"protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF(eofMsg, forToken);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test01212() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[0] = 'P';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 11, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 1, true);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    char char0 = readerBasedJsonParser0.getNextChar((String) null, jsonToken0);
    assertEquals('P', char0);
}",""
"// since 2.8
@Deprecated
protected char getNextChar(String eofMsg) throws IOException {
    return getNextChar(eofMsg, null);
}","public void test01313() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""{r"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 0, false);
    char char0 = readerBasedJsonParser0.getNextChar(""{r"");
    assertArrayEquals(new char[] { '{', 'r', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000' }, charArray0);
}",""
"// since 2.8
@Deprecated
protected char getNextChar(String eofMsg) throws IOException {
    return getNextChar(eofMsg, null);
}","public void test01415() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""05*d{g1+"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    char char0 = readerBasedJsonParser0.getNextChar(""tSzMo;]t"");
    assertEquals('0', char0);
}",""
"@Override
public Object getInputSource() {
    return _reader;
}","public void test01516() throws Throwable {
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, charsToNameCanonicalizer0, true);
    char[] charArray0 = new char[7];
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 708, 68, true);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertNull(object0);
}",""
"public long getByteOffset() {
    return _totalBytes;
}","public void test01617() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    char[] charArray0 = iOContext0.allocConcatBuffer();
    StringReader stringReader0 = new StringReader(""$GM*`]sMnX1a3I>"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-235), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1670, 759, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public long getCharOffset() {
    return _totalChars;
}","public void test01618() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    char[] charArray0 = iOContext0.allocConcatBuffer();
    StringReader stringReader0 = new StringReader(""$GM*`]sMnX1a3I>"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-235), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1670, 759, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1670L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test01619() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    char[] charArray0 = iOContext0.allocConcatBuffer();
    StringReader stringReader0 = new StringReader(""$GM*`]sMnX1a3I>"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-235), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1670, 759, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test01620() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    char[] charArray0 = iOContext0.allocConcatBuffer();
    StringReader stringReader0 = new StringReader(""$GM*`]sMnX1a3I>"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-235), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1670, 759, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1671, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"/*
    /**********************************************************
    /* Base method defs, overrides
    /**********************************************************
     */
@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test01721() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-821), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    ObjectCodec objectCodec0 = readerBasedJsonParser0.getCodec();
    assertNull(objectCodec0);
}",""
"protected boolean _loadMore() throws IOException {
    final int bufSize = _inputEnd;
    _currInputProcessed += bufSize;
    _currInputRowStart -= bufSize;
    // 26-Nov-2015, tatu: Since name-offset requires it too, must offset
    //   this increase to avoid ""moving"" name-offset, resulting most likely
    //   in negative value, which is fine as combine value remains unchanged.
    _nameStartOffset -= bufSize;
    if (_reader != null) {
        int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);
        if (count > 0) {
            _inputPtr = 0;
            _inputEnd = count;
            return true;
        }
        // End of input
        _closeInput();
        // Should never return 0, so let's fail
        if (count == 0) {
            throw new IOException(""Reader returned 0 characters when trying to read "" + _inputEnd);
        }
    }
    return false;
}","public void test01822() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""*[J@csH8_f&m+g\""e"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    boolean boolean0 = readerBasedJsonParser0._loadMore();
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        // Should actually close/release things
        // like input source, symbol table and recyclable buffers now.
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return _currToken;
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return _currToken;
            }
        }
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case '}':
            // Error: } is not valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test01923() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", false);
    StringReader stringReader0 = new StringReader(""was expecting double-quote to start field name"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 117, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2275, 4279, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2275
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02024() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""name"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final String nextTextValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            return _textBuffer.contentsAsString();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
}","public void test02125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""],)+]A:i ~]{WiMRK"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 53, 512, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextTextValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 53
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02226() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1644), (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 614, 12, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextLongValue((-2489L));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test02327() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""\nRequest payload : "");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, (-1833), 3, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextLongValue(1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1833
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test02428() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""dte0H^>rv|}~6> 2$q"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 34, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextIntValue(2);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'dte0H': was expecting ('true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return false;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test02529() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""Qitww4{XU~9**b-~_"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, stringReader0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-936), 33, true);
    SerializedString serializedString0 = new SerializedString("""");
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -936
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test02630() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader(""-R"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    char[] charArray0 = new char[5];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 56320, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-921), 44, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -921
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test02731() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 34, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF(eofMsg, forToken);
        }
    }
    return _inputBuffer[_inputPtr++];
}","public void test02832() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 768, 2, true);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    try {
        readerBasedJsonParser0.getNextChar("""", jsonToken0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input
        //  at [Source: UNKNOWN; line: 1, column: 771]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"// since 2.8
@Deprecated
protected char getNextChar(String eofMsg) throws IOException {
    return getNextChar(eofMsg, null);
}","public void test02933() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 482, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, (char[]) null, 0, 0, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar("""");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test03034() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("",}EVw}os8"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, (char[]) null, 1, (-541), true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test03135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    charArray0[3] = ':';
    charArray0[4] = '@';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 115, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test03236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 78, 1, true);
    IOContext iOContext1 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser1 = new ReaderBasedJsonParser(iOContext1, 2132, stringReader0, objectCodec1, charsToNameCanonicalizer0);
    readerBasedJsonParser1._closeInput();
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    StringBuilder sb = new StringBuilder(matchedPart);
    while ((_inputPtr < _inputEnd) || _loadMore()) {
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
        if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {
            sb.append(""..."");
            break;
        }
    }
    _reportError(""Unrecognized token '%s': was expecting %s"", sb, msg);
}","public void test03337() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, """", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 722, 857, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""}"", ""gP'~*ht,!G}CFXWjX"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 722
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _reportInvalidToken(String matchedPart, String msg) throws IOException {
    /* Let's just try to find what appears to be the token, using
         * regular Java identifier character rules. It's just a heuristic,
         * nothing fancy here.
         */
    StringBuilder sb = new StringBuilder(matchedPart);
    while ((_inputPtr < _inputEnd) || _loadMore()) {
        char c = _inputBuffer[_inputPtr];
        if (!Character.isJavaIdentifierPart(c)) {
            break;
        }
        ++_inputPtr;
        sb.append(c);
        if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {
            sb.append(""..."");
            break;
        }
    }
    _reportError(""Unrecognized token '%s': was expecting %s"", sb, msg);
}","public void test03438() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""Zm?C"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 0, false);
    try {
        readerBasedJsonParser0._reportInvalidToken(""KwhP7o?*Kf>OmNbG"", ""Zm?C"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'KwhP7o?*Kf>OmNbGZm': was expecting Zm?C
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test03539() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""$|?3QfvU"", false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, (Reader) null, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 0, 3, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""$|?3QfvU"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test03640() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""FH[(2qit*!=/)A[Dr"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 35, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._reportInvalidToken(""FH[(2qit*!=/)A[Dr"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Error reporting
    /**********************************************************
     */
protected void _reportInvalidToken(String matchedPart) throws IOException {
    _reportInvalidToken(matchedPart, ""'null', 'true', 'false' or NaN"");
}","public void test03741() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""' (code 0x"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1278, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._reportInvalidToken(""' (code 0x"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token '' (code 0x': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
protected void _releaseBuffers() throws IOException {
    super._releaseBuffers();
    // merge new symbols, if any
    _symbols.release();
    // and release buffers, if they are recyclable ones
    if (_bufferRecyclable) {
        char[] buf = _inputBuffer;
        if (buf != null) {
            _inputBuffer = null;
            _ioContext.releaseTokenBuffer(buf);
        }
    }
}","public void test03842() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""i%l"", true);
    StringReader stringReader0 = new StringReader(""z ]NV8"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._releaseBuffers();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}","/**
 * Method called to release internal buffers owned by the base
 * reader. This may be called along with {@link #_closeInput} (for
 * example, when explicitly closing this reader instance), or
 * separately (if need be).
 */"
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test03943() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""RH@Amv\u00079P&@k^>"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 102, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 1391, 0, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parsePosNumber(1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test04044() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""('true', 'false' or 'null')"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-584), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parsePosNumber(3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test04145() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""zp7|p`M!Vu[mEF1"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._releaseBuffers();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test04246() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""t`S6=-9:c1"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1907), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2895, 2, true);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test04347() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in field name
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    if ((_inputPtr + len) >= _inputEnd) {
        _matchToken2(matchStr, i);
        return;
    }
    do {
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    int ch = _inputBuffer[_inputPtr];
    if (ch >= '0' && ch != ']' && ch != '}') {
        // expected/allowed chars
        _checkMatchEnd(matchStr, i, ch);
    }
}","public void test04448() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""GUma$#P>.|"", false);
    StringReader stringReader0 = new StringReader(""GUma$#P>.|"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""GUma$#P>.|"", 57);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    if ((_inputPtr + len) >= _inputEnd) {
        _matchToken2(matchStr, i);
        return;
    }
    do {
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    int ch = _inputBuffer[_inputPtr];
    if (ch >= '0' && ch != ']' && ch != '}') {
        // expected/allowed chars
        _checkMatchEnd(matchStr, i, ch);
    }
}","public void test04549() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""): "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-933), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-772), 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._matchToken(""): "", 114);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -772
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"/*
    /**********************************************************
    /* Low-level access, supporting
    /**********************************************************
     */
protected void _loadMoreGuaranteed() throws IOException {
    if (!_loadMore()) {
        _reportInvalidEOF();
    }
}","public void test04650() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""ixV"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 1, (-851), true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._loadMoreGuaranteed();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Low-level access, supporting
    /**********************************************************
     */
protected void _loadMoreGuaranteed() throws IOException {
    if (!_loadMore()) {
        _reportInvalidEOF();
    }
}","public void test04751() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""t`S6=-9:c1"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1907), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2895, 2, true);
    try {
        readerBasedJsonParser0._loadMoreGuaranteed();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected boolean _loadMore() throws IOException {
    final int bufSize = _inputEnd;
    _currInputProcessed += bufSize;
    _currInputRowStart -= bufSize;
    // 26-Nov-2015, tatu: Since name-offset requires it too, must offset
    //   this increase to avoid ""moving"" name-offset, resulting most likely
    //   in negative value, which is fine as combine value remains unchanged.
    _nameStartOffset -= bufSize;
    if (_reader != null) {
        int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);
        if (count > 0) {
            _inputPtr = 0;
            _inputEnd = count;
            return true;
        }
        // End of input
        _closeInput();
        // Should never return 0, so let's fail
        if (count == 0) {
            throw new IOException(""Reader returned 0 characters when trying to read "" + _inputEnd);
        }
    }
    return false;
}","public void test04852() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((char[]) null).when(iOContext0).allocTokenBuffer();
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""F3~)kx^$<MFG|r"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._loadMore();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected JsonToken _handleOddValue(int i) throws IOException {
    // Most likely an error, unless we are to allow single-quote-strings
    switch(i) {
        case '\'':
            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse
             * contents; this so that there'sno need to store information on quote char used.
             * Also, no separation to fast/slow parsing; we'll just do
             * one regular (~= slowish) parsing, to keep code simple
             */
            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
                return _handleApos();
            }
            break;
        case ']':
            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled
             *   we may allow ""missing values"", that is, encountering a trailing
             *   comma or closing marker where value would be expected
             */
            if (!_parsingContext.inArray()) {
                break;
            }
        // fall through
        case ',':
            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {
                --_inputPtr;
                return JsonToken.VALUE_NULL;
            }
            break;
        case 'N':
            _matchToken(""NaN"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""NaN"", Double.NaN);
            }
            _reportError(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case 'I':
            _matchToken(""Infinity"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""Infinity"", Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case // note: '-' is taken as number
        '+':
            if (_inputPtr >= _inputEnd) {
                if (!_loadMore()) {
                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);
                }
            }
            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);
    }
    // [core#77] Try to decode most likely token
    if (Character.isJavaIdentifierStart(i)) {
        _reportInvalidToken("""" + ((char) i), ""('true', 'false' or 'null')"");
    }
    // but if it doesn't look like a token:
    _reportUnexpectedChar(i, ""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    return null;
}","public void test04953() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 2, false);
    try {
        readerBasedJsonParser0._handleOddValue(0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method for handling cases where first non-space character
 * of an expected value token is not legal for standard JSON content.
 */"
"protected JsonToken _handleOddValue(int i) throws IOException {
    // Most likely an error, unless we are to allow single-quote-strings
    switch(i) {
        case '\'':
            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse
             * contents; this so that there'sno need to store information on quote char used.
             * Also, no separation to fast/slow parsing; we'll just do
             * one regular (~= slowish) parsing, to keep code simple
             */
            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
                return _handleApos();
            }
            break;
        case ']':
            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled
             *   we may allow ""missing values"", that is, encountering a trailing
             *   comma or closing marker where value would be expected
             */
            if (!_parsingContext.inArray()) {
                break;
            }
        // fall through
        case ',':
            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {
                --_inputPtr;
                return JsonToken.VALUE_NULL;
            }
            break;
        case 'N':
            _matchToken(""NaN"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""NaN"", Double.NaN);
            }
            _reportError(""Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case 'I':
            _matchToken(""Infinity"", 1);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(""Infinity"", Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
            break;
        case // note: '-' is taken as number
        '+':
            if (_inputPtr >= _inputEnd) {
                if (!_loadMore()) {
                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);
                }
            }
            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);
    }
    // [core#77] Try to decode most likely token
    if (Character.isJavaIdentifierStart(i)) {
        _reportInvalidToken("""" + ((char) i), ""('true', 'false' or 'null')"");
    }
    // but if it doesn't look like a token:
    _reportUnexpectedChar(i, ""expected a valid value (number, String, array, object, 'true', 'false' or 'null')"");
    return null;
}","public void test05054() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 3, 2501, false);
    try {
        readerBasedJsonParser0._handleOddValue((-315));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in null
        //  at [Source: UNKNOWN; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}","/**
 * Method for handling cases where first non-space character
 * of an expected value token is not legal for standard JSON content.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test05155() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 78, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleOddName((-1195));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1195
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test05256() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 46, true);
    try {
        readerBasedJsonParser0._handleOddName(0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): was expecting double-quote to start field name
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected String _handleOddName(int i) throws IOException {
    // [JACKSON-173]: allow single quotes
    if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {
        return _parseAposName();
    }
    // [JACKSON-69]: allow unquoted names if feature enabled:
    if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {
        _reportUnexpectedChar(i, ""was expecting double-quote to start field name"");
    }
    final int[] codes = CharTypes.getInputCodeLatin1JsNames();
    final int maxCode = codes.length;
    // Also: first char must be a valid name char, but NOT be number
    boolean firstOk;
    if (i < maxCode) {
        // identifier, or a number ([Issue#102])
        firstOk = (codes[i] == 0);
    } else {
        firstOk = Character.isJavaIdentifierPart((char) i);
    }
    if (!firstOk) {
        _reportUnexpectedChar(i, ""was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"");
    }
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode) {
                if (codes[ch] != 0) {
                    // -1 to bring back first char
                    int start = _inputPtr - 1;
                    _inputPtr = ptr;
                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
                }
            } else if (!Character.isJavaIdentifierPart((char) ch)) {
                // -1 to bring back first char
                int start = _inputPtr - 1;
                _inputPtr = ptr;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr - 1;
    _inputPtr = ptr;
    return _handleOddName2(start, hash, codes);
}","public void test05357() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-985), (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 33, false);
    try {
        readerBasedJsonParser0._handleOddName((-985));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in null
        //  at [Source: UNKNOWN; line: 1, column: 34]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}","/**
 * Method called when we see non-white space character other
 * than double quote, when expecting a field name.
 * In standard mode will just throw an expection; but
 * in non-standard modes may be able to parse name.
 */"
"protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException {
    if (ch == 'I') {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);
            }
        }
        ch = _inputBuffer[_inputPtr++];
        if (ch == 'N') {
            String match = negative ? ""-INF"" : ""+INF"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        } else if (ch == 'n') {
            String match = negative ? ""-Infinity"" : ""+Infinity"";
            _matchToken(match, 3);
            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {
                return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
            }
            _reportError(""Non-standard token '"" + match + ""': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"");
        }
    }
    reportUnexpectedNumberChar(ch, ""expected digit (0-9) to follow minus sign, for valid numeric value"");
    return null;
}","public void test05458() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 156, (-1927), false);
    try {
        readerBasedJsonParser0._handleInvalidNumberStart((-1927), false);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('\uF879' (code -1927)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 157]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called if expected numeric value (due to leading sign) does not
 * look like a number
 */"
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test05559() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, "":"", true);
    StringReader stringReader0 = new StringReader("":"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 48, 2623, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 48
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected void _finishString2() throws IOException {
    char[] outBuf = _textBuffer.getCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    final int[] codes = _icLatin1;
    final int maxCode = codes.length;
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i < maxCode && codes[i] != 0) {
            if (i == INT_QUOTE) {
                break;
            } else if (i == INT_BACKSLASH) {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i < INT_SPACE) {
                _throwUnquotedSpace(i, ""string value"");
            }
            // anything else?
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
}","public void test05660() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""CfxRdb%"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-3015), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    try {
        readerBasedJsonParser0._finishString2();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    // Either ran out of input, or bumped into an escape sequence...
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test05761() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2286), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextFieldName();
    // Undeclared exception!
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test05862() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    StringReader stringReader0 = new StringReader(""t`S6=-9:c1"");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-3023), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 1748, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test05963() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 55, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 3, false);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 3
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Base method defs, overrides
    /**********************************************************
     */
@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test06367() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(objectCodec0).toString();
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 378, 754, false);
    ObjectCodec objectCodec1 = readerBasedJsonParser0.getCodec();
    assertSame(objectCodec1, objectCodec0);
}",""
"public long getCharOffset() {
    return _totalChars;
}","public void test06468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(0L, jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test06469() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test06470() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test06471() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getCurrentLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        // Should actually close/release things
        // like input source, symbol table and recyclable buffers now.
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return _currToken;
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return _currToken;
            }
        }
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case '}':
            // Error: } is not valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test06572() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""ALLOW_SINGLE_QUOTES"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""ALLOW_SINGLE_QUOTES"", true);
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 2, true);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'ALLOW_SINGLE_QUOTES': was expecting ('true', 'false' or 'null')
        //  at [Source: (String)\""ALLOW_SINGLE_QUOTES\""; line: 1, column: 25]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public long getCharOffset() {
    return _totalChars;
}","public void test06673() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 78, 1, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals((-1L), jsonLocation0.getCharOffset());
}","/**
 * @return Character offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"public int getColumnNr() {
    return _columnNr;
}","public void test06674() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 78, 1, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals(0, jsonLocation0.getColumnNr());
}","/**
 * @return Column number of the location (1-based)
 */"
"public int getLineNr() {
    return _lineNr;
}","public void test06675() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 78, 1, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals(1, jsonLocation0.getLineNr());
}","/**
 * @return Line number of the location (1-based)
 */"
"public long getByteOffset() {
    return _totalBytes;
}","public void test06676() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 49, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 78, 1, true);
    JsonLocation jsonLocation0 = readerBasedJsonParser0.getTokenLocation();
    assertEquals((-1L), jsonLocation0.getByteOffset());
}","/**
 * @return Byte offset within underlying stream, reader or writer,
 *   if available; -1 if not.
 */"
"protected final void _matchToken(String matchStr, int i) throws IOException {
    final int len = matchStr.length();
    if ((_inputPtr + len) >= _inputEnd) {
        _matchToken2(matchStr, i);
        return;
    }
    do {
        if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {
            _reportInvalidToken(matchStr.substring(0, i));
        }
        ++_inputPtr;
    } while (++i < len);
    int ch = _inputBuffer[_inputPtr];
    if (ch >= '0' && ch != ']' && ch != '}') {
        // expected/allowed chars
        _checkMatchEnd(matchStr, i, ch);
    }
}","public void test06777() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""dv~XX,h"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 13, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 13, 0, false);
    try {
        readerBasedJsonParser0._matchToken(""mZeY"", 1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'mdv': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Helper method for checking whether input matches expected token
 */"
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test06878() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = 't';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    char char0 = readerBasedJsonParser0._decodeEscaped();
    assertEquals('\t', char0);
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test06979() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""4"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(33);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in character escape sequence
        //  at [Source: UNKNOWN; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
protected char _decodeEscaped() throws IOException {
    if (_inputPtr >= _inputEnd) {
        if (!_loadMore()) {
            _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
        }
    }
    char c = _inputBuffer[_inputPtr++];
    switch((int) c) {
        // First, ones that are mapped
        case 'b':
            return '\b';
        case 't':
            return '\t';
        case 'n':
            return '\n';
        case 'f':
            return '\f';
        case 'r':
            return '\r';
        // And these are to be returned as they are
        case '""':
        case '/':
        case '\\':
            return c;
        case // and finally hex-escaped
        'u':
            break;
        default:
            return _handleUnrecognizedCharacterEscape(c);
    }
    // Ok, a hex escape. Need 4 characters
    int value = 0;
    for (int i = 0; i < 4; ++i) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("" in character escape sequence"", JsonToken.VALUE_STRING);
            }
        }
        int ch = (int) _inputBuffer[_inputPtr++];
        int digit = CharTypes.charToHex(ch);
        if (digit < 0) {
            _reportUnexpectedChar(ch, ""expected a hex-digit for character escape sequence"");
        }
        value = (value << 4) | digit;
    }
    return (char) value;
}","public void test07080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""4"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._decodeEscaped();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized character escape '4' (code 52)
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || _loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test07181() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""6A6#a2:S}/xzyaZZ/"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 936, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 0, false);
    readerBasedJsonParser0._skipCR();
    assertArrayEquals(new char[] { '6', 'A', '6', '#', 'a', '2', ':', 'S' }, charArray0);
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || _loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test07282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""9S3V1f&zERN`,("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 101, stringReader0, objectCodec0, charsToNameCanonicalizer0, (char[]) null, 33, 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._skipCR();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other parsing
    /**********************************************************
     */
/**
 * We actually need to check the character value here
 * (to see if we have \n following \r).
 */
protected final void _skipCR() throws IOException {
    if (_inputPtr < _inputEnd || _loadMore()) {
        if (_inputBuffer[_inputPtr] == '\n') {
            ++_inputPtr;
        }
    }
    ++_currInputRow;
    _currInputRowStart = _inputPtr;
}","public void test07383() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    readerBasedJsonParser0._skipCR();
    assertArrayEquals(new char[] { '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000' }, charArray0);
}",""
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test07484() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"", false);
    StringReader stringReader0 = new StringReader(""maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 78, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 4647, false);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in string value
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"protected final void _skipString() throws IOException {
    _tokenIncomplete = false;
    int inPtr = _inputPtr;
    int inLen = _inputEnd;
    char[] inBuf = _inputBuffer;
    while (true) {
        if (inPtr >= inLen) {
            _inputPtr = inPtr;
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
            inPtr = _inputPtr;
            inLen = _inputEnd;
        }
        char c = inBuf[inPtr++];
        int i = (int) c;
        if (i <= INT_BACKSLASH) {
            if (i == INT_BACKSLASH) {
                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,
                // does that affect decoding? For now let's assume it does not.
                _inputPtr = inPtr;
                /*c = */
                _decodeEscaped();
                inPtr = _inputPtr;
                inLen = _inputEnd;
            } else if (i <= INT_QUOTE) {
                if (i == INT_QUOTE) {
                    _inputPtr = inPtr;
                    break;
                }
                if (i < INT_SPACE) {
                    _inputPtr = inPtr;
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
    }
}","public void test07585() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("" within/between "");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._skipString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 33]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}","/**
 * Method called to skim through rest of unparsed String value,
 * if it is not needed. This can be done bit faster if contents
 * need not be stored for future access.
 */"
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    // Either ran out of input, or bumped into an escape sequence...
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test07686() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = 't';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 26]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    // Either ran out of input, or bumped into an escape sequence...
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test07787() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in string value
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test07888() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""t5hFSHr_$79'nT<U("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    charArray0[0] = ']';
    charArray0[1] = ' ';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1939, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 47, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test07989() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""t5hFSHr_$79'nT<U("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[2];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1939, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 47, false);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal unquoted character ((CTRL-CHAR, code 0)): has to be escaped using backslash to be included in string value
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected JsonToken _handleApos() throws IOException {
    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
    int outPtr = _textBuffer.getCurrentSegmentSize();
    while (true) {
        if (_inputPtr >= _inputEnd) {
            if (!_loadMore()) {
                _reportInvalidEOF("": was expecting closing quote for a string value"", JsonToken.VALUE_STRING);
            }
        }
        char c = _inputBuffer[_inputPtr++];
        int i = (int) c;
        if (i <= '\\') {
            if (i == '\\') {
                /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                c = _decodeEscaped();
            } else if (i <= '\'') {
                if (i == '\'') {
                    break;
                }
                if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                }
            }
        }
        // Need more room?
        if (outPtr >= outBuf.length) {
            outBuf = _textBuffer.finishCurrentSegment();
            outPtr = 0;
        }
        // Ok, let's add char to output:
        outBuf[outPtr++] = c;
    }
    _textBuffer.setCurrentLength(outPtr);
    return JsonToken.VALUE_STRING;
}","public void test08090() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""1YzsfN0"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 120, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 0, true);
    try {
        readerBasedJsonParser0._handleApos();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 15]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test08191() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""NV]bO"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 53, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2536), 73, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2536
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test08292() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-2), (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe(0, ""ALLOW_NON_NUMERIC_NUMBERS"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected String _parseAposName() throws IOException {
    // Note: mostly copy of_parseFieldName
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch == '\'') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            if (ch < maxCode && codes[ch] != 0) {
                break;
            }
            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
            ++ptr;
        } while (ptr < inputLen);
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, '\'');
}","public void test08393() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""^SU^qax\""jQ'nF<LGMQ"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-313), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0._parseAposName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test08494() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[1] = 't';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in field name
        //  at [Source: UNKNOWN; line: 1, column: 26]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08595() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    StringReader stringReader0 = new StringReader(""((Zkn?XkdyGaRU{"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 514, 514, true);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('(' (code 40)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 516]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08696() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    StringReader stringReader0 = new StringReader(""+Infinity"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext1 = new IOContext(bufferRecycler0, iOContext0, false);
    char[] charArray0 = new char[9];
    charArray0[3] = '<';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext1, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 677, false);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('<' (code 60)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08797() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-850), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, true);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-inputNo digit following minus sign
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"protected final JsonToken _parseNegNumber() throws IOException {
    int ptr = _inputPtr;
    // to include sign/digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    if (ptr >= inputLen) {
        return _parseNumber2(true, startPtr);
    }
    int ch = _inputBuffer[ptr++];
    // First check: must have a digit to follow minus sign
    if (ch > INT_9 || ch < INT_0) {
        _inputPtr = ptr;
        return _handleInvalidNumberStart(ch, true);
    }
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(true, startPtr);
    }
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            return _parseNumber2(true, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, true, intLen);
    }
    --ptr;
    _inputPtr = ptr;
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(true, intLen);
}","public void test08898() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    StringReader stringReader0 = new StringReader(""+Infinity"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext1 = new IOContext(bufferRecycler0, iOContext0, false);
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext1, 3, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 677, false);
    try {
        readerBasedJsonParser0._parseNegNumber();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)) in numeric value: expected digit (0-9) to follow minus sign, for valid numeric value
        //  at [Source: UNKNOWN; line: 1, column: 5]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, number parsing
    /**********************************************************
     */
/**
 *  Initial parsing method for number values. It needs to be able
 *  to parse enough input to be able to determine whether the
 *  value is to be considered a simple integer value, or a more
 *  generic decimal value: latter of which needs to be expressed
 *  as a floating point number. The basic rule is that if the number
 *  has no fractional or exponential part, it is an integer; otherwise
 *  a floating point number.
 * <p>
 *  Because much of input has to be processed in any case, no partial
 *  parsing is done: all input text will be stored for further
 *  processing. However, actual numeric value conversion will be
 *  deferred, since it is usually the most complicated and costliest
 *  part of processing.
 */
protected final JsonToken _parsePosNumber(int ch) throws IOException {
    /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
    int ptr = _inputPtr;
    // to include digit already read
    int startPtr = ptr - 1;
    final int inputLen = _inputEnd;
    // One special case, leading zero(es):
    if (ch == INT_0) {
        return _parseNumber2(false, startPtr);
    }
    /* First, let's see if the whole number is contained within
         * the input buffer unsplit. This should be the common case;
         * and to simplify processing, we will just reparse contents
         * in the alternative case (number split on buffer boundary)
         */
    // already got one
    int intLen = 1;
    // First let's get the obligatory integer part:
    int_loop: while (true) {
        if (ptr >= inputLen) {
            _inputPtr = startPtr;
            return _parseNumber2(false, startPtr);
        }
        ch = (int) _inputBuffer[ptr++];
        if (ch < INT_0 || ch > INT_9) {
            break int_loop;
        }
        ++intLen;
    }
    if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {
        _inputPtr = ptr;
        return _parseFloat(ch, startPtr, ptr, false, intLen);
    }
    // Got it all: let's add to text buffer for parsing, access
    // need to push back following separator
    --ptr;
    _inputPtr = ptr;
    // As per #105, need separating space between root values; check here
    if (_parsingContext.inRoot()) {
        _verifyRootSpace(ch);
    }
    int len = ptr - startPtr;
    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
    return resetInt(false, intLen);
}","public void test08999() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    charArray0[3] = '2';
    charArray0[4] = 'b';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1718, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 3, 1665, true);
    try {
        readerBasedJsonParser0._parsePosNumber((-772));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('b' (code 98)): Expected space separating root-level values
        //  at [Source: UNKNOWN; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test090100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""cJc,om$/?"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2132, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._closeInput();
    readerBasedJsonParser0.nextBooleanValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final int nextIntValue(int defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getIntValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;
}","public void test091101() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""%#c{@u7-qaJ"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 69, 98, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextIntValue(98);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 69
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test092102() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, (Reader) null, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextTextValue();
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test093103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""NV]bO"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 40, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1295, 3, true);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'NV': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 6]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test094104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""A% O"", false);
    StringReader stringReader0 = new StringReader(""A% O"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 256, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'A': was expecting ('true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test095105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""81.&xM /1^w1 ;tt,w4"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1604), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('&' (code 38)) in numeric value: Decimal point not followed by a digit
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException {
    // // // and this is back to standard nextToken()
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return nameToMatch.equals(name);
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return nameToMatch.equals(name);
}","public void test096106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""p"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0._isNextTokenNameMaybe((-404), ""p"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in null
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test097107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 4, (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.io.IOContext"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test098108() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    SerializedString serializedString0 = new SerializedString("""");
    boolean boolean0 = readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
    assertTrue(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return false;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test098109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    SerializedString serializedString0 = new SerializedString("""");
    boolean boolean0 = readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
    assertFalse(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return false;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test099110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""L`$^%Oum`{y`"", true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    charArray0[0] = '|';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 656, true);
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('|' (code 124)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* JsonParser impl
    /**********************************************************
     */
/**
 * Method that can be called to get the name associated with
 * the current event.
 */
@Override
public String getCurrentName() throws IOException {
    // [JACKSON-395]: start markers require information from parent
    if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {
        JsonReadContext parent = _parsingContext.getParent();
        if (parent != null) {
            return parent.getCurrentName();
        }
    }
    return _parsingContext.getCurrentName();
}","public void test100111() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 1, 2, false);
    readerBasedJsonParser0.finishToken();
    assertNull(readerBasedJsonParser0.getCurrentName());
}",""
"@Override
public int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test101112() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""false"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(33);
    assertEquals(10, readerBasedJsonParser0.getCurrentTokenId());
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test102113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""81.&xM /1^w1 ;tt,w4"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1604), stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(0L);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('&' (code 38)) in numeric value: Decimal point not followed by a digit
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test103114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""5*d{g~"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextLongValue(33);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ('*' (code 42)): Expected space separating root-level values
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in UTF8StreamJsonParser
@Override
public final Boolean nextBooleanValue() throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_TRUE) {
            return Boolean.TRUE;
        }
        if (t == JsonToken.VALUE_FALSE) {
            return Boolean.FALSE;
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return null;
    }
    JsonToken t = nextToken();
    if (t != null) {
        int id = t.id();
        if (id == ID_TRUE)
            return Boolean.TRUE;
        if (id == ID_FALSE)
            return Boolean.FALSE;
    }
    return null;
}","public void test104115() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""Illegal character ("", true);
    StringReader stringReader0 = new StringReader("""");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[5];
    charArray0[0] = '3';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 322, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 0, 57, true);
    try {
        readerBasedJsonParser0.nextBooleanValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character ((CTRL-CHAR, code 0)): Expected space separating root-level values
        //  at [Source: UNKNOWN; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        // Should actually close/release things
        // like input source, symbol table and recyclable buffers now.
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return _currToken;
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return _currToken;
            }
        }
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case '}':
            // Error: } is not valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test105116() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""05*d{g1+"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextToken();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Invalid numeric value: Leading zeroes not allowed
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// note: identical to one in Utf8StreamParser
@Override
public final long nextLongValue(long defaultValue) throws IOException {
    if (_currToken == JsonToken.FIELD_NAME) {
        // mostly copied from '_nextAfterName'
        _nameCopied = false;
        JsonToken t = _nextToken;
        _nextToken = null;
        _currToken = t;
        if (t == JsonToken.VALUE_NUMBER_INT) {
            return getLongValue();
        }
        if (t == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        } else if (t == JsonToken.START_OBJECT) {
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        }
        return defaultValue;
    }
    // !!! TODO: optimize this case as well
    return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;
}","public void test106117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""H`$W- -S6D0VUsR:"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[9];
    charArray0[2] = ']';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1600), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 1, 109, true);
    readerBasedJsonParser0._decodeEscaped();
    try {
        readerBasedJsonParser0.nextLongValue((-376L));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected close marker ']': expected '}' (for root starting at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 0])
        //  at [Source: (com.fasterxml.jackson.core.util.BufferRecycler); line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {
        return _binaryValue;
    }
    if (_currToken != JsonToken.VALUE_STRING) {
        _reportError(""Current token ("" + _currToken + "") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"");
    }
    // To ensure that we won't see inconsistent data, better clear up state
    if (_tokenIncomplete) {
        try {
            _binaryValue = _decodeBase64(b64variant);
        } catch (IllegalArgumentException iae) {
            throw _constructError(""Failed to decode VALUE_STRING as base64 ("" + b64variant + ""): "" + iae.getMessage());
        }
        /* let's clear incomplete only now; allows for accessing other
             * textual content in error cases
             */
        _tokenIncomplete = false;
    } else {
        // may actually require conversion...
        if (_binaryValue == null) {
            @SuppressWarnings(""resource"")
            ByteArrayBuilder builder = _getByteArrayBuilder();
            _decodeBase64(getText(), builder, b64variant);
            _binaryValue = builder.toByteArray();
        }
    }
    return _binaryValue;
}","public void test107118() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, (Reader) null, (ObjectCodec) null, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.getBinaryValue((Base64Variant) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token (null) not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"@Override
public final int getTextOffset() throws IOException {
    // Most have offset of 0, only some may have other values:
    if (_currToken != null) {
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return 0;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextOffset();
            default:
        }
    }
    return 0;
}","public void test108119() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""zp7|p`M!Vu[mEF1"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.getTextOffset();
    assertEquals(0, int0);
}",""
"@Override
public final int getTextLength() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                return _parsingContext.getCurrentName().length();
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.size();
            default:
                return _currToken.asCharArray().length;
        }
    }
    return 0;
}","public void test109120() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader("") out of range of Java byte"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2, 224, false);
    int int0 = readerBasedJsonParser0.getTextLength();
    assertEquals(0, int0);
}",""
"@Override
public final char[] getTextCharacters() throws IOException {
    if (_currToken != null) {
        // null only before/after document
        switch(_currToken.id()) {
            case ID_FIELD_NAME:
                if (!_nameCopied) {
                    String name = _parsingContext.getCurrentName();
                    int nameLen = name.length();
                    if (_nameCopyBuffer == null) {
                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);
                    } else if (_nameCopyBuffer.length < nameLen) {
                        _nameCopyBuffer = new char[nameLen];
                    }
                    name.getChars(0, nameLen, _nameCopyBuffer, 0);
                    _nameCopied = true;
                }
                return _nameCopyBuffer;
            case ID_STRING:
                if (_tokenIncomplete) {
                    _tokenIncomplete = false;
                    // only strings can be incomplete
                    _finishString();
                }
            // fall through
            case ID_NUMBER_INT:
            case ID_NUMBER_FLOAT:
                return _textBuffer.getTextBuffer();
            default:
                return _currToken.asCharArray();
        }
    }
    return null;
}","public void test110121() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_TRAILING_COMMA"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1819), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-2920), 2, false);
    char[] charArray1 = readerBasedJsonParser0.getTextCharacters();
    assertNull(charArray1);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test111122() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    StringReader stringReader0 = new StringReader(""'"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[1];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-1876), (-319), true);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertEquals(""["", string0);
}",""
"protected final String _getText2(JsonToken t) {
    if (t == null) {
        return null;
    }
    switch(t.id()) {
        case ID_FIELD_NAME:
            return _parsingContext.getCurrentName();
        case ID_STRING:
        // fall through
        case ID_NUMBER_INT:
        case ID_NUMBER_FLOAT:
            return _textBuffer.contentsAsString();
        default:
            return t.asString();
    }
}","public void test112123() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    String string0 = readerBasedJsonParser0._getText2(jsonToken0);
    assertNull(string0);
}",""
"/*
    /**********************************************************
    /* Public API, data access
    /**********************************************************
     */
/**
 * Method for accessing textual representation of the current event;
 * if no current event (before first call to {@link #nextToken}, or
 * after encountering end-of-input), returns null.
 * Method can be called for any event.
 */
@Override
public final String getText() throws IOException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    return _getText2(t);
}","public void test113124() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""<yA"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getText();
    assertNull(string0);
}",""
"// // // Let's override default impls for improved performance
// @since 2.1
@Override
public final String getValueAsString() throws IOException {
    if (_currToken == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsAsString();
    }
    if (_currToken == JsonToken.FIELD_NAME) {
        return getCurrentName();
    }
    return super.getValueAsString(null);
}","public void test114125() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1522, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    String string0 = readerBasedJsonParser0.getValueAsString();
    assertNull(string0);
}",""
"// since 2.8
@Override
public int getText(Writer writer) throws IOException {
    JsonToken t = _currToken;
    if (t == JsonToken.VALUE_STRING) {
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            // only strings can be incomplete
            _finishString();
        }
        return _textBuffer.contentsToWriter(writer);
    }
    if (t == JsonToken.FIELD_NAME) {
        String n = _parsingContext.getCurrentName();
        writer.write(n);
        return n.length();
    }
    if (t != null) {
        if (t.isNumeric()) {
            return _textBuffer.contentsToWriter(writer);
        }
        char[] ch = t.asCharArray();
        writer.write(ch);
        return ch.length;
    }
    return 0;
}","public void test115126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader(""NV\"" u@;uw1LS`{,is8"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[6];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 54, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 3, 2, false);
    int int0 = readerBasedJsonParser0.getText((Writer) null);
    assertEquals(0, int0);
}",""
"@Override
public int getCurrentTokenId() {
    final JsonToken t = _currToken;
    return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();
}","public void test116127() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""4"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0.nextLongValue(33);
    readerBasedJsonParser0.getValueAsString(""VV4R{p.xC\""Vpo&"");
    assertEquals(7, readerBasedJsonParser0.getCurrentTokenId());
}",""
"/*
    /**********************************************************
    /* Public API, nextXxx() overrides
    /**********************************************************
     */
// Implemented since 2.7
@Override
public boolean nextFieldName(SerializableString sstr) throws IOException {
    // // // Note: most of code below is copied from nextToken()
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return false;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return false;
    }
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return false;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return false;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return false;
    }
    _updateNameLocation();
    if (i == INT_QUOTE) {
        // when doing literal match, must consider escaping:
        char[] nameChars = sstr.asQuotedChars();
        final int len = nameChars.length;
        // Require 4 more bytes for faster skipping of colon that follows name
        if ((_inputPtr + len + 4) < _inputEnd) {
            // maybe...
            // first check length match by
            final int end = _inputPtr + len;
            if (_inputBuffer[end] == '""') {
                int offset = 0;
                int ptr = _inputPtr;
                while (true) {
                    if (ptr == end) {
                        // yes, match!
                        _parsingContext.setCurrentName(sstr.getValue());
                        _isNextTokenNameYes(_skipColonFast(ptr + 1));
                        return true;
                    }
                    if (nameChars[offset] != _inputBuffer[ptr]) {
                        break;
                    }
                    ++offset;
                    ++ptr;
                }
            }
        }
    }
    return _isNextTokenNameMaybe(i, sstr.getValue());
}","public void test117128() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""t`S6=-9:c1"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[0];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1907), stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 2895, 2, true);
    SerializedString serializedString0 = new SerializedString(""xuy00-gV'0?p_t+Z"");
    try {
        readerBasedJsonParser0.nextFieldName((SerializableString) serializedString0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Reader returned 0 characters when trying to read 2
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"// since 2.8
@Deprecated
protected char getNextChar(String eofMsg) throws IOException {
    return getNextChar(eofMsg, null);
}","public void test118129() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 0, true);
    readerBasedJsonParser0._loadMore();
    try {
        readerBasedJsonParser0.getNextChar(""+Infinity"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input+Infinity
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"/*
    /**********************************************************
    /* Low-level access, supporting
    /**********************************************************
     */
protected void _loadMoreGuaranteed() throws IOException {
    if (!_loadMore()) {
        _reportInvalidEOF();
    }
}","public void test119130() throws Throwable {
    char[] charArray0 = new char[4];
    TextBuffer textBuffer0 = mock(TextBuffer.class, new ViolatedAssumptionAnswer());
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn(textBuffer0).when(iOContext0).constructTextBuffer();
    doReturn(false).when(iOContext0).isResourceManaged();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    StringReader stringReader0 = new StringReader("""");
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 33, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 842, (-2021), true);
    try {
        readerBasedJsonParser0._loadMoreGuaranteed();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in null
        //  at [Source: UNKNOWN; line: 1, column: -1178]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
protected final void _finishString() throws IOException {
    /* First: let's try to see if we have simple String value: one
         * that does not cross input buffer boundary, and does not
         * contain escape sequences.
         */
    int ptr = _inputPtr;
    final int inputLen = _inputEnd;
    if (ptr < inputLen) {
        final int[] codes = _icLatin1;
        final int maxCode = codes.length;
        do {
            int ch = _inputBuffer[ptr];
            if (ch < maxCode && codes[ch] != 0) {
                if (ch == '""') {
                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));
                    _inputPtr = ptr + 1;
                    // Yes, we got it all
                    return;
                }
                break;
            }
            ++ptr;
        } while (ptr < inputLen);
    }
    // Either ran out of input, or bumped into an escape sequence...
    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));
    _inputPtr = ptr;
    _finishString2();
}","public void test120131() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""t`S6=-9:c1"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 169, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    readerBasedJsonParser0._loadMoreGuaranteed();
    try {
        readerBasedJsonParser0._finishString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input: was expecting closing quote for a string value
        //  at [Source: UNKNOWN; line: 1, column: 21]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test121132() throws Throwable {
    IOContext iOContext0 = new IOContext((BufferRecycler) null, (Object) null, true);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[3];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-985), (Reader) null, objectCodec0, charsToNameCanonicalizer0, charArray0, 33, 33, false);
    readerBasedJsonParser0._releaseBuffers();
    assertFalse(readerBasedJsonParser0.isClosed());
}",""
"/*
    /**********************************************************
    /* Public API, traversal
    /**********************************************************
     */
/**
 * @return Next token from the stream, if any found, or null
 *   to indicate end-of-input
 */
@Override
public final JsonToken nextToken() throws IOException {
    /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
    if (_currToken == JsonToken.FIELD_NAME) {
        return _nextAfterName();
    }
    // But if we didn't already have a name, and (partially?) decode number,
    // need to ensure no numeric information is leaked
    _numTypesValid = NR_UNKNOWN;
    if (_tokenIncomplete) {
        // only strings can be partial
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        // end-of-input
        // Should actually close/release things
        // like input source, symbol table and recyclable buffers now.
        close();
        return (_currToken = null);
    }
    // clear any data retained so far
    _binaryValue = null;
    // Closing scope?
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return _currToken;
    }
    // Nope: do we then expect a comma?
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        // Was that a trailing comma?
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return _currToken;
            }
        }
    }
    /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
    boolean inObject = _parsingContext.inObject();
    if (inObject) {
        // First, field name itself:
        _updateNameLocation();
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
        _parsingContext.setCurrentName(name);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
    }
    _updateLocation();
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case '}':
            // Error: } is not valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    if (inObject) {
        _nextToken = t;
        return _currToken;
    }
    _currToken = t;
    return t;
}","public void test122133() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""p"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    stringReader0.skip(2);
    readerBasedJsonParser0.nextToken();
}",""
"/*
    /**********************************************************
    /* Internal methods, secondary parsing
    /**********************************************************
     */
protected final String _parseName() throws IOException {
    // First: let's try to see if we have a simple name: one that does
    // not cross input buffer boundary, and does not contain escape sequences.
    int ptr = _inputPtr;
    int hash = _hashSeed;
    final int[] codes = _icLatin1;
    while (ptr < _inputEnd) {
        int ch = _inputBuffer[ptr];
        if (ch < codes.length && codes[ch] != 0) {
            if (ch == '""') {
                int start = _inputPtr;
                // to skip the quote
                _inputPtr = ptr + 1;
                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);
            }
            break;
        }
        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
        ++ptr;
    }
    int start = _inputPtr;
    _inputPtr = ptr;
    return _parseName2(start, hash, INT_QUOTE);
}","public void test123134() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""ALLOW_SINGLE_QUOTES"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0, charArray0, 2, 0, true);
    readerBasedJsonParser0.getNextChar(""ALLOW_SINGLE_QUOTES"");
    try {
        readerBasedJsonParser0._parseName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input in field name
        //  at [Source: UNKNOWN; line: 1, column: 23]
        //
        verifyException(""com.fasterxml.jackson.core.base.ParserMinimalBase"", e);
    }
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test124135() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);
    StringReader stringReader0 = new StringReader(""' (code 0x"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1278, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);
    int int0 = readerBasedJsonParser0.releaseBuffered((Writer) null);
    assertEquals(0, int0);
}",""
"@Override
public int releaseBuffered(Writer w) throws IOException {
    int count = _inputEnd - _inputPtr;
    if (count < 1) {
        return 0;
    }
    // let's just advance ptr to end
    int origPtr = _inputPtr;
    w.write(_inputBuffer, origPtr, count);
    return count;
}","public void test125136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 2577, false);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.releaseBuffered((Writer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public low-level accessors
    /**********************************************************
     */
public long getTokenCharacterOffset() {
    return _tokenInputTotal;
}","public void test126137() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);
    StringReader stringReader0 = new StringReader(""p"");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    ObjectCodec objectCodec1 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    readerBasedJsonParser0.setCodec(objectCodec1);
    assertEquals(0L, readerBasedJsonParser0.getTokenCharacterOffset());
}",""
"@Override
public Object getInputSource() {
    return _reader;
}","public void test127138() throws Throwable {
    IOContext iOContext0 = mock(IOContext.class, new ViolatedAssumptionAnswer());
    doReturn((TextBuffer) null).when(iOContext0).constructTextBuffer();
    StringReader stringReader0 = new StringReader("""");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[8];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, 0, 46, true);
    Object object0 = readerBasedJsonParser0.getInputSource();
    assertSame(stringReader0, object0);
}",""
"@Override
public String nextFieldName() throws IOException {
    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)
    _numTypesValid = NR_UNKNOWN;
    if (_currToken == JsonToken.FIELD_NAME) {
        _nextAfterName();
        return null;
    }
    if (_tokenIncomplete) {
        _skipString();
    }
    int i = _skipWSOrEnd();
    if (i < 0) {
        close();
        _currToken = null;
        return null;
    }
    _binaryValue = null;
    if (i == INT_RBRACKET || i == INT_RCURLY) {
        _closeScope(i);
        return null;
    }
    if (_parsingContext.expectComma()) {
        i = _skipComma(i);
        if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {
            if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {
                _closeScope(i);
                return null;
            }
        }
    }
    if (!_parsingContext.inObject()) {
        _updateLocation();
        _nextTokenNotInObject(i);
        return null;
    }
    _updateNameLocation();
    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
    _parsingContext.setCurrentName(name);
    _currToken = JsonToken.FIELD_NAME;
    i = _skipColon();
    _updateLocation();
    if (i == INT_QUOTE) {
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        return name;
    }
    // Ok: we must have a value... what is it?
    JsonToken t;
    switch(i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
    }
    _nextToken = t;
    return name;
}","public void test128139() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    StringReader stringReader0 = new StringReader(""I`RBJA"");
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, false);
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 0, stringReader0, objectCodec0, charsToNameCanonicalizer0);
    try {
        readerBasedJsonParser0.nextFieldName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'I': was expecting 'null', 'true', 'false' or NaN
        //  at [Source: UNKNOWN; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"// since 2.8
@Deprecated
protected char getNextChar(String eofMsg) throws IOException {
    return getNextChar(eofMsg, null);
}","public void test129140() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, (Object) null, true);
    StringReader stringReader0 = new StringReader(""Numeric value ("");
    ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[7];
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 92, stringReader0, objectCodec0, charsToNameCanonicalizer0, charArray0, (-863), 2, true);
    // Undeclared exception!
    try {
        readerBasedJsonParser0.getNextChar(""c:$]:,sV"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -863
        //
        verifyException(""com.fasterxml.jackson.core.json.ReaderBasedJsonParser"", e);
    }
}",""
