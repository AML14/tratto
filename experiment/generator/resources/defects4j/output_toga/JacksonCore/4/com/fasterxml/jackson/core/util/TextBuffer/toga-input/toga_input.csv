focal_method,test_prefix,docstring
"public char[] expandCurrentSegment(int minSize) {
    char[] curr = _currentSegment;
    if (curr.length >= minSize)
        return curr;
    _currentSegment = curr = Arrays.copyOf(curr, minSize);
    return curr;
}","public void test000() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment(1000);
    assertSame(charArray1, charArray0);
}","/**
 * Method called to expand size of the current segment, to
 * accommodate for more contiguous content. Usually only
 * used when parsing tokens like names if even then.
 *
 * @param minSize Required minimum strength of the current segment
 *
 * @since 2.4.0
 */"
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test002() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment(1000);
    assertEquals(0, textBuffer0.getCurrentSegmentSize());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test013() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.setCurrentLength(1500);
    textBuffer0.expandCurrentSegment();
    textBuffer0.append(""com.fasterxml.jackson.core.util.TextBuffer"", 1, 1);
    assertEquals(1701, textBuffer0.size());
}",""
"public void append(String str, int offset, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        str.getChars(offset, offset + len, curr, _currentSize);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        str.getChars(offset, offset + max, curr, _currentSize);
        len -= max;
        offset += max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        str.getChars(offset, offset + amount, _currentSegment, 0);
        _currentSize += amount;
        offset += amount;
        len -= amount;
    } while (len > 0);
}","public void test024() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.append(""H"", (-314), 985);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public void append(String str, int offset, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        str.getChars(offset, offset + len, curr, _currentSize);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        str.getChars(offset, offset + max, curr, _currentSize);
        len -= max;
        offset += max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        str.getChars(offset, offset + amount, _currentSegment, 0);
        _currentSize += amount;
        offset += amount;
        len -= amount;
    } while (len > 0);
}","public void test035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(2000, 2000);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.contentsAsArray();
    textBuffer0.resetWithShared(charArray0, 1283, 3);
    // Undeclared exception!
    try {
        textBuffer0.append("""", 2, 1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public void append(char[] c, int start, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        System.arraycopy(c, start, curr, _currentSize, len);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        System.arraycopy(c, start, curr, _currentSize, max);
        start += max;
        len -= max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        System.arraycopy(c, start, _currentSegment, 0, amount);
        _currentSize += amount;
        start += amount;
        len -= amount;
    } while (len > 0);
}","public void test046() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.setCurrentLength(200);
    // Undeclared exception!
    try {
        textBuffer0.append(charArray0, 0, 1542);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public void append(char[] c, int start, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        System.arraycopy(c, start, curr, _currentSize, len);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        System.arraycopy(c, start, curr, _currentSize, max);
        start += max;
        len -= max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        System.arraycopy(c, start, _currentSegment, 0, amount);
        _currentSize += amount;
        start += amount;
        len -= amount;
    } while (len > 0);
}","public void test057() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4000, 4000);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 2201, (-788));
    // Undeclared exception!
    try {
        textBuffer0.append(charArray0, 1, 5846);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test068() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[6];
    textBuffer0.resetWithShared(charArray0, 2, 2);
    textBuffer0.append('k');
    assertEquals(3, textBuffer0.size());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test079() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 2, (-1539));
    textBuffer0.ensureNotShared();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Other accessors:
    /**********************************************************
     */
public String contentsAsString() {
    if (_resultString == null) {
        // Has array been requested? Can make a shortcut, if so:
        if (_resultArray != null) {
            _resultString = new String(_resultArray);
        } else {
            // Do we use shared array?
            if (_inputStart >= 0) {
                if (_inputLen < 1) {
                    return (_resultString = """");
                }
                _resultString = new String(_inputBuffer, _inputStart, _inputLen);
            } else {
                // nope... need to copy
                // But first, let's see if we have just one buffer
                int segLen = _segmentSize;
                int currLen = _currentSize;
                if (segLen == 0) {
                    // yup
                    _resultString = (currLen == 0) ? """" : new String(_currentSegment, 0, currLen);
                } else {
                    // no, need to combine
                    StringBuilder sb = new StringBuilder(segLen + currLen);
                    // First stored segments
                    if (_segments != null) {
                        for (int i = 0, len = _segments.size(); i < len; ++i) {
                            char[] curr = _segments.get(i);
                            sb.append(curr, 0, curr.length);
                        }
                    }
                    // And finally, current segment:
                    sb.append(_currentSegment, 0, _currentSize);
                    _resultString = sb.toString();
                }
            }
        }
    }
    return _resultString;
}","public void test0810() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = textBuffer0.contentsAsArray();
    textBuffer0.resetWithShared(charArray0, 200, (-270));
    textBuffer0.getCurrentSegment();
    // Undeclared exception!
    try {
        textBuffer0.contentsAsString();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test0911() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = new char[5];
    textBuffer0.resetWithShared(charArray0, 1532, 4000);
    textBuffer0.getTextBuffer();
    assertEquals(1532, textBuffer0.getTextOffset());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test1012() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4000, 4000);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 2201, (-788));
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertEquals(2201, textBuffer0.getTextOffset());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test1013() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4000, 4000);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 2201, (-788));
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertTrue(boolean0);
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test1114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    char[] charArray0 = textBuffer0.expandCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 262144, (-501));
    int int0 = textBuffer0.size();
    assertEquals((-501), int0);
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test1215() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 3, 1301);
    int int0 = textBuffer0.getTextOffset();
    assertEquals(3, int0);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test1316() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append(""km1b7"", 1, 3);
    int int0 = textBuffer0.getCurrentSegmentSize();
    assertEquals(3, textBuffer0.size());
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test1317() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append(""km1b7"", 1, 3);
    int int0 = textBuffer0.getCurrentSegmentSize();
    assertEquals(3, int0);
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test1418() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.setCurrentLength((-3592));
    int int0 = textBuffer0.getCurrentSegmentSize();
    assertEquals((-3592), int0);
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test1519() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append('9');
    assertEquals(1, textBuffer0.getCurrentSegmentSize());
}",""
"public void resetWithCopy(char[] buf, int start, int len) {
    _inputBuffer = null;
    // indicates shared buffer not used
    _inputStart = -1;
    _inputLen = 0;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    } else if (_currentSegment == null) {
        _currentSegment = buf(len);
    }
    _currentSize = _segmentSize = 0;
    append(buf, start, len);
}","public void test1621() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.resetWithCopy((char[]) null, (-3747), 999);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"public void resetWithCopy(char[] buf, int start, int len) {
    _inputBuffer = null;
    // indicates shared buffer not used
    _inputStart = -1;
    _inputLen = 0;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    } else if (_currentSegment == null) {
        _currentSegment = buf(len);
    }
    _currentSize = _segmentSize = 0;
    append(buf, start, len);
}","public void test1722() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = new char[7];
    // Undeclared exception!
    try {
        textBuffer0.resetWithCopy(charArray0, 2474, 2);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public char[] getTextBuffer() {
    // Are we just using shared input buffer?
    if (_inputStart >= 0)
        return _inputBuffer;
    if (_resultArray != null)
        return _resultArray;
    if (_resultString != null) {
        return (_resultArray = _resultString.toCharArray());
    }
    // Nope; but does it fit in just one segment?
    if (!_hasSegments)
        return _currentSegment;
    // Nope, need to have/create a non-segmented array and return it
    return contentsAsArray();
}","public void test1823() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.setCurrentLength(1500);
    // Undeclared exception!
    try {
        textBuffer0.getTextBuffer();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public char[] finishCurrentSegment() {
    if (_segments == null) {
        _segments = new ArrayList<char[]>();
    }
    _hasSegments = true;
    _segments.add(_currentSegment);
    int oldLen = _currentSegment.length;
    _segmentSize += oldLen;
    _currentSize = 0;
    // Let's grow segments by 50%
    int newLen = oldLen + (oldLen >> 1);
    if (newLen < MIN_SEGMENT_LEN) {
        newLen = MIN_SEGMENT_LEN;
    } else if (newLen > MAX_SEGMENT_LEN) {
        newLen = MAX_SEGMENT_LEN;
    }
    char[] curr = carr(newLen);
    _currentSegment = curr;
    return curr;
}","public void test1924() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.finishCurrentSegment();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.TextBuffer"", e);
    }
}",""
"public char[] expandCurrentSegment(int minSize) {
    char[] curr = _currentSegment;
    if (curr.length >= minSize)
        return curr;
    _currentSegment = curr = Arrays.copyOf(curr, minSize);
    return curr;
}","public void test2025() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.expandCurrentSegment(3);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.TextBuffer"", e);
    }
}","/**
 * Method called to expand size of the current segment, to
 * accommodate for more contiguous content. Usually only
 * used when parsing tokens like names if even then.
 *
 * @param minSize Required minimum strength of the current segment
 *
 * @since 2.4.0
 */"
"public char[] expandCurrentSegment() {
    final char[] curr = _currentSegment;
    // Let's grow by 50% by default
    final int len = curr.length;
    // but above intended maximum, slow to increase by 25%
    int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));
    return (_currentSegment = Arrays.copyOf(curr, newLen));
}","public void test2126() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.expandCurrentSegment();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.TextBuffer"", e);
    }
}","/**
 * Method called to expand size of the current segment, to
 * accommodate for more contiguous content. Usually only
 * used when parsing tokens like names if even then.
 */"
"/*
    /**********************************************************
    /* Public mutators:
    /**********************************************************
     */
/**
 * Method called to make sure that buffer is not using shared input
 * buffer; if it is, it will copy such contents to private buffer.
 */
public void ensureNotShared() {
    if (_inputStart >= 0) {
        unshare(16);
    }
}","public void test2227() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(0, 0);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.ensureNotShared();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.util.BufferRecycler"", e);
    }
}",""
"public char[] emptyAndGetCurrentSegment() {
    // inlined 'resetWithEmpty()'
    // indicates shared buffer not used
    _inputStart = -1;
    _currentSize = 0;
    _inputLen = 0;
    _inputBuffer = null;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    }
    char[] curr = _currentSegment;
    if (curr == null) {
        _currentSegment = curr = buf(0);
    }
    return curr;
}","public void test2328() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(0, 0);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.emptyAndGetCurrentSegment();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.util.BufferRecycler"", e);
    }
}",""
"/*
    /**********************************************************
    /* Other accessors:
    /**********************************************************
     */
public String contentsAsString() {
    if (_resultString == null) {
        // Has array been requested? Can make a shortcut, if so:
        if (_resultArray != null) {
            _resultString = new String(_resultArray);
        } else {
            // Do we use shared array?
            if (_inputStart >= 0) {
                if (_inputLen < 1) {
                    return (_resultString = """");
                }
                _resultString = new String(_inputBuffer, _inputStart, _inputLen);
            } else {
                // nope... need to copy
                // But first, let's see if we have just one buffer
                int segLen = _segmentSize;
                int currLen = _currentSize;
                if (segLen == 0) {
                    // yup
                    _resultString = (currLen == 0) ? """" : new String(_currentSegment, 0, currLen);
                } else {
                    // no, need to combine
                    StringBuilder sb = new StringBuilder(segLen + currLen);
                    // First stored segments
                    if (_segments != null) {
                        for (int i = 0, len = _segments.size(); i < len; ++i) {
                            char[] curr = _segments.get(i);
                            sb.append(curr, 0, curr.length);
                        }
                    }
                    // And finally, current segment:
                    sb.append(_currentSegment, 0, _currentSize);
                    _resultString = sb.toString();
                }
            }
        }
    }
    return _resultString;
}","public void test2429() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.resetWithEmpty();
    textBuffer0.setCurrentLength(3);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public double contentsAsDouble() throws NumberFormatException {
    return NumberInput.parseDouble(contentsAsString());
}","public void test2530() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.setCurrentLength(1500);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsDouble();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a Double value.
 */"
"public char[] contentsAsArray() {
    char[] result = _resultArray;
    if (result == null) {
        _resultArray = result = resultArray();
    }
    return result;
}","public void test2631() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.resetWithShared((char[]) null, 6, 1301);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsArray();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public char[] contentsAsArray() {
    char[] result = _resultArray;
    if (result == null) {
        _resultArray = result = resultArray();
    }
    return result;
}","public void test2732() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[1];
    textBuffer0.resetWithShared(charArray0, 43, 1001);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsArray();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Arrays"", e);
    }
}",""
"public void append(char[] c, int start, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        System.arraycopy(c, start, curr, _currentSize, len);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        System.arraycopy(c, start, curr, _currentSize, max);
        start += max;
        len -= max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        System.arraycopy(c, start, _currentSegment, 0, amount);
        _currentSize += amount;
        start += amount;
        len -= amount;
    } while (len > 0);
}","public void test2833() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(0, 949);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.append((char[]) null, 0, 3714);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"public void append(String str, int offset, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        str.getChars(offset, offset + len, curr, _currentSize);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        str.getChars(offset, offset + max, curr, _currentSize);
        len -= max;
        offset += max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        str.getChars(offset, offset + amount, _currentSegment, 0);
        _currentSize += amount;
        offset += amount;
        len -= amount;
    } while (len > 0);
}","public void test2934() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.append((String) null, 1, 2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.TextBuffer"", e);
    }
}",""
"public void append(char c) {
    // Using shared buffer so far?
    if (_inputStart >= 0) {
        unshare(16);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    if (_currentSize >= curr.length) {
        expand(1);
        curr = _currentSegment;
    }
    curr[_currentSize++] = c;
}","public void test3035() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.releaseBuffers();
    // Undeclared exception!
    try {
        textBuffer0.append('t');
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.util.TextBuffer"", e);
    }
}",""
"public void append(char c) {
    // Using shared buffer so far?
    if (_inputStart >= 0) {
        unshare(16);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    if (_currentSize >= curr.length) {
        expand(1);
        curr = _currentSegment;
    }
    curr[_currentSize++] = c;
}","public void test3136() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(2923, 0);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    // Undeclared exception!
    try {
        textBuffer0.append('q');
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""com.fasterxml.jackson.core.util.BufferRecycler"", e);
    }
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test3237() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append('#');
    textBuffer0.contentsAsString();
    assertFalse(textBuffer0.hasTextAsCharacters());
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"/*
    /**********************************************************
    /* Other accessors:
    /**********************************************************
     */
public String contentsAsString() {
    if (_resultString == null) {
        // Has array been requested? Can make a shortcut, if so:
        if (_resultArray != null) {
            _resultString = new String(_resultArray);
        } else {
            // Do we use shared array?
            if (_inputStart >= 0) {
                if (_inputLen < 1) {
                    return (_resultString = """");
                }
                _resultString = new String(_inputBuffer, _inputStart, _inputLen);
            } else {
                // nope... need to copy
                // But first, let's see if we have just one buffer
                int segLen = _segmentSize;
                int currLen = _currentSize;
                if (segLen == 0) {
                    // yup
                    _resultString = (currLen == 0) ? """" : new String(_currentSegment, 0, currLen);
                } else {
                    // no, need to combine
                    StringBuilder sb = new StringBuilder(segLen + currLen);
                    // First stored segments
                    if (_segments != null) {
                        for (int i = 0, len = _segments.size(); i < len; ++i) {
                            char[] curr = _segments.get(i);
                            sb.append(curr, 0, curr.length);
                        }
                    }
                    // And finally, current segment:
                    sb.append(_currentSegment, 0, _currentSize);
                    _resultString = sb.toString();
                }
            }
        }
    }
    return _resultString;
}","public void test3338() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[1];
    textBuffer0.resetWithShared(charArray0, 43, 1001);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsString();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"/*
    /**********************************************************
    /* Other accessors:
    /**********************************************************
     */
public String contentsAsString() {
    if (_resultString == null) {
        // Has array been requested? Can make a shortcut, if so:
        if (_resultArray != null) {
            _resultString = new String(_resultArray);
        } else {
            // Do we use shared array?
            if (_inputStart >= 0) {
                if (_inputLen < 1) {
                    return (_resultString = """");
                }
                _resultString = new String(_inputBuffer, _inputStart, _inputLen);
            } else {
                // nope... need to copy
                // But first, let's see if we have just one buffer
                int segLen = _segmentSize;
                int currLen = _currentSize;
                if (segLen == 0) {
                    // yup
                    _resultString = (currLen == 0) ? """" : new String(_currentSegment, 0, currLen);
                } else {
                    // no, need to combine
                    StringBuilder sb = new StringBuilder(segLen + currLen);
                    // First stored segments
                    if (_segments != null) {
                        for (int i = 0, len = _segments.size(); i < len; ++i) {
                            char[] curr = _segments.get(i);
                            sb.append(curr, 0, curr.length);
                        }
                    }
                    // And finally, current segment:
                    sb.append(_currentSegment, 0, _currentSize);
                    _resultString = sb.toString();
                }
            }
        }
    }
    return _resultString;
}","public void test3439() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.contentsAsString();
    String string0 = textBuffer0.contentsAsString();
    assertEquals("""", string0);
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test3540() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 1, 1301);
    textBuffer0.contentsAsArray();
    assertEquals(1, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test3641() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 0, 2);
    textBuffer0.contentsAsArray();
    assertEquals(2, textBuffer0.size());
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test3742() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.setCurrentLength(1500);
    textBuffer0.append(""com.fasterxml.jackson.core.util.TextBuffer"", 1, 1);
    assertEquals(1, textBuffer0.getCurrentSegmentSize());
}",""
"/*
    /**********************************************************
    /* Raw access, for high-performance use:
    /**********************************************************
     */
public char[] getCurrentSegment() {
    /* Since the intention of the caller is to directly add stuff into
         * buffers, we should NOT have anything in shared buffer... ie. may
         * need to unshare contents.
         */
    if (_inputStart >= 0) {
        unshare(1);
    } else {
        char[] curr = _currentSegment;
        if (curr == null) {
            _currentSegment = buf(0);
        } else if (_currentSize >= curr.length) {
            // Plus, we better have room for at least one more char
            expand(1);
        }
    }
    return _currentSegment;
}","public void test3843() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 3, 1301);
    // Undeclared exception!
    try {
        textBuffer0.getCurrentSegment();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public char[] expandCurrentSegment(int minSize) {
    char[] curr = _currentSegment;
    if (curr.length >= minSize)
        return curr;
    _currentSegment = curr = Arrays.copyOf(curr, minSize);
    return curr;
}","public void test3944() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment((int) '6');
    assertEquals(200, charArray1.length);
}","/**
 * Method called to expand size of the current segment, to
 * accommodate for more contiguous content. Usually only
 * used when parsing tokens like names if even then.
 *
 * @param minSize Required minimum strength of the current segment
 *
 * @since 2.4.0
 */"
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test3946() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment((int) '6');
    assertEquals(0, textBuffer0.size());
}",""
"public char[] emptyAndGetCurrentSegment() {
    // inlined 'resetWithEmpty()'
    // indicates shared buffer not used
    _inputStart = -1;
    _currentSize = 0;
    _inputLen = 0;
    _inputBuffer = null;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    }
    char[] curr = _currentSegment;
    if (curr == null) {
        _currentSegment = curr = buf(0);
    }
    return curr;
}","public void test4047() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    assertEquals(200, charArray0.length);
}",""
"public char[] expandCurrentSegment(int minSize) {
    char[] curr = _currentSegment;
    if (curr.length >= minSize)
        return curr;
    _currentSegment = curr = Arrays.copyOf(curr, minSize);
    return curr;
}","public void test4048() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment(3302);
    assertEquals(3302, charArray1.length);
}","/**
 * Method called to expand size of the current segment, to
 * accommodate for more contiguous content. Usually only
 * used when parsing tokens like names if even then.
 *
 * @param minSize Required minimum strength of the current segment
 *
 * @since 2.4.0
 */"
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test4049() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment(3302);
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test4050() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3302, 3302);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    char[] charArray1 = textBuffer0.expandCurrentSegment(3302);
    assertEquals(0, textBuffer0.size());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test4151() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.finishCurrentSegment();
    assertEquals(2500, textBuffer0.size());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test4252() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[7];
    textBuffer0.resetWithCopy(charArray0, 1, 1);
    textBuffer0.setCurrentLength(1023);
    textBuffer0.getCurrentSegment();
    assertEquals(1000, textBuffer0.size());
}",""
"/*
    /**********************************************************
    /* Raw access, for high-performance use:
    /**********************************************************
     */
public char[] getCurrentSegment() {
    /* Since the intention of the caller is to directly add stuff into
         * buffers, we should NOT have anything in shared buffer... ie. may
         * need to unshare contents.
         */
    if (_inputStart >= 0) {
        unshare(1);
    } else {
        char[] curr = _currentSegment;
        if (curr == null) {
            _currentSegment = buf(0);
        } else if (_currentSize >= curr.length) {
            // Plus, we better have room for at least one more char
            expand(1);
        }
    }
    return _currentSegment;
}","public void test4353() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.getCurrentSegment();
    char[] charArray0 = textBuffer0.getCurrentSegment();
    assertEquals(1000, charArray0.length);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test4354() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.getCurrentSegment();
    char[] charArray0 = textBuffer0.getCurrentSegment();
    assertEquals(0, textBuffer0.size());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test4455() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.resetWithEmpty();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Raw access, for high-performance use:
    /**********************************************************
     */
public char[] getCurrentSegment() {
    /* Since the intention of the caller is to directly add stuff into
         * buffers, we should NOT have anything in shared buffer... ie. may
         * need to unshare contents.
         */
    if (_inputStart >= 0) {
        unshare(1);
    } else {
        char[] curr = _currentSegment;
        if (curr == null) {
            _currentSegment = buf(0);
        } else if (_currentSize >= curr.length) {
            // Plus, we better have room for at least one more char
            expand(1);
        }
    }
    return _currentSegment;
}","public void test4456() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.resetWithEmpty();
    char[] charArray0 = textBuffer0.getCurrentSegment();
    assertEquals(1000, charArray0.length);
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test4457() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.resetWithEmpty();
    char[] charArray0 = textBuffer0.getCurrentSegment();
    assertEquals(0, textBuffer0.getCurrentSegmentSize());
}",""
"public void append(String str, int offset, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        str.getChars(offset, offset + len, curr, _currentSize);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        str.getChars(offset, offset + max, curr, _currentSize);
        len -= max;
        offset += max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        str.getChars(offset, offset + amount, _currentSegment, 0);
        _currentSize += amount;
        offset += amount;
        len -= amount;
    } while (len > 0);
}","public void test4558() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3335, 3335);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    // Undeclared exception!
    try {
        textBuffer0.append(""com.fasterxml.jackson.core.util.TextBuffer"", 1442, 1442);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public void append(char[] c, int start, int len) {
    // Can't append to shared buf (sanity check)
    if (_inputStart >= 0) {
        unshare(len);
    }
    _resultString = null;
    _resultArray = null;
    // Room in current segment?
    char[] curr = _currentSegment;
    int max = curr.length - _currentSize;
    if (max >= len) {
        System.arraycopy(c, start, curr, _currentSize, len);
        _currentSize += len;
        return;
    }
    // No room for all, need to copy part(s):
    if (max > 0) {
        System.arraycopy(c, start, curr, _currentSize, max);
        start += max;
        len -= max;
    }
    /* And then allocate new segment; we are guaranteed to now
         * have enough room in segment.
         */
    // Except, as per [Issue-24], not for HUGE appends... so:
    do {
        expand(len);
        int amount = Math.min(_currentSegment.length, len);
        System.arraycopy(c, start, _currentSegment, 0, amount);
        _currentSize += amount;
        start += amount;
        len -= amount;
    } while (len > 0);
}","public void test4659() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    // Undeclared exception!
    try {
        textBuffer0.append(charArray0, 0, 1542);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"/*
    /**********************************************************
    /* Standard methods:
    /**********************************************************
     */
/**
 * Note: calling this method may not be as efficient as calling
 * {@link #contentsAsString}, since it's not guaranteed that resulting
 * String is cached.
 */
@Override
public String toString() {
    return contentsAsString();
}","public void test4760() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = new char[7];
    textBuffer0.append(charArray0, 2, 3);
    textBuffer0.setCurrentLength(1051);
    // Undeclared exception!
    try {
        textBuffer0.toString();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test4861() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[7];
    textBuffer0.resetWithCopy(charArray0, 1, 1);
    textBuffer0.setCurrentLength(1021);
    textBuffer0.append('\u0000');
    assertEquals(1, textBuffer0.getCurrentSegmentSize());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test4963() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.resetWithEmpty();
    textBuffer0.ensureNotShared();
    assertEquals(0, textBuffer0.size());
}",""
"public BigDecimal contentsAsDecimal() throws NumberFormatException {
    // Already got a pre-cut array?
    if (_resultArray != null) {
        return NumberInput.parseBigDecimal(_resultArray);
    }
    // Or a shared buffer?
    if ((_inputStart >= 0) && (_inputBuffer != null)) {
        return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
    }
    // Or if not, just a single buffer (the usual case)
    if ((_segmentSize == 0) && (_currentSegment != null)) {
        return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
    }
    // If not, let's just get it aggregated...
    return NumberInput.parseBigDecimal(contentsAsArray());
}","public void test5064() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    try {
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // Value \""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"" can not be represented as BigDecimal
        //
        verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a {@link BigDecimal}.
 */"
"public BigDecimal contentsAsDecimal() throws NumberFormatException {
    // Already got a pre-cut array?
    if (_resultArray != null) {
        return NumberInput.parseBigDecimal(_resultArray);
    }
    // Or a shared buffer?
    if ((_inputStart >= 0) && (_inputBuffer != null)) {
        return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
    }
    // Or if not, just a single buffer (the usual case)
    if ((_segmentSize == 0) && (_currentSegment != null)) {
        return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
    }
    // If not, let's just get it aggregated...
    return NumberInput.parseBigDecimal(contentsAsArray());
}","public void test5165() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 5226, 0);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a {@link BigDecimal}.
 */"
"public BigDecimal contentsAsDecimal() throws NumberFormatException {
    // Already got a pre-cut array?
    if (_resultArray != null) {
        return NumberInput.parseBigDecimal(_resultArray);
    }
    // Or a shared buffer?
    if ((_inputStart >= 0) && (_inputBuffer != null)) {
        return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
    }
    // Or if not, just a single buffer (the usual case)
    if ((_segmentSize == 0) && (_currentSegment != null)) {
        return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
    }
    // If not, let's just get it aggregated...
    return NumberInput.parseBigDecimal(contentsAsArray());
}","public void test5266() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.resetWithEmpty();
    textBuffer0.toString();
    textBuffer0.getTextBuffer();
    try {
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // Value \""\"" can not be represented as BigDecimal
        //
        verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a {@link BigDecimal}.
 */"
"public BigDecimal contentsAsDecimal() throws NumberFormatException {
    // Already got a pre-cut array?
    if (_resultArray != null) {
        return NumberInput.parseBigDecimal(_resultArray);
    }
    // Or a shared buffer?
    if ((_inputStart >= 0) && (_inputBuffer != null)) {
        return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
    }
    // Or if not, just a single buffer (the usual case)
    if ((_segmentSize == 0) && (_currentSegment != null)) {
        return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
    }
    // If not, let's just get it aggregated...
    return NumberInput.parseBigDecimal(contentsAsArray());
}","public void test5367() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    try {
        textBuffer0.contentsAsDecimal();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // Value \""\"" can not be represented as BigDecimal
        //
        verifyException(""com.fasterxml.jackson.core.io.NumberInput"", e);
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a {@link BigDecimal}.
 */"
"public char[] contentsAsArray() {
    char[] result = _resultArray;
    if (result == null) {
        _resultArray = result = resultArray();
    }
    return result;
}","public void test5468() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.contentsAsArray();
    char[] charArray0 = textBuffer0.contentsAsArray();
    assertArrayEquals(new char[] {}, charArray0);
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test5569() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.contentsAsString();
    assertFalse(textBuffer0.hasTextAsCharacters());
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"public double contentsAsDouble() throws NumberFormatException {
    return NumberInput.parseDouble(contentsAsString());
}","public void test5670() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    char[] charArray0 = textBuffer0.expandCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 262144, 43);
    // Undeclared exception!
    try {
        textBuffer0.contentsAsDouble();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a Double value.
 */"
"/*
    /**********************************************************
    /* Other accessors:
    /**********************************************************
     */
public String contentsAsString() {
    if (_resultString == null) {
        // Has array been requested? Can make a shortcut, if so:
        if (_resultArray != null) {
            _resultString = new String(_resultArray);
        } else {
            // Do we use shared array?
            if (_inputStart >= 0) {
                if (_inputLen < 1) {
                    return (_resultString = """");
                }
                _resultString = new String(_inputBuffer, _inputStart, _inputLen);
            } else {
                // nope... need to copy
                // But first, let's see if we have just one buffer
                int segLen = _segmentSize;
                int currLen = _currentSize;
                if (segLen == 0) {
                    // yup
                    _resultString = (currLen == 0) ? """" : new String(_currentSegment, 0, currLen);
                } else {
                    // no, need to combine
                    StringBuilder sb = new StringBuilder(segLen + currLen);
                    // First stored segments
                    if (_segments != null) {
                        for (int i = 0, len = _segments.size(); i < len; ++i) {
                            char[] curr = _segments.get(i);
                            sb.append(curr, 0, curr.length);
                        }
                    }
                    // And finally, current segment:
                    sb.append(_currentSegment, 0, _currentSize);
                    _resultString = sb.toString();
                }
            }
        }
    }
    return _resultString;
}","public void test5771() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.contentsAsArray();
    String string0 = textBuffer0.contentsAsString();
    assertEquals("""", string0);
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test5872() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append('6');
    textBuffer0.contentsAsDouble();
    textBuffer0.toString();
    assertEquals(1, textBuffer0.getCurrentSegmentSize());
}",""
"public char[] getTextBuffer() {
    // Are we just using shared input buffer?
    if (_inputStart >= 0)
        return _inputBuffer;
    if (_resultArray != null)
        return _resultArray;
    if (_resultString != null) {
        return (_resultArray = _resultString.toCharArray());
    }
    // Nope; but does it fit in just one segment?
    if (!_hasSegments)
        return _currentSegment;
    // Nope, need to have/create a non-segmented array and return it
    return contentsAsArray();
}","public void test5973() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(654, 654);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.getTextBuffer();
    assertSame(charArray1, charArray0);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test5974() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(654, 654);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.getTextBuffer();
    assertEquals(0, textBuffer0.size());
}",""
"/*
    /**********************************************************
    /* Raw access, for high-performance use:
    /**********************************************************
     */
public char[] getCurrentSegment() {
    /* Since the intention of the caller is to directly add stuff into
         * buffers, we should NOT have anything in shared buffer... ie. may
         * need to unshare contents.
         */
    if (_inputStart >= 0) {
        unshare(1);
    } else {
        char[] curr = _currentSegment;
        if (curr == null) {
            _currentSegment = buf(0);
        } else if (_currentSize >= curr.length) {
            // Plus, we better have room for at least one more char
            expand(1);
        }
    }
    return _currentSegment;
}","public void test6077() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    assertEquals(200, charArray0.length);
}",""
"public char[] getTextBuffer() {
    // Are we just using shared input buffer?
    if (_inputStart >= 0)
        return _inputBuffer;
    if (_resultArray != null)
        return _resultArray;
    if (_resultString != null) {
        return (_resultArray = _resultString.toCharArray());
    }
    // Nope; but does it fit in just one segment?
    if (!_hasSegments)
        return _currentSegment;
    // Nope, need to have/create a non-segmented array and return it
    return contentsAsArray();
}","public void test6078() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.contentsAsArray();
    char[] charArray1 = textBuffer0.getTextBuffer();
    assertEquals(0, charArray1.length);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test6080() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.contentsAsArray();
    char[] charArray1 = textBuffer0.getTextBuffer();
    assertEquals(0, textBuffer0.size());
}",""
"public char[] getTextBuffer() {
    // Are we just using shared input buffer?
    if (_inputStart >= 0)
        return _inputBuffer;
    if (_resultArray != null)
        return _resultArray;
    if (_resultString != null) {
        return (_resultArray = _resultString.toCharArray());
    }
    // Nope; but does it fit in just one segment?
    if (!_hasSegments)
        return _currentSegment;
    // Nope, need to have/create a non-segmented array and return it
    return contentsAsArray();
}","public void test6181() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getTextBuffer();
    assertNull(charArray0);
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6282() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(654, 654);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.resetWithString("""");
    assertFalse(textBuffer0.hasTextAsCharacters());
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test6283() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(654, 654);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.resetWithString("""");
    textBuffer0.getTextBuffer();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6384() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(654, 654);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.resetWithString("""");
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertFalse(boolean0);
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"public char[] contentsAsArray() {
    char[] result = _resultArray;
    if (result == null) {
        _resultArray = result = resultArray();
    }
    return result;
}","public void test6486() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.contentsAsArray();
    assertNotNull(charArray1);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test6487() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.contentsAsArray();
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertEquals(0, textBuffer0.size());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6488() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    char[] charArray1 = textBuffer0.contentsAsArray();
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertTrue(boolean0);
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"public char[] emptyAndGetCurrentSegment() {
    // inlined 'resetWithEmpty()'
    // indicates shared buffer not used
    _inputStart = -1;
    _currentSize = 0;
    _inputLen = 0;
    _inputBuffer = null;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    }
    char[] curr = _currentSegment;
    if (curr == null) {
        _currentSegment = curr = buf(0);
    }
    return curr;
}","public void test6589() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    assertEquals(200, charArray0.length);
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test6590() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6591() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertTrue(boolean0);
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test6592() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.emptyAndGetCurrentSegment();
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertEquals(0, textBuffer0.size());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6693() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    boolean boolean0 = textBuffer0.hasTextAsCharacters();
    assertTrue(boolean0);
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test6794() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    int int0 = textBuffer0.getTextOffset();
    assertEquals(0, int0);
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test6896() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    int int0 = textBuffer0.getTextOffset();
    assertEquals(0, int0);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test6897() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    int int0 = textBuffer0.getTextOffset();
    assertEquals(0, textBuffer0.size());
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test6998() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.contentsAsString();
    int int0 = textBuffer0.size();
    assertFalse(textBuffer0.hasTextAsCharacters());
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test6999() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.getCurrentSegment();
    textBuffer0.contentsAsString();
    int int0 = textBuffer0.size();
    assertEquals(0, int0);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test70100() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.append('\\');
    textBuffer0.contentsAsArray();
    int int0 = textBuffer0.size();
    assertEquals(1, int0);
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test71101() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    int int0 = textBuffer0.size();
    assertEquals(0, int0);
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test72103() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    int int0 = textBuffer0.size();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test72104() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    int int0 = textBuffer0.size();
    assertEquals(0, int0);
}",""
"public boolean hasTextAsCharacters() {
    // if we have array in some form, sure
    if (_inputStart >= 0 || _resultArray != null)
        return true;
    // not if we have String as value
    if (_resultString != null)
        return false;
    return true;
}","public void test73105() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.resetWithString(""3mZ!-QI }(rk"");
    assertFalse(textBuffer0.hasTextAsCharacters());
}","/**
 * Method that can be used to check whether textual contents can
 * be efficiently accessed using {@link #getTextBuffer}.
 */"
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test74106() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.resetWithCopy(charArray0, 0, 3);
    assertEquals(3, textBuffer0.size());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test75107() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(4, 4);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.resetWithCopy(charArray0, 0, 3);
    assertEquals(3, textBuffer0.size());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test76108() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = textBuffer0.getCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.resetWithShared(charArray0, 5226, 0);
    assertEquals(5226, textBuffer0.getTextOffset());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test77109() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3, 3);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    assertEquals(200, textBuffer0.size());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test77110() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler(3, 3);
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.emptyAndGetCurrentSegment();
    textBuffer0.finishCurrentSegment();
    textBuffer0.resetWithEmpty();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"public int getTextOffset() {
    /* Only shared input buffer can have non-zero offset; buffer
         * segments start at 0, and if we have to create a combo buffer,
         * that too will start from beginning of the buffer
         */
    return (_inputStart >= 0) ? _inputStart : 0;
}","public void test78111() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.releaseBuffers();
    assertEquals(0, textBuffer0.getTextOffset());
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test78112() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.releaseBuffers();
    assertEquals(0, textBuffer0.getCurrentSegmentSize());
}",""
"/*
    /**********************************************************
    /* Accessors for implementing public interface
    /**********************************************************
     */
/**
 * @return Number of characters currently stored by this collector
 */
public int size() {
    if (_inputStart >= 0) {
        // shared copy from input buf
        return _inputLen;
    }
    if (_resultArray != null) {
        return _resultArray.length;
    }
    if (_resultString != null) {
        return _resultString.length();
    }
    // local segmented buffers
    return _segmentSize + _currentSize;
}","public void test79113() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    textBuffer0.releaseBuffers();
    assertEquals(0, textBuffer0.size());
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test80114() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    int int0 = textBuffer0.getCurrentSegmentSize();
    assertEquals(0, int0);
}",""
"public int getCurrentSegmentSize() {
    return _currentSize;
}","public void test81115() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[7];
    textBuffer0.resetWithCopy(charArray0, 1, 1);
    textBuffer0.setCurrentLength(1023);
    textBuffer0.append(charArray0, 3, 3);
    assertEquals(3, textBuffer0.getCurrentSegmentSize());
}",""
"public char[] emptyAndGetCurrentSegment() {
    // inlined 'resetWithEmpty()'
    // indicates shared buffer not used
    _inputStart = -1;
    _currentSize = 0;
    _inputLen = 0;
    _inputBuffer = null;
    _resultString = null;
    _resultArray = null;
    // And then reset internal input buffers, if necessary:
    if (_hasSegments) {
        clearSegments();
    }
    char[] curr = _currentSegment;
    if (curr == null) {
        _currentSegment = curr = buf(0);
    }
    return curr;
}","public void test81116() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    char[] charArray0 = new char[7];
    textBuffer0.resetWithCopy(charArray0, 1, 1);
    textBuffer0.setCurrentLength(1023);
    textBuffer0.append(charArray0, 3, 3);
    char[] charArray1 = textBuffer0.emptyAndGetCurrentSegment();
    assertEquals(1500, charArray1.length);
}",""
"public double contentsAsDouble() throws NumberFormatException {
    return NumberInput.parseDouble(contentsAsString());
}","public void test82117() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);
    try {
        textBuffer0.contentsAsDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Convenience method for converting contents of the buffer
 * into a Double value.
 */"
"public char[] contentsAsArray() {
    char[] result = _resultArray;
    if (result == null) {
        _resultArray = result = resultArray();
    }
    return result;
}","public void test83118() throws Throwable {
    TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);
    textBuffer0.toString();
    char[] charArray0 = textBuffer0.contentsAsArray();
    assertEquals(0, charArray0.length);
}",""
