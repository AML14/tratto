focal_method,test_prefix,docstring
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test000() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected an int but was BOOLEAN at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test011() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a long but was BOOLEAN at line 1 column 6 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test022() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 78;
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test033() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected null but was BOOLEAN at line 1 column 6 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test044() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = (-710);
    boolean boolean0 = jsonReader0.hasNext();
    assertTrue(boolean0);
}","/**
 * Returns true if the current array or object has another element.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test045() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = (-710);
    boolean boolean0 = jsonReader0.hasNext();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test056() throws Throwable {
    StringReader stringReader0 = new StringReader(""Cv2W#S#jiAa"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    int int0 = jsonReader0.getLineNumber();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"int getLineNumber() {
    return lineNumber + 1;
}","public void test057() throws Throwable {
    StringReader stringReader0 = new StringReader(""Cv2W#S#jiAa"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    int int0 = jsonReader0.getLineNumber();
    assertEquals(1, int0);
}",""
"public final boolean isLenient() {
    return lenient;
}","public void test068() throws Throwable {
    StringReader stringReader0 = new StringReader(""{=NHuXD"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    int int0 = jsonReader0.getColumnNumber();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"int getColumnNumber() {
    return pos - lineStart + 1;
}","public void test069() throws Throwable {
    StringReader stringReader0 = new StringReader(""{=NHuXD"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    int int0 = jsonReader0.getColumnNumber();
    assertEquals(1, int0);
}",""
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test0710() throws Throwable {
    StringReader stringReader0 = new StringReader(""iTmwT[`A"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test0811() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input at line "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test0912() throws Throwable {
    StringReader stringReader0 = new StringReader(""Y~g'!2ABYI}q6)Q="");
    CharBuffer charBuffer0 = CharBuffer.allocate(2765);
    stringReader0.read(charBuffer0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test1013() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input at line "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test1114() throws Throwable {
    StringReader stringReader0 = new StringReader(""com.google.gson.stream.JsonReader$1"");
    stringReader0.skip(71L);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1215() throws Throwable {
    StringReader stringReader0 = new StringReader(""uail03_c535m!=$\""b"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1316() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 1351;
    // Undeclared exception!
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1417() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1518() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test1619() throws Throwable {
    StringReader stringReader0 = new StringReader(""n9dy{;4>"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test1720() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test1821() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 843;
    // Undeclared exception!
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test1922() throws Throwable {
    StringReader stringReader0 = new StringReader(""BOOLEAN"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2023() throws Throwable {
    StringReader stringReader0 = new StringReader(""null"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2124() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2225() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2326() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2427() throws Throwable {
    StringReader stringReader0 = new StringReader(""^BXQ6 &"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2528() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test2629() throws Throwable {
    StringReader stringReader0 = new StringReader(""5z4*+u(T@G:Y|U"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test2730() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input at line "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test2831() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test2932() throws Throwable {
    StringReader stringReader0 = new StringReader(""@0C@S3y"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test3033() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input at line "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test3134() throws Throwable {
    StringReader stringReader0 = new StringReader("" "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 2
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3235() throws Throwable {
    StringReader stringReader0 = new StringReader(""GcL]e(y^RI+KJ3*7S"");
    stringReader0.skip(71);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3336() throws Throwable {
    StringReader stringReader0 = new StringReader(""null"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3437() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test3538() throws Throwable {
    StringReader stringReader0 = new StringReader(""o`sn^h~6't"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test3639() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3740() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected6END_ARRAY bbt was "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3841() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test3942() throws Throwable {
    StringReader stringReader0 = new StringReader(""t{~wEAbQS]>VfH"");
    stringReader0.read();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test4043() throws Throwable {
    StringReader stringReader0 = new StringReader(""*d\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public String getPath() {
    StringBuilder result = new StringBuilder().append('$');
    for (int i = 0, size = stackSize; i < size; i++) {
        switch(stack[i]) {
            case JsonScope.EMPTY_ARRAY:
            case JsonScope.NONEMPTY_ARRAY:
                result.append('[').append(pathIndices[i]).append(']');
                break;
            case JsonScope.EMPTY_OBJECT:
            case JsonScope.DANGLING_NAME:
            case JsonScope.NONEMPTY_OBJECT:
                result.append('.');
                if (pathNames[i] != null) {
                    result.append(pathNames[i]);
                }
                break;
            case JsonScope.NONEMPTY_DOCUMENT:
            case JsonScope.EMPTY_DOCUMENT:
            case JsonScope.CLOSED:
                break;
        }
    }
    return result.toString();
}","public void test4144() throws Throwable {
    StringReader stringReader0 = new StringReader(""1"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.hasNext();
    String string0 = jsonReader0.getPath();
    assertEquals(""$"", string0);
}","/**
 * Returns a <a href=""http://goessner.net/articles/JsonPath/"">JsonPath</a> to
 * the current location in the JSON value.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test4245() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected END_OBJECT but was "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 61;
    // Undeclared exception!
    try {
        jsonReader0.peek();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test4346() throws Throwable {
    StringReader stringReader0 = new StringReader(""1\""a!"");
    stringReader0.read();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.doPeek();
    JsonToken jsonToken0 = jsonReader0.peek();
    assertEquals(JsonToken.STRING, jsonToken0);
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test4447() throws Throwable {
    StringReader stringReader0 = new StringReader(""ImLZ~;"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    char[] charArray0 = new char[3];
    stringReader0.read(charArray0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected null but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test4548() throws Throwable {
    StringReader stringReader0 = new StringReader(""END_OBJECT"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    String string0 = jsonReader0.getPath();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public String getPath() {
    StringBuilder result = new StringBuilder().append('$');
    for (int i = 0, size = stackSize; i < size; i++) {
        switch(stack[i]) {
            case JsonScope.EMPTY_ARRAY:
            case JsonScope.NONEMPTY_ARRAY:
                result.append('[').append(pathIndices[i]).append(']');
                break;
            case JsonScope.EMPTY_OBJECT:
            case JsonScope.DANGLING_NAME:
            case JsonScope.NONEMPTY_OBJECT:
                result.append('.');
                if (pathNames[i] != null) {
                    result.append(pathNames[i]);
                }
                break;
            case JsonScope.NONEMPTY_DOCUMENT:
            case JsonScope.EMPTY_DOCUMENT:
            case JsonScope.CLOSED:
                break;
        }
    }
    return result.toString();
}","public void test4549() throws Throwable {
    StringReader stringReader0 = new StringReader(""END_OBJECT"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    String string0 = jsonReader0.getPath();
    assertEquals(""$"", string0);
}","/**
 * Returns a <a href=""http://goessner.net/articles/JsonPath/"">JsonPath</a> to
 * the current location in the JSON value.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test4650() throws Throwable {
    StringReader stringReader0 = new StringReader(""Y~g'!2ABYI}q6)Q="");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.getPath();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public String getPath() {
    StringBuilder result = new StringBuilder().append('$');
    for (int i = 0, size = stackSize; i < size; i++) {
        switch(stack[i]) {
            case JsonScope.EMPTY_ARRAY:
            case JsonScope.NONEMPTY_ARRAY:
                result.append('[').append(pathIndices[i]).append(']');
                break;
            case JsonScope.EMPTY_OBJECT:
            case JsonScope.DANGLING_NAME:
            case JsonScope.NONEMPTY_OBJECT:
                result.append('.');
                if (pathNames[i] != null) {
                    result.append(pathNames[i]);
                }
                break;
            case JsonScope.NONEMPTY_DOCUMENT:
            case JsonScope.EMPTY_DOCUMENT:
            case JsonScope.CLOSED:
                break;
        }
    }
    return result.toString();
}","public void test4651() throws Throwable {
    StringReader stringReader0 = new StringReader(""Y~g'!2ABYI}q6)Q="");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.getPath();
    assertEquals(""$"", string0);
}","/**
 * Returns a <a href=""http://goessner.net/articles/JsonPath/"">JsonPath</a> to
 * the current location in the JSON value.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test4752() throws Throwable {
    StringReader stringReader0 = new StringReader(""#\""aR~Wp ~"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test4853() throws Throwable {
    StringReader stringReader0 = new StringReader("" "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 2
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test4954() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.skipValue();
    stringReader0.reset();
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 7 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5055() throws Throwable {
    StringReader stringReader0 = new StringReader(""$|tB%R8Cs#gh"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5156() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 325;
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5257() throws Throwable {
    StringReader stringReader0 = new StringReader(""JSON forbids NaN and infinities: "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5358() throws Throwable {
    StringReader stringReader0 = new StringReader(""cSN^K*E&?\nKwz}_f("");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5459() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 325;
    // Undeclared exception!
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5560() throws Throwable {
    StringReader stringReader0 = new StringReader(""n9dy{;4>"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5661() throws Throwable {
    StringReader stringReader0 = new StringReader(""Wx7[Elm_JhlUxtZeK~V"");
    char[] charArray0 = new char[2];
    stringReader0.read(charArray0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    double double0 = jsonReader0.nextDouble();
    assertEquals(7.0, double0, 0.01);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test5662() throws Throwable {
    StringReader stringReader0 = new StringReader(""Wx7[Elm_JhlUxtZeK~V"");
    char[] charArray0 = new char[2];
    stringReader0.read(charArray0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    double double0 = jsonReader0.nextDouble();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5763() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = (-798);
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test5864() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    boolean boolean0 = jsonReader0.nextBoolean();
    assertFalse(boolean0);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test5965() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected value"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 819;
    // Undeclared exception!
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test6066() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a string but was BOOLEAN at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test6167() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.hasNext();
    // Undeclared exception!
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a name but was BOOLEAN at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test6268() throws Throwable {
    StringReader stringReader0 = new StringReader(""}Z(Ly"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Expected value at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test6369() throws Throwable {
    String string0 = ""\\u"";
    StringReader stringReader0 = new StringReader(string0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test6470() throws Throwable {
    StringReader stringReader0 = new StringReader(""=GDacb&:`h*!Pp"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test6571() throws Throwable {
    StringReader stringReader0 = new StringReader(""/"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test6672() throws Throwable {
    StringReader stringReader0 = new StringReader("".JPrg(5DHU<ri]J"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test6773() throws Throwable {
    StringReader stringReader0 = new StringReader(""6EYai'"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test6874() throws Throwable {
    StringReader stringReader0 = new StringReader(""e,Q@=ksK% "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
}","public void test6975() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input at line "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7076() throws Throwable {
    StringReader stringReader0 = new StringReader(""5.V@VBMc&"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test7177() throws Throwable {
    StringReader stringReader0 = new StringReader(""-[~l?-Em"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7278() throws Throwable {
    StringReader stringReader0 = new StringReader(""cSN^K*E&?\nKwz}_f("");
    char[] charArray0 = new char[2];
    stringReader0.read(charArray0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test7379() throws Throwable {
    StringReader stringReader0 = new StringReader(""fWv25._0uK(:+bQd)"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test7480() throws Throwable {
    StringReader stringReader0 = new StringReader(""T=Cj)?>e d"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test7581() throws Throwable {
    StringReader stringReader0 = new StringReader("";^gS_M"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected value at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test7682() throws Throwable {
    StringReader stringReader0 = new StringReader(""'q8p&$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test7783() throws Throwable {
    StringReader stringReader0 = new StringReader(""1\""a!"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test7884() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.skipValue();
    JsonToken jsonToken0 = jsonReader0.peek();
    assertEquals(JsonToken.END_DOCUMENT, jsonToken0);
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test7885() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.skipValue();
    JsonToken jsonToken0 = jsonReader0.peek();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7986() throws Throwable {
    StringReader stringReader0 = new StringReader(""null"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a string but was NULL at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test8087() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    JsonToken jsonToken0 = jsonReader0.peek();
    assertEquals(JsonToken.BOOLEAN, jsonToken0);
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test8188() throws Throwable {
    StringReader stringReader0 = new StringReader(""[SqKW5ra{K'pBQP|w7_"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    JsonToken jsonToken0 = jsonReader0.peek();
    assertEquals(JsonToken.BEGIN_ARRAY, jsonToken0);
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test8289() throws Throwable {
    StringReader stringReader0 = new StringReader(""n9dy{;4>"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.skipValue();
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a double but was BEGIN_OBJECT at line 1 column 6 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test8390() throws Throwable {
    StringReader stringReader0 = new StringReader("":MeM^/wrd#,7n8{OqSe"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Expected value at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test8491() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 325;
    boolean boolean0 = jsonReader0.hasNext();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test8492() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 325;
    boolean boolean0 = jsonReader0.hasNext();
    assertTrue(boolean0);
}","/**
 * Returns true if the current array or object has another element.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test8593() throws Throwable {
    StringReader stringReader0 = new StringReader(""Cv2W#S#jiAa"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 4281;
    // Undeclared exception!
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test8694() throws Throwable {
    StringReader stringReader0 = new StringReader(""FALSE"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_OBJECT but was BOOLEAN at line 1 column 6 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test8795() throws Throwable {
    StringReader stringReader0 = new StringReader(""A>72fe3ax;<v^"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test8896() throws Throwable {
    StringReader stringReader0 = new StringReader(""1"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.hasNext();
    // Undeclared exception!
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected END_ARRAY but was NUMBER at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test8997() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
}","public void test9098() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 325;
    // Undeclared exception!
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public JsonReader(Reader in) {
    if (in == null) {
        throw new NullPointerException(""in == null"");
    }
    this.in = in;
}","public void test9199() throws Throwable {
    JsonReader jsonReader0 = null;
    try {
        jsonReader0 = new JsonReader((Reader) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // in == null
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Creates a new instance that reads a JSON-encoded stream from {@code in}.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test92100() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"@Override
public String toString() {
    return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber();
}","public void test93101() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.toString();
    assertEquals(""JsonReader at line 1 column 1"", string0);
}",""
"public final boolean isLenient() {
    return lenient;
}","public void test93102() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.toString();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test94103() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected a boolean but was "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    boolean boolean0 = jsonReader0.isLenient();
    assertFalse(boolean0);
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
