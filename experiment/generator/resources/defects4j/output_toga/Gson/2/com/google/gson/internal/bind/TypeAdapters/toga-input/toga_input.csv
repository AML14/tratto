focal_method,test_prefix,docstring
"public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            Class<? super T> rawType = typeToken.getRawType();
            return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;
        }

        @Override
        public String toString() {
            return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test000() throws Throwable {
    Gson gson0 = new Gson();
    Class<Calendar> class0 = Calendar.class;
    Class<GregorianCalendar> class1 = GregorianCalendar.class;
    TypeAdapterRuntimeTypeWrapper<Calendar> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Calendar>(gson0, (TypeAdapter<Calendar>) null, class1);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactoryForMultipleTypes(class0, (Class<? extends Calendar>) class1, (TypeAdapter<? super Calendar>) typeAdapterRuntimeTypeWrapper0);
    assertNotNull(typeAdapterFactory0);
}",""
"public static <TT> TypeAdapterFactory newFactory(final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;
        }
    };
}","public void test011() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    Class<Calendar> class1 = Calendar.class;
    TypeToken<Calendar> typeToken0 = TypeToken.get(class1);
    TypeAdapter<Calendar> typeAdapter0 = TypeAdapters.CALENDAR;
    TypeAdapterRuntimeTypeWrapper<Calendar> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Calendar>((Gson) null, typeAdapter0, class0);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactory(typeToken0, (TypeAdapter<Calendar>) typeAdapterRuntimeTypeWrapper0);
    assertNotNull(typeAdapterFactory0);
}",""
"@Override
public T read(JsonReader in) throws IOException {
    return delegate.read(in);
}","public void test022() throws Throwable {
    Class<UUID> class0 = UUID.class;
    Gson gson0 = new Gson();
    Class<Calendar> class1 = Calendar.class;
    TypeAdapter<Calendar> typeAdapter0 = gson0.getAdapter(class1);
    TypeAdapterRuntimeTypeWrapper<Calendar> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Calendar>(gson0, typeAdapter0, class0);
    PipedReader pipedReader0 = new PipedReader();
    JsonReader jsonReader0 = new JsonReader(pipedReader0);
    try {
        typeAdapterRuntimeTypeWrapper0.read(jsonReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}",""
"public static <TT> TypeAdapterFactory newFactory(final Class<TT> type, final TypeAdapter<TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;
        }

        @Override
        public String toString() {
            return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test033() throws Throwable {
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    Gson gson0 = new Gson();
    TypeAdapter<ChronoLocalDate> typeAdapter0 = gson0.getAdapter(class0);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactory(class0, typeAdapter0);
    assertNotNull(typeAdapterFactory0);
}",""
"public static <TT> TypeAdapterFactory newFactory(final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            Class<? super T> rawType = typeToken.getRawType();
            return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;
        }

        @Override
        public String toString() {
            return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test044() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    Gson gson0 = new Gson();
    TypeAdapter<Boolean> typeAdapter0 = gson0.getAdapter(class0);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactory(class0, class0, (TypeAdapter<? super Boolean>) typeAdapter0);
    assertNotNull(typeAdapterFactory0);
}",""
"public <T> TypeAdapter<T> getAdapter(Class<T> type) {
    return getAdapter(TypeToken.get(type));
}","public void test055() throws Throwable {
    Gson gson0 = new Gson();
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    TypeAdapter<GregorianCalendar> typeAdapter0 = gson0.getAdapter(class0);
    assertNotNull(typeAdapter0);
}","/**
 * Returns the type adapter for {@code} type.
 *
 * @throws IllegalArgumentException if this GSON cannot serialize and
 *     deserialize {@code type}.
 */"
"public String toJson(Object src) {
    if (src == null) {
        return toJson(JsonNull.INSTANCE);
    }
    return toJson(src, src.getClass());
}","public void test066() throws Throwable {
    Gson gson0 = new Gson();
    Class<Object> class0 = Object.class;
    TypeToken<Object> typeToken0 = TypeToken.get(class0);
    TypeAdapter<Object> typeAdapter0 = gson0.getAdapter(typeToken0);
    String string0 = gson0.toJson((Object) typeAdapter0);
    assertNotNull(string0);
}","/**
 * This method serializes the specified object into its equivalent Json representation.
 * This method should be used when the specified object is not a generic type. This method uses
 * {@link Class#getClass()} to get the type for the specified object, but the
 * {@code getClass()} loses the generic type information because of the Type Erasure feature
 * of Java. Note that this method works fine if the any of the object fields are of generic type,
 * just the object itself should not be of a generic type. If the object is of generic type, use
 * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 *
 * @param src the object for which Json representation is to be created setting for Gson
 * @return Json representation of {@code src}.
 */"
"public boolean isJsonArray() {
    return this instanceof JsonArray;
}","public void test077() throws Throwable {
    Gson gson0 = new Gson();
    JsonObject jsonObject0 = new JsonObject();
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(pipedOutputStream0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(filterOutputStream0, false);
    gson0.toJson((JsonElement) jsonObject0, (Appendable) mockPrintWriter0);
    assertFalse(jsonObject0.isJsonArray());
}","/**
 * provides check for verifying if this element is an array or not.
 *
 * @return true if this element is of type {@link JsonArray}, false otherwise.
 */"
"public JsonObject getAsJsonObject() {
    if (isJsonObject()) {
        return (JsonObject) this;
    }
    throw new IllegalStateException(""Not a JSON Object: "" + this);
}","public void test088() throws Throwable {
    JsonArray jsonArray0 = new JsonArray();
    // Undeclared exception!
    try {
        jsonArray0.getAsJsonObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Not a JSON Object: []
        //
        verifyException(""com.google.gson.JsonElement"", e);
    }
}","/**
 * convenience method to get this element as a {@link JsonObject}. If the element is of some
 * other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 * first.
 *
 * @return get this element as a {@link JsonObject}.
 * @throws IllegalStateException if the element is of another type.
 */"
"public String toJson(Object src) {
    if (src == null) {
        return toJson(JsonNull.INSTANCE);
    }
    return toJson(src, src.getClass());
}","public void test099() throws Throwable {
    Gson gson0 = new Gson();
    String string0 = gson0.toJson((Object) null);
    assertEquals(""null"", string0);
}","/**
 * This method serializes the specified object into its equivalent Json representation.
 * This method should be used when the specified object is not a generic type. This method uses
 * {@link Class#getClass()} to get the type for the specified object, but the
 * {@code getClass()} loses the generic type information because of the Type Erasure feature
 * of Java. Note that this method works fine if the any of the object fields are of generic type,
 * just the object itself should not be of a generic type. If the object is of generic type, use
 * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 *
 * @param src the object for which Json representation is to be created setting for Gson
 * @return Json representation of {@code src}.
 */"
"public String toJson(JsonElement jsonElement) {
    StringWriter writer = new StringWriter();
    toJson(jsonElement, writer);
    return writer.toString();
}","public void test1010() throws Throwable {
    Gson gson0 = new Gson();
    Character character0 = Character.valueOf('c');
    JsonPrimitive jsonPrimitive0 = new JsonPrimitive(character0);
    String string0 = gson0.toJson((JsonElement) jsonPrimitive0);
    assertEquals(""\""c\"""", string0);
}","/**
 * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
 *
 * @param jsonElement root of a tree of {@link JsonElement}s
 * @return JSON String representation of the tree
 * @since 1.4
 */"
"public String toJson(JsonElement jsonElement) {
    StringWriter writer = new StringWriter();
    toJson(jsonElement, writer);
    return writer.toString();
}","public void test1111() throws Throwable {
    Gson gson0 = new Gson();
    String string0 = gson0.toJson((JsonElement) null);
    assertEquals(""null"", string0);
}","/**
 * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
 *
 * @param jsonElement root of a tree of {@link JsonElement}s
 * @return JSON String representation of the tree
 * @since 1.4
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test1212() throws Throwable {
    Class<Object> class0 = Object.class;
    Gson gson0 = new Gson();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) null, (Type) class0);
    Class<JsonArray> class1 = JsonArray.class;
    // Undeclared exception!
    try {
        gson0.fromJson(jsonElement0, class1);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test1313() throws Throwable {
    Gson gson0 = new Gson();
    JsonPrimitive jsonPrimitive0 = new JsonPrimitive(""Qu"");
    Class<JsonArray> class0 = JsonArray.class;
    // Undeclared exception!
    try {
        gson0.fromJson((JsonElement) jsonPrimitive0, class0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test1414() throws Throwable {
    Class<Object> class0 = Object.class;
    Excluder excluder0 = Excluder.DEFAULT;
    Gson gson0 = new Gson();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) excluder0, (Type) class0);
    Class<JsonArray> class1 = JsonArray.class;
    // Undeclared exception!
    try {
        gson0.fromJson(jsonElement0, class1);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public boolean isBoolean() {
    return value instanceof Boolean;
}","public void test1515() throws Throwable {
    Class<MockGregorianCalendar> class0 = MockGregorianCalendar.class;
    Gson gson0 = new Gson();
    TypeAdapter<Locale> typeAdapter0 = TypeAdapters.LOCALE;
    TypeAdapterRuntimeTypeWrapper<Locale> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Locale>(gson0, typeAdapter0, class0);
    Locale locale0 = Locale.PRC;
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) typeAdapterRuntimeTypeWrapper0.toJsonTree(locale0);
    assertFalse(jsonPrimitive0.isBoolean());
}","/**
 * Check whether this primitive contains a boolean value.
 *
 * @return true if this primitive contains a boolean value, false otherwise.
 */"
"public final String toJson(T value) {
    StringWriter stringWriter = new StringWriter();
    try {
        toJson(stringWriter, value);
    } catch (IOException e) {
        // No I/O writing to a StringWriter.
        throw new AssertionError(e);
    }
    return stringWriter.toString();
}","public void test1616() throws Throwable {
    Class<Locale> class0 = Locale.class;
    Gson gson0 = new Gson();
    TypeAdapterRuntimeTypeWrapper<Object> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Object>(gson0, (TypeAdapter<Object>) null, class0);
    URL uRL0 = MockURL.getFileExample();
    // Undeclared exception!
    try {
        typeAdapterRuntimeTypeWrapper0.toJson((Object) uRL0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JSON must start with an array or an object.
        //
        verifyException(""com.google.gson.stream.JsonWriter"", e);
    }
}","/**
 * Converts {@code value} to a JSON document. Unlike Gson's similar {@link
 * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link
 * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
 * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
 * writing.
 *
 * @param value the Java object to convert. May be null.
 * @since 2.2
 */"
"public final T fromJsonTree(JsonElement jsonTree) {
    try {
        JsonReader jsonReader = new JsonTreeReader(jsonTree);
        return read(jsonReader);
    } catch (IOException e) {
        throw new JsonIOException(e);
    }
}","public void test1717() throws Throwable {
    Class<URL> class0 = URL.class;
    Gson gson0 = new Gson();
    TypeAdapter<URL> typeAdapter0 = gson0.getAdapter(class0);
    TypeAdapterRuntimeTypeWrapper<URL> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<URL>(gson0, typeAdapter0, class0);
    JsonNull jsonNull0 = JsonNull.INSTANCE;
    URL uRL0 = typeAdapterRuntimeTypeWrapper0.fromJsonTree(jsonNull0);
    assertNull(uRL0);
}","/**
 * Converts {@code jsonTree} to a Java object.
 *
 * @param jsonTree the Java object to convert. May be {@link JsonNull}.
 * @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test1818() throws Throwable {
    Class<StringBuffer> class0 = StringBuffer.class;
    Gson gson0 = new Gson();
    try {
        gson0.fromJson(""Expected name"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 11 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    return (T) fromJson(new JsonTreeReader(json), typeOfT);
}","public void test1919() throws Throwable {
    Gson gson0 = new Gson();
    Boolean boolean0 = new Boolean(""/s*XB$;,$>m0)"");
    JsonPrimitive jsonPrimitive0 = new JsonPrimitive(boolean0);
    Class<Long> class0 = Long.TYPE;
    try {
        gson0.fromJson((JsonElement) jsonPrimitive0, (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected NUMBER but was BOOLEAN
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. This method is useful if the specified object is a generic type. For
 * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2020() throws Throwable {
    Gson gson0 = new Gson();
    Class<Short> class0 = Short.class;
    try {
        gson0.fromJson(""Expected "", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected an int but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    return (T) fromJson(new JsonTreeReader(json), typeOfT);
}","public void test2121() throws Throwable {
    Class<Byte> class0 = Byte.class;
    Gson gson0 = new Gson();
    JsonObject jsonObject0 = new JsonObject();
    try {
        gson0.fromJson((JsonElement) jsonObject0, (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected NUMBER but was BEGIN_OBJECT
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. This method is useful if the specified object is a generic type. For
 * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public String toJson(Object src, Type typeOfSrc) {
    StringWriter writer = new StringWriter();
    toJson(src, typeOfSrc, writer);
    return writer.toString();
}","public void test2222() throws Throwable {
    Gson gson0 = new Gson();
    Class<Boolean> class0 = Boolean.TYPE;
    String string0 = gson0.toJson((Object) null, (Type) class0);
    assertEquals(""null"", string0);
}","/**
 * This method serializes the specified object, including those of generic types, into its
 * equivalent Json representation. This method must be used if the specified object is a generic
 * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 *
 * @param src the object for which JSON representation is to be created
 * @param typeOfSrc The specific genericized type of src. You can obtain
 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 * to get the type for {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return Json representation of {@code src}
 */"
"public int size() {
    return elements.size();
}","public void test2323() throws Throwable {
    Gson gson0 = new Gson();
    BitSet bitSet0 = new BitSet();
    bitSet0.flip(12);
    JsonArray jsonArray0 = (JsonArray) gson0.toJsonTree((Object) bitSet0);
    assertEquals(13, jsonArray0.size());
}","/**
 * Returns the number of elements in the array.
 *
 * @return the number of elements in the array.
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test2424() throws Throwable {
    Gson gson0 = new Gson();
    BitSet bitSet0 = new BitSet();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) bitSet0);
    Class<StringBuilder> class0 = StringBuilder.class;
    try {
        gson0.fromJson(jsonElement0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected STRING but was BEGIN_ARRAY
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public String toJson(Object src) {
    if (src == null) {
        return toJson(JsonNull.INSTANCE);
    }
    return toJson(src, src.getClass());
}","public void test2525() throws Throwable {
    Class<Byte> class0 = Byte.class;
    Gson gson0 = new Gson();
    // Undeclared exception!
    try {
        gson0.toJson((Object) class0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Attempted to serialize java.lang.Class: java.lang.Byte. Forgot to register a type adapter?
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$1"", e);
    }
}","/**
 * This method serializes the specified object into its equivalent Json representation.
 * This method should be used when the specified object is not a generic type. This method uses
 * {@link Class#getClass()} to get the type for the specified object, but the
 * {@code getClass()} loses the generic type information because of the Type Erasure feature
 * of Java. Note that this method works fine if the any of the object fields are of generic type,
 * just the object itself should not be of a generic type. If the object is of generic type, use
 * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 *
 * @param src the object for which Json representation is to be created setting for Gson
 * @return Json representation of {@code src}.
 */"
"public static <T1> TypeAdapterFactory newTypeHierarchyFactory(final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
    return new TypeAdapterFactory() {

        @SuppressWarnings(""unchecked"")
        public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
            final Class<? super T2> requestedType = typeToken.getRawType();
            if (!clazz.isAssignableFrom(requestedType)) {
                return null;
            }
            return (TypeAdapter<T2>) typeAdapter;
        }

        @Override
        public String toString() {
            return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test2626() throws Throwable {
    Class<MockGregorianCalendar> class0 = MockGregorianCalendar.class;
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newTypeHierarchyFactory(class0, (TypeAdapter<MockGregorianCalendar>) null);
    assertNotNull(typeAdapterFactory0);
}","/**
 * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
 * that the deserialized type matches the type requested.
 */"
"@Override
public String toString() {
    return new StringBuilder(""{serializeNulls:"").append(serializeNulls).append(""factories:"").append(factories).append("",instanceCreators:"").append(constructorConstructor).append(""}"").toString();
}","public void test2828() throws Throwable {
    Gson gson0 = new Gson();
    String string0 = gson0.toString();
    assertNotNull(string0);
}",""
