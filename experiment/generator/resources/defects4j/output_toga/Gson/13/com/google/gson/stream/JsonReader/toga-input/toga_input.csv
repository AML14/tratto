focal_method,test_prefix,docstring
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test000() throws Throwable {
    StringReader stringReader0 = new StringReader(""_fZ+9+%"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    char[] charArray0 = new char[2];
    jsonReader0.setLenient(true);
    stringReader0.read(charArray0);
    jsonReader0.nextString();
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test011() throws Throwable {
    StringReader stringReader0 = new StringReader(""null"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.skipValue();
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
    }
}","public void test022() throws Throwable {
    StringReader stringReader0 = new StringReader(""{Z^"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected null but was BEGIN_OBJECT at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test033() throws Throwable {
    StringReader stringReader0 = new StringReader(""7"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a name but was NUMBER at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test044() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test045() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    boolean boolean0 = jsonReader0.isLenient();
    assertTrue(boolean0);
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test056() throws Throwable {
    StringReader stringReader0 = new StringReader(""1>g`M*dk?MI8i"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test067() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test078() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test089() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = (-1035);
    // Undeclared exception!
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test0910() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1011() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
    }
}","public void test1112() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 1896;
    // Undeclared exception!
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
    }
}","public void test1213() throws Throwable {
    StringReader stringReader0 = new StringReader(""'V"");
    char[] charArray0 = new char[3];
    stringReader0.read(charArray0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test1314() throws Throwable {
    StringReader stringReader0 = new StringReader(""L/ FL>gcC1q\""}"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test1415() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1516() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1617() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1718() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1819() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test1920() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected a double but was "");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test2021() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test2122() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test2223() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test2324() throws Throwable {
    StringReader stringReader0 = new StringReader(""@[z{Cr8jIr6;V*jG$w"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test2425() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test2526() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString());
    }
}","public void test2627() throws Throwable {
    StringReader stringReader0 = new StringReader(""td{lj"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString());
    }
}","public void test2728() throws Throwable {
    StringReader stringReader0 = new StringReader(""()+@sNqw6Jl"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
    }
}","public void test2829() throws Throwable {
    StringReader stringReader0 = new StringReader(""com.google.gson.stream.MalformedJsonException"");
    stringReader0.close();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
    }
}","public void test2930() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test3031() throws Throwable {
    StringReader stringReader0 = new StringReader(""z &oj}, MU:J-!7%}R"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test3132() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test3233() throws Throwable {
    StringReader stringReader0 = new StringReader(""]+9v=*Y#rtSs76MPq+"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected value at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test3334() throws Throwable {
    StringReader stringReader0 = new StringReader("":M|nQ^XMJ;~^m"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    stringReader0.close();
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.StringReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test3435() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString());
    }
}","public void test3536() throws Throwable {
    StringReader stringReader0 = new StringReader(""o2;$}Pr6#<"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 574;
    // Undeclared exception!
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString());
    }
}","public void test3637() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test3738() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    String string0 = jsonReader0.nextString();
    assertEquals(""u"", string0);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String getPath() {
    StringBuilder result = new StringBuilder().append('$');
    for (int i = 0, size = stackSize; i < size; i++) {
        switch(stack[i]) {
            case JsonScope.EMPTY_ARRAY:
            case JsonScope.NONEMPTY_ARRAY:
                result.append('[').append(pathIndices[i]).append(']');
                break;
            case JsonScope.EMPTY_OBJECT:
            case JsonScope.DANGLING_NAME:
            case JsonScope.NONEMPTY_OBJECT:
                result.append('.');
                if (pathNames[i] != null) {
                    result.append(pathNames[i]);
                }
                break;
            case JsonScope.NONEMPTY_DOCUMENT:
            case JsonScope.EMPTY_DOCUMENT:
            case JsonScope.CLOSED:
                break;
        }
    }
    return result.toString();
}","public void test3739() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    String string0 = jsonReader0.nextString();
    String string1 = jsonReader0.getPath();
    assertEquals(""$"", string1);
}","/**
 * Returns a <a href=""http://goessner.net/articles/JsonPath/"">JsonPath</a> to
 * the current location in the JSON value.
 */"
"public String getPath() {
    StringBuilder result = new StringBuilder().append('$');
    for (int i = 0, size = stackSize; i < size; i++) {
        switch(stack[i]) {
            case JsonScope.EMPTY_ARRAY:
            case JsonScope.NONEMPTY_ARRAY:
                result.append('[').append(pathIndices[i]).append(']');
                break;
            case JsonScope.EMPTY_OBJECT:
            case JsonScope.DANGLING_NAME:
            case JsonScope.NONEMPTY_OBJECT:
                result.append('.');
                if (pathNames[i] != null) {
                    result.append(pathNames[i]);
                }
                break;
            case JsonScope.NONEMPTY_DOCUMENT:
            case JsonScope.EMPTY_DOCUMENT:
            case JsonScope.CLOSED:
                break;
        }
    }
    return result.toString();
}","public void test3840() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.getPath();
    assertEquals(""$"", string0);
}","/**
 * Returns a <a href=""http://goessner.net/articles/JsonPath/"">JsonPath</a> to
 * the current location in the JSON value.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test3841() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.getPath();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test3942() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0#*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test4043() throws Throwable {
    StringReader stringReader0 = new StringReader(""/mx%0rHm4DIDC."");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test4144() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(>#*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    stringReader0.reset();
    jsonReader0.skipValue();
    assertTrue(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test4245() throws Throwable {
    StringReader stringReader0 = new StringReader(""{US9bLmP+"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peek();
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 3 path $.
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test4346() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test4447() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0#*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.skipValue();
    assertTrue(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test4548() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.skipValue();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test4649() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test4750() throws Throwable {
    StringReader stringReader0 = new StringReader(""End of input"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test4851() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    // Undeclared exception!
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test4952() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""A@-'4bX>&;eBL"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unterminated string at line 1 column 15 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5053() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a double but was END_DOCUMENT at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5154() throws Throwable {
    StringReader stringReader0 = new StringReader(""u"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.hasNext();
    // Undeclared exception!
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
    }
}","public void test5255() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected BEGIN_ARRAY but was "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test5356() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a boolean but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5457() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.nextString();
    assertEquals(""`/koumn~)Gr1DC"", string0);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5558() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0-*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    // Undeclared exception!
    try {
        jsonReader0.nextString();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a string but was END_DOCUMENT at line 1 column 12 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test5659() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0-*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    boolean boolean0 = jsonReader0.hasNext();
    assertTrue(boolean0);
}","/**
 * Returns true if the current array or object has another element.
 */"
"public String nextString() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED) {
        result = nextQuotedValue('""');
    } else if (p == PEEKED_BUFFERED) {
        result = peekedString;
        peekedString = null;
    } else if (p == PEEKED_LONG) {
        result = Long.toString(peekedLong);
    } else if (p == PEEKED_NUMBER) {
        result = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else {
        throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test5660() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0-*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    boolean boolean0 = jsonReader0.hasNext();
    String string0 = jsonReader0.nextString();
    assertNotNull(string0);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 * consuming it. If the next token is a number, this method will return its
 * string form.
 *
 * @throws IllegalStateException if the next token is not a string or if
 *     this reader is closed.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test5762() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a name but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test5863() throws Throwable {
    StringReader stringReader0 = new StringReader(""=uUL[*a%+vs;|b8[W"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test5964() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0*t9t/p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Expected value at line 1 column 9 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test6065() throws Throwable {
    StringReader stringReader0 = new StringReader(""418K{Eu?>*GR?7iA"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test6166() throws Throwable {
    StringReader stringReader0 = new StringReader("".&JI%p+:G'].9sHP|U"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test6267() throws Throwable {
    StringReader stringReader0 = new StringReader(""+q[sjs81~o"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test6368() throws Throwable {
    StringReader stringReader0 = new StringReader(""8"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    int int0 = jsonReader0.nextInt();
    assertEquals(8, int0);
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public double nextDouble() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return (double) peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
    } else if (p == PEEKED_UNQUOTED) {
        peekedString = nextUnquotedValue();
    } else if (p != PEEKED_BUFFERED) {
        throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double result = Double.parseDouble(peekedString);
    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
        throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test6469() throws Throwable {
    StringReader stringReader0 = new StringReader(""NUMBER"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextDouble();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a double using {@link Double#parseDouble(String)}.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a double, or is non-finite.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test6570() throws Throwable {
    StringReader stringReader0 = new StringReader(""f"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
        // Look for a comma before the next element.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ']':
                return peeked = PEEKED_END_ARRAY;
            case ';':
                // fall-through
                checkLenient();
            case ',':
                break;
            default:
                throw syntaxError(""Unterminated array"");
        }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
        stack[stackSize - 1] = JsonScope.DANGLING_NAME;
        // Look for a comma before the next element.
        if (peekStack == JsonScope.NONEMPTY_OBJECT) {
            int c = nextNonWhitespace(true);
            switch(c) {
                case '}':
                    return peeked = PEEKED_END_OBJECT;
                case ';':
                    // fall-through
                    checkLenient();
                case ',':
                    break;
                default:
                    throw syntaxError(""Unterminated object"");
            }
        }
        int c = nextNonWhitespace(true);
        switch(c) {
            case '""':
                return peeked = PEEKED_DOUBLE_QUOTED_NAME;
            case '\'':
                checkLenient();
                return peeked = PEEKED_SINGLE_QUOTED_NAME;
            case '}':
                if (peekStack != JsonScope.NONEMPTY_OBJECT) {
                    return peeked = PEEKED_END_OBJECT;
                } else {
                    throw syntaxError(""Expected name"");
                }
            default:
                checkLenient();
                // Don't consume the first character in an unquoted string.
                pos--;
                if (isLiteral((char) c)) {
                    return peeked = PEEKED_UNQUOTED_NAME;
                } else {
                    throw syntaxError(""Expected name"");
                }
        }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
        // Look for a colon before the value.
        int c = nextNonWhitespace(true);
        switch(c) {
            case ':':
                break;
            case '=':
                checkLenient();
                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
                    pos++;
                }
                break;
            default:
                throw syntaxError(""Expected ':'"");
        }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
        if (lenient) {
            consumeNonExecutePrefix();
        }
        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
        int c = nextNonWhitespace(false);
        if (c == -1) {
            return peeked = PEEKED_EOF;
        } else {
            checkLenient();
            pos--;
        }
    } else if (peekStack == JsonScope.CLOSED) {
        throw new IllegalStateException(""JsonReader is closed"");
    }
    int c = nextNonWhitespace(true);
    switch(c) {
        case ']':
            if (peekStack == JsonScope.EMPTY_ARRAY) {
                return peeked = PEEKED_END_ARRAY;
            }
        // fall-through to handle "",]""
        case ';':
        case ',':
            // In lenient mode, a 0-length literal in an array means 'null'.
            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
                checkLenient();
                pos--;
                return peeked = PEEKED_NULL;
            } else {
                throw syntaxError(""Unexpected value"");
            }
        case '\'':
            checkLenient();
            return peeked = PEEKED_SINGLE_QUOTED;
        case '""':
            return peeked = PEEKED_DOUBLE_QUOTED;
        case '[':
            return peeked = PEEKED_BEGIN_ARRAY;
        case '{':
            return peeked = PEEKED_BEGIN_OBJECT;
        default:
            // Don't consume the first character in a literal value.
            pos--;
    }
    int result = peekKeyword();
    if (result != PEEKED_NONE) {
        return result;
    }
    result = peekNumber();
    if (result != PEEKED_NONE) {
        return result;
    }
    if (!isLiteral(buffer[pos])) {
        throw syntaxError(""Expected value"");
    }
    checkLenient();
    return peeked = PEEKED_UNQUOTED;
}","public void test6671() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.skipValue();
    try {
        jsonReader0.doPeek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected value at line 1 column 4 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}",""
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test6772() throws Throwable {
    StringReader stringReader0 = new StringReader("";h>F7|[qk1MTKR"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.hasNext();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected value at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns true if the current array or object has another element.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test6873() throws Throwable {
    StringReader stringReader0 = new StringReader("",A"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected value at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test6974() throws Throwable {
    StringReader stringReader0 = new StringReader(""r'vF56YZ0]v"");
    stringReader0.read();
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test7075() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0-*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    stringReader0.reset();
    jsonReader0.skipValue();
    assertTrue(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test7176() throws Throwable {
    StringReader stringReader0 = new StringReader(""NAME"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.close();
    // Undeclared exception!
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // JsonReader is closed
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public void skipValue() throws IOException {
    int count = 0;
    do {
        int p = peeked;
        if (p == PEEKED_NONE) {
            p = doPeek();
        }
        if (p == PEEKED_BEGIN_ARRAY) {
            push(JsonScope.EMPTY_ARRAY);
            count++;
        } else if (p == PEEKED_BEGIN_OBJECT) {
            push(JsonScope.EMPTY_OBJECT);
            count++;
        } else if (p == PEEKED_END_ARRAY) {
            stackSize--;
            count--;
        } else if (p == PEEKED_END_OBJECT) {
            stackSize--;
            count--;
        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
            skipUnquotedValue();
        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
            skipQuotedValue('\'');
        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
            skipQuotedValue('""');
        } else if (p == PEEKED_NUMBER) {
            pos += peekedNumberLength;
        }
        peeked = PEEKED_NONE;
    } while (count != 0);
    pathIndices[stackSize - 1]++;
    pathNames[stackSize - 1] = ""null"";
}","public void test7277() throws Throwable {
    StringReader stringReader0 = new StringReader(""{US9bLmP+"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.skipValue();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 3 path $.
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7378() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 282;
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
    }
}","public void test7479() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0#*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.nextString();
    // Undeclared exception!
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected END_ARRAY but was END_DOCUMENT at line 1 column 12 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void nextNull() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_NULL) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
    } else {
        throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
    }
}","public void test7580() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""]`52)3|-_7y"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peek();
    // Undeclared exception!
    try {
        jsonReader0.nextNull();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected null but was STRING at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is a
 * literal null.
 *
 * @throws IllegalStateException if the next token is not null or if this
 *     reader is closed.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test7681() throws Throwable {
    StringReader stringReader0 = new StringReader(""null"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_OBJECT but was NULL at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    int result;
    if (p == PEEKED_LONG) {
        result = (int) peekedLong;
        if (peekedLong != result) {
            // Make sure no precision was lost casting to 'int'.
            throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
        }
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            result = Integer.parseInt(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    result = (int) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7782() throws Throwable {
    StringReader stringReader0 = new StringReader(""true"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextInt();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected an int but was BOOLEAN at line 1 column 5 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as an int. If the next token's numeric value cannot be exactly
 * represented by a Java {@code int}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as an int.
 */"
"public boolean nextBoolean() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_TRUE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return true;
    } else if (p == PEEKED_FALSE) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return false;
    }
    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
}","public void test7883() throws Throwable {
    StringReader stringReader0 = new StringReader(""VEL=[?5WP%2P 2wF/"");
    char[] charArray0 = new char[4];
    stringReader0.read(charArray0);
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.nextBoolean();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a boolean but was BEGIN_ARRAY at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 * consuming it.
 *
 * @throws IllegalStateException if the next token is not a boolean or if
 *     this reader is closed.
 */"
"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_LONG) {
        peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return peekedLong;
    }
    if (p == PEEKED_NUMBER) {
        peekedString = new String(buffer, pos, peekedNumberLength);
        pos += peekedNumberLength;
    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
        if (p == PEEKED_UNQUOTED) {
            peekedString = nextUnquotedValue();
        } else {
            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
        }
        try {
            long result = Long.parseLong(peekedString);
            peeked = PEEKED_NONE;
            pathIndices[stackSize - 1]++;
            return result;
        } catch (NumberFormatException ignored) {
            // Fall back to parse as a double below.
        }
    } else {
        throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
    }
    peeked = PEEKED_BUFFERED;
    // don't catch this NumberFormatException.
    double asDouble = Double.parseDouble(peekedString);
    long result = (long) asDouble;
    if (result != asDouble) {
        // Make sure no precision was lost casting to 'long'.
        throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
}","public void test7984() throws Throwable {
    StringReader stringReader0 = new StringReader(""{US9bLmP+"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peek();
    // Undeclared exception!
    try {
        jsonReader0.nextLong();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected a long but was BEGIN_OBJECT at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 * consuming it. If the next token is a string, this method will attempt to
 * parse it as a long. If the next token's numeric value cannot be exactly
 * represented by a Java {@code long}, this method throws.
 *
 * @throws IllegalStateException if the next token is not a literal value.
 * @throws NumberFormatException if the next literal value cannot be parsed
 *     as a number, or exactly represented as a long.
 */"
"public JsonToken peek() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    switch(p) {
        case PEEKED_BEGIN_OBJECT:
            return JsonToken.BEGIN_OBJECT;
        case PEEKED_END_OBJECT:
            return JsonToken.END_OBJECT;
        case PEEKED_BEGIN_ARRAY:
            return JsonToken.BEGIN_ARRAY;
        case PEEKED_END_ARRAY:
            return JsonToken.END_ARRAY;
        case PEEKED_SINGLE_QUOTED_NAME:
        case PEEKED_DOUBLE_QUOTED_NAME:
        case PEEKED_UNQUOTED_NAME:
            return JsonToken.NAME;
        case PEEKED_TRUE:
        case PEEKED_FALSE:
            return JsonToken.BOOLEAN;
        case PEEKED_NULL:
            return JsonToken.NULL;
        case PEEKED_SINGLE_QUOTED:
        case PEEKED_DOUBLE_QUOTED:
        case PEEKED_UNQUOTED:
        case PEEKED_BUFFERED:
            return JsonToken.STRING;
        case PEEKED_LONG:
        case PEEKED_NUMBER:
            return JsonToken.NUMBER;
        case PEEKED_EOF:
            return JsonToken.END_DOCUMENT;
        default:
            throw new AssertionError();
    }
}","public void test8085() throws Throwable {
    StringReader stringReader0 = new StringReader("" $PL)RQB3Gt"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.peek();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 2 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the type of the next token without consuming it.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test8186() throws Throwable {
    StringReader stringReader0 = new StringReader(""8vhJc,4\"" "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 2063;
    boolean boolean0 = jsonReader0.hasNext();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public boolean hasNext() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
}","public void test8187() throws Throwable {
    StringReader stringReader0 = new StringReader(""8vhJc,4\"" "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.peeked = 2063;
    boolean boolean0 = jsonReader0.hasNext();
    assertTrue(boolean0);
}","/**
 * Returns true if the current array or object has another element.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString());
    }
}","public void test8288() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // End of input at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void endObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_OBJECT) {
        stackSize--;
        // Free the last path name so that it can be garbage collected!
        pathNames[stackSize] = null;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString());
    }
}","public void test8389() throws Throwable {
    StringReader stringReader0 = new StringReader(""_fZ+9+%"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.endObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected END_OBJECT but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current object.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test8490() throws Throwable {
    StringReader stringReader0 = new StringReader(""em]g?`Y9?9l`N"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_OBJECT but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
    }
}","public void test8591() throws Throwable {
    StringReader stringReader0 = new StringReader("":nGU 5s[N{k8"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Expected value at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void endArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_END_ARRAY) {
        stackSize--;
        pathIndices[stackSize - 1]++;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
    }
}","public void test8692() throws Throwable {
    StringReader stringReader0 = new StringReader(""kG(0#*t9p~$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.hasNext();
    // Undeclared exception!
    try {
        jsonReader0.endArray();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected END_ARRAY but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * end of the current array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString());
    }
}","public void test8793() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected BEGIN_OBJECT but was "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public void beginArray() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_ARRAY) {
        push(JsonScope.EMPTY_ARRAY);
        pathIndices[stackSize - 1] = 0;
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString());
    }
}","public void test8894() throws Throwable {
    StringReader stringReader0 = new StringReader(""Expected null but was "");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    jsonReader0.setLenient(true);
    jsonReader0.doPeek();
    // Undeclared exception!
    try {
        jsonReader0.beginArray();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new array.
 */"
"public JsonReader(Reader in) {
    if (in == null) {
        throw new NullPointerException(""in == null"");
    }
    this.in = in;
}","public void test8995() throws Throwable {
    JsonReader jsonReader0 = null;
    try {
        jsonReader0 = new JsonReader((Reader) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // in == null
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Creates a new instance that reads a JSON-encoded stream from {@code in}.
 */"
"public String nextName() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    String result;
    if (p == PEEKED_UNQUOTED_NAME) {
        result = nextUnquotedValue();
    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
        result = nextQuotedValue('\'');
    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
        result = nextQuotedValue('""');
    } else {
        throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
    }
    peeked = PEEKED_NONE;
    pathNames[stackSize - 1] = result;
    return result;
}","public void test9096() throws Throwable {
    StringReader stringReader0 = new StringReader(""TK;]"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    try {
        jsonReader0.nextName();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
 * consumes it.
 *
 * @throws java.io.IOException if the next token in the stream is not a property
 *     name.
 */"
"@Override
public String toString() {
    return getClass().getSimpleName() + locationString();
}","public void test9197() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.toString();
    assertEquals(""JsonReader at line 1 column 1 path $"", string0);
}",""
"public final boolean isLenient() {
    return lenient;
}","public void test9198() throws Throwable {
    StringReader stringReader0 = new StringReader(""\""`/koumn~)Gr1DC\"""");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    String string0 = jsonReader0.toString();
    assertFalse(jsonReader0.isLenient());
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public final boolean isLenient() {
    return lenient;
}","public void test9299() throws Throwable {
    StringReader stringReader0 = new StringReader(""@LNr`+O6Q$"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    boolean boolean0 = jsonReader0.isLenient();
    assertFalse(boolean0);
}","/**
 * Returns true if this parser is liberal in what it accepts.
 */"
"public void beginObject() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
        p = doPeek();
    }
    if (p == PEEKED_BEGIN_OBJECT) {
        push(JsonScope.EMPTY_OBJECT);
        peeked = PEEKED_NONE;
    } else {
        throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
    }
}","public void test93100() throws Throwable {
    StringReader stringReader0 = new StringReader(""-1{6%A)/R-%F6T~Q"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    // Undeclared exception!
    try {
        jsonReader0.beginObject();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Expected BEGIN_OBJECT but was NUMBER at line 1 column 3 path $
        //
        verifyException(""com.google.gson.stream.JsonReader"", e);
    }
}","/**
 * Consumes the next token from the JSON stream and asserts that it is the
 * beginning of a new object.
 */"
