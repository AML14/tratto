focal_method,test_prefix,docstring
"public String toJson(JsonElement jsonElement) {
    StringWriter writer = new StringWriter();
    toJson(jsonElement, writer);
    return writer.toString();
}","public void test000() throws Throwable {
    Gson gson0 = new Gson();
    ZoneOffset zoneOffset0 = ZoneOffset.MAX;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.ITALIAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0, locale0);
    JsonElement jsonElement0 = gson0.toJsonTree((Object) mockGregorianCalendar0);
    String string0 = gson0.toJson(jsonElement0);
    assertNotNull(string0);
}","/**
 * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
 *
 * @param jsonElement root of a tree of {@link JsonElement}s
 * @return JSON String representation of the tree
 * @since 1.4
 */"
"@Override
public String toString() {
    return new StringBuilder(""{serializeNulls:"").append(serializeNulls).append(""factories:"").append(factories).append("",instanceCreators:"").append(constructorConstructor).append(""}"").toString();
}","public void test011() throws Throwable {
    Gson gson0 = new Gson();
    String string0 = gson0.toString();
    assertNotNull(string0);
}",""
"public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            Class<? super T> rawType = typeToken.getRawType();
            return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;
        }

        @Override
        public String toString() {
            return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test022() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    Gson gson0 = new Gson();
    TypeAdapter<Boolean> typeAdapter0 = TypeAdapters.BOOLEAN_AS_STRING;
    TypeAdapterRuntimeTypeWrapper<Boolean> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<Boolean>(gson0, typeAdapter0, class0);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactoryForMultipleTypes(class0, (Class<? extends Boolean>) class0, (TypeAdapter<? super Boolean>) typeAdapterRuntimeTypeWrapper0);
    assertNotNull(typeAdapterFactory0);
}",""
"public static <T1> TypeAdapterFactory newTypeHierarchyFactory(final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
    return new TypeAdapterFactory() {

        @SuppressWarnings(""unchecked"")
        @Override
        public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
            final Class<? super T2> requestedType = typeToken.getRawType();
            if (!clazz.isAssignableFrom(requestedType)) {
                return null;
            }
            return (TypeAdapter<T2>) new TypeAdapter<T1>() {

                @Override
                public void write(JsonWriter out, T1 value) throws IOException {
                    typeAdapter.write(out, value);
                }

                @Override
                public T1 read(JsonReader in) throws IOException {
                    T1 result = typeAdapter.read(in);
                    if (result != null && !requestedType.isInstance(result)) {
                        throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName());
                    }
                    return result;
                }
            };
        }

        @Override
        public String toString() {
            return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]"";
        }
    };
}","public void test033() throws Throwable {
    Class<Character> class0 = Character.class;
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newTypeHierarchyFactory(class0, (TypeAdapter<Character>) null);
    assertNotNull(typeAdapterFactory0);
}","/**
 * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
 * that the deserialized type matches the type requested.
 */"
"public static <TT> TypeAdapterFactory newFactory(final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {
    return new TypeAdapterFactory() {

        // we use a runtime check to make sure the 'T's equal
        @SuppressWarnings(""unchecked"")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
            return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;
        }
    };
}","public void test044() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeToken<Object> typeToken0 = TypeToken.get(class0);
    Gson gson0 = new Gson();
    TypeAdapter<Object> typeAdapter0 = gson0.getAdapter(typeToken0);
    TypeAdapterFactory typeAdapterFactory0 = TypeAdapters.newFactory(typeToken0, typeAdapter0);
    assertNotNull(typeAdapterFactory0);
}",""
"public boolean isString() {
    return value instanceof String;
}","public void test055() throws Throwable {
    Gson gson0 = new Gson();
    Short short0 = new Short((short) 1);
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) short0);
    assertFalse(jsonPrimitive0.isString());
}","/**
 * Check whether this primitive contains a String value.
 *
 * @return true if this primitive contains a String value, false otherwise.
 */"
"public boolean isJsonArray() {
    return this instanceof JsonArray;
}","public void test066() throws Throwable {
    Gson gson0 = new Gson();
    InetAddress inetAddress0 = MockInetAddress.getByName(""BEGIN_OBJECT"");
    JsonElement jsonElement0 = gson0.toJsonTree((Object) inetAddress0);
    assertFalse(jsonElement0.isJsonArray());
}","/**
 * provides check for verifying if this element is an array or not.
 *
 * @return true if this element is of type {@link JsonArray}, false otherwise.
 */"
"public boolean isBoolean() {
    return value instanceof Boolean;
}","public void test077() throws Throwable {
    Gson gson0 = new Gson();
    Byte byte0 = new Byte((byte) 9);
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) byte0);
    assertFalse(jsonPrimitive0.isBoolean());
}","/**
 * Check whether this primitive contains a boolean value.
 *
 * @return true if this primitive contains a boolean value, false otherwise.
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test088() throws Throwable {
    Gson gson0 = new Gson();
    AtomicBoolean atomicBoolean0 = new AtomicBoolean(false);
    JsonElement jsonElement0 = gson0.toJsonTree((Object) atomicBoolean0);
    Class<JsonPrimitive> class0 = JsonPrimitive.class;
    JsonPrimitive jsonPrimitive0 = gson0.fromJson(jsonElement0, class0);
    assertNotSame(jsonElement0, jsonPrimitive0);
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test099() throws Throwable {
    Gson gson0 = new Gson();
    JsonArray jsonArray0 = new JsonArray();
    Class<AtomicInteger> class0 = AtomicInteger.class;
    try {
        gson0.fromJson((JsonElement) jsonArray0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected NUMBER but was BEGIN_ARRAY
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public boolean isJsonObject() {
    return this instanceof JsonObject;
}","public void test1010() throws Throwable {
    Gson gson0 = new Gson();
    AtomicInteger atomicInteger0 = new AtomicInteger(267);
    JsonElement jsonElement0 = gson0.toJsonTree((Object) atomicInteger0);
    assertFalse(jsonElement0.isJsonObject());
}","/**
 * provides check for verifying if this element is a Json object or not.
 *
 * @return true if this element is of type {@link JsonObject}, false otherwise.
 */"
"public boolean isJsonNull() {
    return this instanceof JsonNull;
}","public void test1111() throws Throwable {
    Gson gson0 = new Gson();
    Locale locale0 = Locale.CHINA;
    Currency currency0 = Currency.getInstance(locale0);
    JsonElement jsonElement0 = gson0.toJsonTree((Object) currency0);
    assertFalse(jsonElement0.isJsonNull());
}","/**
 * provides check for verifying if this element represents a null value or not.
 *
 * @return true if this element is of type {@link JsonNull}, false otherwise.
 * @since 1.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test1212() throws Throwable {
    Gson gson0 = new Gson();
    Class<Currency> class0 = Currency.class;
    TypeToken<Currency> typeToken0 = TypeToken.get(class0);
    Type type0 = typeToken0.getType();
    // Undeclared exception!
    try {
        gson0.fromJson(""duplicate"", type0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Currency"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test1313() throws Throwable {
    Class<BitSet> class0 = BitSet.class;
    Gson gson0 = new Gson();
    try {
        gson0.fromJson(""[hMu]="", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // Error: Expecting: bitset number value (1, 0), Found: hMu
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$6"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"public final T fromJson(String json) throws IOException {
    return fromJson(new StringReader(json));
}","public void test1414() throws Throwable {
    Gson gson0 = new Gson();
    Class<BitSet> class0 = BitSet.class;
    TypeAdapter<BitSet> typeAdapter0 = gson0.getAdapter(class0);
    TypeAdapterRuntimeTypeWrapper<BitSet> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<BitSet>(gson0, typeAdapter0, class0);
    BitSet bitSet0 = typeAdapterRuntimeTypeWrapper0.fromJson(""null"");
    assertNull(bitSet0);
}","/**
 * Converts the JSON document in {@code json} to a Java object. Unlike Gson's
 * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is
 * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code
 * JsonReader} and call {@link #read(JsonReader)} for lenient reading.
 *
 * @return the converted Java object. May be null.
 * @since 2.2
 */"
"public String toJson(Object src, Type typeOfSrc) {
    StringWriter writer = new StringWriter();
    toJson(src, typeOfSrc, writer);
    return writer.toString();
}","public void test1515() throws Throwable {
    Gson gson0 = new Gson();
    Class<BitSet> class0 = BitSet.class;
    String string0 = gson0.toJson((Object) null, (Type) class0);
    assertEquals(""null"", string0);
}","/**
 * This method serializes the specified object, including those of generic types, into its
 * equivalent Json representation. This method must be used if the specified object is a generic
 * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 *
 * @param src the object for which JSON representation is to be created
 * @param typeOfSrc The specific genericized type of src. You can obtain
 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 * to get the type for {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return Json representation of {@code src}
 */"
"public int size() {
    return elements.size();
}","public void test1616() throws Throwable {
    Gson gson0 = new Gson();
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 57;
    BitSet bitSet0 = BitSet.valueOf(byteArray0);
    JsonArray jsonArray0 = (JsonArray) gson0.toJsonTree((Object) bitSet0);
    assertEquals(6, jsonArray0.size());
}","/**
 * Returns the number of elements in the array.
 *
 * @return the number of elements in the array.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    return (T) fromJson(new JsonTreeReader(json), typeOfT);
}","public void test1717() throws Throwable {
    Gson gson0 = new Gson();
    JsonArray jsonArray0 = new JsonArray();
    Class<Boolean> class0 = Boolean.TYPE;
    try {
        gson0.fromJson((JsonElement) jsonArray0, (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected BOOLEAN but was BEGIN_ARRAY
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. This method is useful if the specified object is a generic type. For
 * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test1818() throws Throwable {
    Gson gson0 = new Gson();
    Class<Boolean> class0 = Boolean.TYPE;
    Long long0 = gson0.fromJson(""null"", (Type) class0);
    assertNull(long0);
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test1919() throws Throwable {
    Gson gson0 = new Gson();
    Class<Boolean> class0 = Boolean.TYPE;
    try {
        gson0.fromJson(""Error: Expecting: bitset number value (1, 0), Found: "", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 7 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"public String toJson(Object src, Type typeOfSrc) {
    StringWriter writer = new StringWriter();
    toJson(src, typeOfSrc, writer);
    return writer.toString();
}","public void test2020() throws Throwable {
    Gson gson0 = new Gson();
    Class<Boolean> class0 = Boolean.TYPE;
    String string0 = gson0.toJson((Object) null, (Type) class0);
    assertEquals(""null"", string0);
}","/**
 * This method serializes the specified object, including those of generic types, into its
 * equivalent Json representation. This method must be used if the specified object is a generic
 * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 *
 * @param src the object for which JSON representation is to be created
 * @param typeOfSrc The specific genericized type of src. You can obtain
 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 * to get the type for {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return Json representation of {@code src}
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2121() throws Throwable {
    Gson gson0 = new Gson();
    Class<Byte> class0 = Byte.TYPE;
    try {
        gson0.fromJson(""'wDTS'Xdd"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NumberFormatException: For input string: \""wDTS\""
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$9"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2222() throws Throwable {
    Gson gson0 = new Gson();
    Class<Short> class0 = Short.TYPE;
    try {
        gson0.fromJson(""com.google.gson.internal.LinkedTreeMap$Node"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NumberFormatException: For input string: \""com.google.gson.internal.LinkedTreeMap$Node\""
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$10"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2323() throws Throwable {
    Gson gson0 = new Gson();
    Class<Integer> class0 = Integer.TYPE;
    try {
        gson0.fromJson(""Error"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NumberFormatException: For input string: \""Error\""
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$11"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"public int size() {
    return elements.size();
}","public void test2424() throws Throwable {
    Gson gson0 = new Gson();
    int[] intArray0 = new int[1];
    AtomicIntegerArray atomicIntegerArray0 = new AtomicIntegerArray(intArray0);
    JsonArray jsonArray0 = (JsonArray) gson0.toJsonTree((Object) atomicIntegerArray0);
    assertEquals(1, jsonArray0.size());
}","/**
 * Returns the number of elements in the array.
 *
 * @return the number of elements in the array.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2525() throws Throwable {
    Gson gson0 = new Gson();
    Class<Long> class0 = Long.TYPE;
    try {
        gson0.fromJson(""Error: Expecting: bitset number value (1, 0), Found: "", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NumberFormatException: For input string: \""Error\""
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$12"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {
    boolean isEmpty = true;
    boolean oldLenient = reader.isLenient();
    reader.setLenient(true);
    try {
        reader.peek();
        isEmpty = false;
        TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);
        TypeAdapter<T> typeAdapter = getAdapter(typeToken);
        T object = typeAdapter.read(reader);
        return object;
    } catch (EOFException e) {
        /*
       * For compatibility with JSON 1.5 and earlier, we return null for empty
       * documents instead of throwing.
       */
        if (isEmpty) {
            return null;
        }
        throw new JsonSyntaxException(e);
    } catch (IllegalStateException e) {
        throw new JsonSyntaxException(e);
    } catch (IOException e) {
        // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
        throw new JsonSyntaxException(e);
    } finally {
        reader.setLenient(oldLenient);
    }
}","public void test2626() throws Throwable {
    Class<Long> class0 = Long.class;
    Gson gson0 = new Gson();
    StringReader stringReader0 = new StringReader(""null"");
    JsonReader jsonReader0 = new JsonReader(stringReader0);
    GregorianCalendar gregorianCalendar0 = gson0.fromJson(jsonReader0, (Type) class0);
    assertNull(gregorianCalendar0);
}","/**
 * Reads the next JSON value from {@code reader} and convert it to an object
 * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.
 * Since Type is not parameterized by T, this method is type unsafe and should be used carefully
 *
 * @throws JsonIOException if there was a problem writing to the Reader
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2727() throws Throwable {
    Gson gson0 = new Gson();
    Class<Character> class0 = Character.TYPE;
    try {
        gson0.fromJson(""H#L[a|Yce5}9{$~+j"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 3 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2828() throws Throwable {
    Gson gson0 = new Gson();
    Class<Character> class0 = Character.TYPE;
    Long long0 = gson0.fromJson(""null"", (Type) class0);
    assertNull(long0);
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test2929() throws Throwable {
    Gson gson0 = new Gson();
    Class<Character> class0 = Character.TYPE;
    try {
        gson0.fromJson(""yOvN cannTthn:udle"", (Type) class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // Expecting character, got: yOvN
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$16"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3030() throws Throwable {
    Gson gson0 = new Gson();
    Character character0 = Character.valueOf('2');
    JsonElement jsonElement0 = gson0.toJsonTree((Object) character0);
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    try {
        gson0.fromJson(jsonElement0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected BEGIN_OBJECT but was STRING
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public boolean isJsonNull() {
    return this instanceof JsonNull;
}","public void test3131() throws Throwable {
    Gson gson0 = new Gson();
    Class<Character> class0 = Character.TYPE;
    JsonElement jsonElement0 = gson0.toJsonTree((Object) null, (Type) class0);
    assertTrue(jsonElement0.isJsonNull());
}","/**
 * provides check for verifying if this element represents a null value or not.
 *
 * @return true if this element is of type {@link JsonNull}, false otherwise.
 * @since 1.2
 */"
"public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
    JsonReader jsonReader = newJsonReader(json);
    Object object = fromJson(jsonReader, classOfT);
    assertFullConsumption(object, jsonReader);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3232() throws Throwable {
    Gson gson0 = new Gson();
    StringReader stringReader0 = new StringReader(""wz4v"");
    Class<String> class0 = String.class;
    String string0 = gson0.fromJson((Reader) stringReader0, class0);
    assertEquals(""wz4v"", string0);
}","/**
 * This method deserializes the Json read from the specified reader into an object of the
 * specified class. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
 * {@link Reader}, use {@link #fromJson(String, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the reader producing the Json from which the object is to be deserialized.
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
 * @throws JsonIOException if there was a problem reading from the Reader
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * @since 1.2
 */"
"public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
    JsonReader jsonReader = newJsonReader(json);
    Object object = fromJson(jsonReader, classOfT);
    assertFullConsumption(object, jsonReader);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3333() throws Throwable {
    Gson gson0 = new Gson();
    StringReader stringReader0 = new StringReader(""null"");
    Class<String> class0 = String.class;
    String string0 = gson0.fromJson((Reader) stringReader0, class0);
    assertNull(string0);
}","/**
 * This method deserializes the Json read from the specified reader into an object of the
 * specified class. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
 * {@link Reader}, use {@link #fromJson(String, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the reader producing the Json from which the object is to be deserialized.
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
 * @throws JsonIOException if there was a problem reading from the Reader
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * @since 1.2
 */"
"public boolean isJsonPrimitive() {
    return this instanceof JsonPrimitive;
}","public void test3434() throws Throwable {
    Gson gson0 = new Gson();
    StringBuilder stringBuilder0 = new StringBuilder();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) stringBuilder0);
    assertTrue(jsonElement0.isJsonPrimitive());
}","/**
 * provides check for verifying if this element is a primitive or not.
 *
 * @return true if this element is of type {@link JsonPrimitive}, false otherwise.
 */"
"public boolean isString() {
    return value instanceof String;
}","public void test3535() throws Throwable {
    Gson gson0 = new Gson();
    StringBuffer stringBuffer0 = new StringBuffer();
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) stringBuffer0);
    assertTrue(jsonPrimitive0.isString());
}","/**
 * Check whether this primitive contains a String value.
 *
 * @return true if this primitive contains a String value, false otherwise.
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3636() throws Throwable {
    Gson gson0 = new Gson();
    Class<URL> class0 = URL.class;
    URL uRL0 = gson0.fromJson(""null"", class0);
    assertNull(uRL0);
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public boolean isBoolean() {
    return value instanceof Boolean;
}","public void test3737() throws Throwable {
    Gson gson0 = new Gson();
    URL uRL0 = MockURL.getFileExample();
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) uRL0);
    assertFalse(jsonPrimitive0.isBoolean());
}","/**
 * Check whether this primitive contains a boolean value.
 *
 * @return true if this primitive contains a boolean value, false otherwise.
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3838() throws Throwable {
    Gson gson0 = new Gson();
    Class<URI> class0 = URI.class;
    // Undeclared exception!
    try {
        gson0.fromJson("">X"", class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.net.URISyntaxException: Illegal character in path at index 0: >X
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$23"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test3939() throws Throwable {
    Gson gson0 = new Gson();
    Class<URI> class0 = URI.class;
    URI uRI0 = gson0.fromJson(""null"", class0);
    assertNull(uRI0);
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public boolean isJsonObject() {
    return this instanceof JsonObject;
}","public void test4040() throws Throwable {
    Gson gson0 = new Gson();
    URI uRI0 = MockURI.aHttpURI;
    JsonElement jsonElement0 = gson0.toJsonTree((Object) uRI0);
    assertFalse(jsonElement0.isJsonObject());
}","/**
 * provides check for verifying if this element is a Json object or not.
 *
 * @return true if this element is of type {@link JsonObject}, false otherwise.
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test4141() throws Throwable {
    Gson gson0 = new Gson();
    Class<InetAddress> class0 = InetAddress.class;
    try {
        gson0.fromJson(""yOvN cannTthn:udle"", class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 7 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test4242() throws Throwable {
    Gson gson0 = new Gson();
    Class<InetAddress> class0 = InetAddress.class;
    InetAddress inetAddress0 = gson0.fromJson(""null"", class0);
    assertNull(inetAddress0);
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public boolean isNumber() {
    return value instanceof Number;
}","public void test4343() throws Throwable {
    Gson gson0 = new Gson();
    UUID uUID0 = MockUUID.randomUUID();
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) uUID0);
    assertFalse(jsonPrimitive0.isNumber());
}","/**
 * Check whether this primitive contains a Number.
 *
 * @return true if this primitive contains a Number, false otherwise.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test4444() throws Throwable {
    Gson gson0 = new Gson();
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    Long long0 = gson0.fromJson(""null"", (Type) class0);
    assertNull(long0);
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"@SuppressWarnings(""unchecked"")
public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
    if (json == null) {
        return null;
    }
    StringReader reader = new StringReader(json);
    T target = (T) fromJson(reader, typeOfT);
    return target;
}","public void test4545() throws Throwable {
    Gson gson0 = new Gson();
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    TypeToken<GregorianCalendar> typeToken0 = TypeToken.get(class0);
    Class<? super GregorianCalendar> class1 = typeToken0.getRawType();
    try {
        gson0.fromJson(""{NM%K}.T\""]"", (Type) class1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Expected ':' at line 1 column 7 path $.NM%K
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified type. This method
 * is useful if the specified object is a generic type. For non-generic objects, use
 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Type)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 * {@code Collection<Foo>}, you should use:
 * <pre>
 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 * </pre>
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 */"
"public boolean isJsonNull() {
    return this instanceof JsonNull;
}","public void test4747() throws Throwable {
    Gson gson0 = new Gson();
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    TypeToken<GregorianCalendar> typeToken0 = TypeToken.get(class0);
    Class<? super GregorianCalendar> class1 = typeToken0.getRawType();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) null, (Type) class1);
    assertTrue(jsonElement0.isJsonNull());
}","/**
 * provides check for verifying if this element represents a null value or not.
 *
 * @return true if this element is of type {@link JsonNull}, false otherwise.
 * @since 1.2
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test4848() throws Throwable {
    Gson gson0 = new Gson();
    Class<Locale> class0 = Locale.class;
    try {
        gson0.fromJson(""(#U[\""@6Z~.2"", class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 3 path $
        //
        verifyException(""com.google.gson.Gson"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test4949() throws Throwable {
    Class<Locale> class0 = Locale.class;
    Gson gson0 = new Gson();
    // Undeclared exception!
    try {
        gson0.fromJson(""_"", class0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Locale"", e);
    }
}","/**
 * This method deserializes the specified Json into an object of the specified class. It is not
 * suitable to use if the specified class is a generic type since it will not have the generic
 * type information because of the Type Erasure feature of Java. Therefore, this method should not
 * be used if the desired type is a generic type. Note that this method works fine if the any of
 * the fields of the specified object are generics, just the object itself should not be a
 * generic type. For the cases when the object is of generic type, invoke
 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 * a String, use {@link #fromJson(Reader, Class)} instead.
 *
 * @param <T> the type of the desired object
 * @param json the string from which the object is to be deserialized
 * @param classOfT the class of T
 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type
 * classOfT
 */"
"public boolean isString() {
    return value instanceof String;
}","public void test5050() throws Throwable {
    Gson gson0 = new Gson();
    Locale locale0 = Locale.UK;
    JsonPrimitive jsonPrimitive0 = (JsonPrimitive) gson0.toJsonTree((Object) locale0);
    assertTrue(jsonPrimitive0.isString());
}","/**
 * Check whether this primitive contains a String value.
 *
 * @return true if this primitive contains a String value, false otherwise.
 */"
"public final T fromJson(String json) throws IOException {
    return fromJson(new StringReader(json));
}","public void test5151() throws Throwable {
    Gson gson0 = new Gson();
    Class<BitSet> class0 = BitSet.class;
    TypeToken<BitSet> typeToken0 = TypeToken.get(class0);
    JsonDeserializer<BitSet> jsonDeserializer0 = (JsonDeserializer<BitSet>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(jsonDeserializer0).deserialize(any(com.google.gson.JsonElement.class), any(java.lang.reflect.Type.class), any(com.google.gson.JsonDeserializationContext.class));
    TreeTypeAdapter<BitSet> treeTypeAdapter0 = new TreeTypeAdapter<BitSet>((JsonSerializer<BitSet>) null, jsonDeserializer0, gson0, typeToken0, (TypeAdapterFactory) null);
    TypeAdapterRuntimeTypeWrapper<BitSet> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<BitSet>(gson0, treeTypeAdapter0, class0);
    BitSet bitSet0 = typeAdapterRuntimeTypeWrapper0.fromJson(""6}UK%^^[\""Ku"");
    assertNull(bitSet0);
}","/**
 * Converts the JSON document in {@code json} to a Java object. Unlike Gson's
 * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is
 * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code
 * JsonReader} and call {@link #read(JsonReader)} for lenient reading.
 *
 * @return the converted Java object. May be null.
 * @since 2.2
 */"
"public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
    Object object = fromJson(json, (Type) classOfT);
    return Primitives.wrap(classOfT).cast(object);
}","public void test5252() throws Throwable {
    Gson gson0 = new Gson();
    JsonObject jsonObject0 = new JsonObject();
    Class<JsonPrimitive> class0 = JsonPrimitive.class;
    try {
        gson0.fromJson((JsonElement) jsonObject0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // Expected a com.google.gson.JsonPrimitive but was com.google.gson.JsonObject
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$35$1"", e);
    }
}","/**
 * This method deserializes the Json read from the specified parse tree into an object of the
 * specified type. It is not suitable to use if the specified class is a generic type since it
 * will not have the generic type information because of the Type Erasure feature of Java.
 * Therefore, this method should not be used if the desired type is a generic type. Note that
 * this method works fine if the any of the fields of the specified object are generics, just the
 * object itself should not be a generic type. For the cases when the object is of generic type,
 * invoke {@link #fromJson(JsonElement, Type)}.
 * @param <T> the type of the desired object
 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 * be deserialized
 * @param classOfT The class of T
 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 * @since 1.3
 */"
"public boolean isBoolean() {
    return value instanceof Boolean;
}","public void test5353() throws Throwable {
    Gson gson0 = new Gson();
    Character character0 = Character.valueOf('_');
    JsonPrimitive jsonPrimitive0 = new JsonPrimitive(character0);
    Class<JsonPrimitive> class0 = JsonPrimitive.class;
    JsonPrimitive jsonPrimitive1 = gson0.fromJson((JsonElement) jsonPrimitive0, class0);
    assertFalse(jsonPrimitive1.isBoolean());
}","/**
 * Check whether this primitive contains a boolean value.
 *
 * @return true if this primitive contains a boolean value, false otherwise.
 */"
"public final T fromJson(String json) throws IOException {
    return fromJson(new StringReader(json));
}","public void test5454() throws Throwable {
    Gson gson0 = new Gson();
    Class<GregorianCalendar> class0 = GregorianCalendar.class;
    Class<BitSet> class1 = BitSet.class;
    TypeToken<BitSet> typeToken0 = TypeToken.get(class1);
    JsonDeserializer<BitSet> jsonDeserializer0 = (JsonDeserializer<BitSet>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    TreeTypeAdapter<BitSet> treeTypeAdapter0 = new TreeTypeAdapter<BitSet>((JsonSerializer<BitSet>) null, jsonDeserializer0, gson0, typeToken0, (TypeAdapterFactory) null);
    TypeAdapterRuntimeTypeWrapper<BitSet> typeAdapterRuntimeTypeWrapper0 = new TypeAdapterRuntimeTypeWrapper<BitSet>(gson0, treeTypeAdapter0, class0);
    BitSet bitSet0 = typeAdapterRuntimeTypeWrapper0.fromJson(""null"");
    assertNull(bitSet0);
}","/**
 * Converts the JSON document in {@code json} to a Java object. Unlike Gson's
 * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is
 * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code
 * JsonReader} and call {@link #read(JsonReader)} for lenient reading.
 *
 * @return the converted Java object. May be null.
 * @since 2.2
 */"
"public String toJson(JsonElement jsonElement) {
    StringWriter writer = new StringWriter();
    toJson(jsonElement, writer);
    return writer.toString();
}","public void test5555() throws Throwable {
    Gson gson0 = new Gson();
    String string0 = gson0.toJson((JsonElement) null);
    assertEquals(""null"", string0);
}","/**
 * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
 *
 * @param jsonElement root of a tree of {@link JsonElement}s
 * @return JSON String representation of the tree
 * @since 1.4
 */"
"public boolean isJsonNull() {
    return this instanceof JsonNull;
}","public void test5656() throws Throwable {
    Gson gson0 = new Gson();
    JsonNull jsonNull0 = JsonNull.INSTANCE;
    JsonElement jsonElement0 = gson0.toJsonTree((Object) jsonNull0);
    assertTrue(jsonElement0.isJsonNull());
}","/**
 * provides check for verifying if this element represents a null value or not.
 *
 * @return true if this element is of type {@link JsonNull}, false otherwise.
 * @since 1.2
 */"
"public boolean isJsonPrimitive() {
    return this instanceof JsonPrimitive;
}","public void test5757() throws Throwable {
    Gson gson0 = new Gson();
    JsonElement jsonElement0 = gson0.toJsonTree((Object) gson0);
    assertFalse(jsonElement0.isJsonPrimitive());
}","/**
 * provides check for verifying if this element is a primitive or not.
 *
 * @return true if this element is of type {@link JsonPrimitive}, false otherwise.
 */"
"public JsonElement toJsonTree(Object src) {
    if (src == null) {
        return JsonNull.INSTANCE;
    }
    return toJsonTree(src, src.getClass());
}","public void test5858() throws Throwable {
    ObjectConstructor<Short> objectConstructor0 = (ObjectConstructor<Short>) mock(ObjectConstructor.class, new ViolatedAssumptionAnswer());
    Gson gson0 = new Gson();
    // Undeclared exception!
    try {
        gson0.toJsonTree((Object) objectConstructor0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Attempted to serialize java.lang.Class: com.google.gson.internal.ObjectConstructor. Forgot to register a type adapter?
        //
        verifyException(""com.google.gson.internal.bind.TypeAdapters$5"", e);
    }
}","/**
 * This method serializes the specified object into its equivalent representation as a tree of
 * {@link JsonElement}s. This method should be used when the specified object is not a generic
 * type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 * the {@code getClass()} loses the generic type information because of the Type Erasure feature
 * of Java. Note that this method works fine if the any of the object fields are of generic type,
 * just the object itself should not be of a generic type. If the object is of generic type, use
 * {@link #toJsonTree(Object, Type)} instead.
 *
 * @param src the object for which Json representation is to be created setting for Gson
 * @return Json representation of {@code src}.
 * @since 1.4
 */"
"public <T> TypeAdapter<T> getAdapter(Class<T> type) {
    return getAdapter(TypeToken.get(type));
}","public void test5959() throws Throwable {
    Gson gson0 = new Gson();
    Class<Calendar> class0 = Calendar.class;
    TypeAdapter<Calendar> typeAdapter0 = gson0.getAdapter(class0);
    assertNotNull(typeAdapter0);
}","/**
 * Returns the type adapter for {@code} type.
 *
 * @throws IllegalArgumentException if this GSON cannot serialize and
 *     deserialize {@code type}.
 */"
