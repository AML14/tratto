focal_method,test_prefix,docstring
"/*
    /**********************************************************
    /* Formatting
    /**********************************************************
     */
/**
 * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
 *
 * @param date the date to format
 * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'
 */
public static String format(Date date) {
    return format(date, false, TIMEZONE_UTC);
}","public void test022() throws Throwable {
    MockDate mockDate0 = new MockDate(60000, 60000, 60000, 16, 16);
    String string0 = ISO8601Utils.format((Date) mockDate0);
    assertEquals(""67064-04-10T16:16:00Z"", string0);
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test033() throws Throwable {
    // Undeclared exception!
    try {
        ISO8601Utils.parse(""MM"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"public static String format(Date date, boolean millis, TimeZone tz) {
    Calendar calendar = new GregorianCalendar(tz, Locale.US);
    calendar.setTime(date);
    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
    int capacity = ""yyyy-MM-ddThh:mm:ss"".length();
    capacity += millis ? "".sss"".length() : 0;
    capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length();
    StringBuilder formatted = new StringBuilder(capacity);
    padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length());
    formatted.append('T');
    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length());
    if (millis) {
        formatted.append('.');
        padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length());
    }
    int offset = tz.getOffset(calendar.getTimeInMillis());
    if (offset != 0) {
        int hours = Math.abs((offset / (60 * 1000)) / 60);
        int minutes = Math.abs((offset / (60 * 1000)) % 60);
        formatted.append(offset < 0 ? '-' : '+');
        padInt(formatted, hours, ""hh"".length());
        formatted.append(':');
        padInt(formatted, minutes, ""mm"".length());
    } else {
        formatted.append('Z');
    }
    return formatted.toString();
}","public void test044() throws Throwable {
    MockDate mockDate0 = new MockDate(3903L);
    // Undeclared exception!
    try {
        ISO8601Utils.format((Date) mockDate0, true, (TimeZone) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @param tz timezone to use for the formatting (UTC will produce 'Z')
 * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 */"
"public static String format(Date date, boolean millis) {
    return format(date, millis, TIMEZONE_UTC);
}","public void test055() throws Throwable {
    // Undeclared exception!
    try {
        ISO8601Utils.format((Date) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}","/**
 * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'
 */"
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test066() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(1);
    try {
        ISO8601Utils.parse(""-00:00"", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""-00:00']: Invalid number: 00:0
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test077() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(0);
    try {
        ISO8601Utils.parse(""Mismatching time zone indicator: "", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""Mismatching time zone indicator: ']: Invalid number: Mism
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test088() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(2147483645);
    try {
        ISO8601Utils.parse(""4"", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""4']: 4
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test099() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(3);
    try {
        ISO8601Utils.parse("""", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""']: (java.lang.NumberFormatException)
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test1010() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition((-1201));
    try {
        ISO8601Utils.parse((String) null, parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [null]: (java.lang.NumberFormatException)
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test1111() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(0);
    ISO8601Utils.parse(""3938-06-04T16:18:16.000Z"", parsePosition0);
    try {
        ISO8601Utils.parse(""Mismatching time zone indicator: "", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""Mismatching time zone indicator: ']: Invalid number: dica
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"/*
    /**********************************************************
    /* Parsing
    /**********************************************************
     */
/**
 * Parse a date from ISO-8601 formatted string. It expects a format
 * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
 *
 * @param date ISO string to parse in the appropriate format.
 * @param pos The position to start parsing from, updated to where parsing stopped.
 * @return the parsed date
 * @throws ParseException if the date is not in the appropriate format
 */
public static Date parse(String date, ParsePosition pos) throws ParseException {
    Exception fail = null;
    try {
        int offset = pos.getIndex();
        // extract year
        int year = parseInt(date, offset, offset += 4);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract month
        int month = parseInt(date, offset, offset += 2);
        if (checkOffset(date, offset, '-')) {
            offset += 1;
        }
        // extract day
        int day = parseInt(date, offset, offset += 2);
        // default time value
        int hour = 0;
        int minutes = 0;
        int seconds = 0;
        // always use 0 otherwise returned date will include millis of current time
        int milliseconds = 0;
        // if the value has no time component (and no time zone), we are done
        boolean hasT = checkOffset(date, offset, 'T');
        if (!hasT && (date.length() <= offset)) {
            Calendar calendar = new GregorianCalendar(year, month - 1, day);
            pos.setIndex(offset);
            return calendar.getTime();
        }
        if (hasT) {
            // extract hours, minutes, seconds and milliseconds
            hour = parseInt(date, offset += 1, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            minutes = parseInt(date, offset, offset += 2);
            if (checkOffset(date, offset, ':')) {
                offset += 1;
            }
            // second and milliseconds can be optional
            if (date.length() > offset) {
                char c = date.charAt(offset);
                if (c != 'Z' && c != '+' && c != '-') {
                    seconds = parseInt(date, offset, offset += 2);
                    // truncate up to 3 leap seconds
                    if (seconds > 59 && seconds < 63)
                        seconds = 59;
                    // milliseconds can be optional in the format
                    if (checkOffset(date, offset, '.')) {
                        offset += 1;
                        // assume at least one digit
                        int endOffset = indexOfNonDigit(date, offset + 1);
                        // parse up to 3 digits
                        int parseEndOffset = Math.min(endOffset, offset + 3);
                        int fraction = parseInt(date, offset, parseEndOffset);
                        // compensate for ""missing"" digits
                        switch(// number of digits parsed
                        parseEndOffset - offset) {
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                        }
                        offset = endOffset;
                    }
                }
            }
        }
        // extract timezone
        if (date.length() <= offset) {
            throw new IllegalArgumentException(""No time zone indicator"");
        }
        TimeZone timezone = null;
        char timezoneIndicator = date.charAt(offset);
        if (timezoneIndicator == 'Z') {
            timezone = TIMEZONE_UTC;
            offset += 1;
        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
            String timezoneOffset = date.substring(offset);
            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
            offset += timezoneOffset.length();
            // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
            if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {
                timezone = TIMEZONE_UTC;
            } else {
                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
                //    not sure why, but that's the way it looks. Further, Javadocs for
                //    `java.util.TimeZone` specifically instruct use of GMT as base for
                //    custom timezones... odd.
                String timezoneId = ""GMT"" + timezoneOffset;
                //                    String timezoneId = ""UTC"" + timezoneOffset;
                timezone = TimeZone.getTimeZone(timezoneId);
                String act = timezone.getID();
                if (!act.equals(timezoneId)) {
                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
                         *    one without. If so, don't sweat.
                         *   Yes, very inefficient. Hopefully not hit often.
                         *   If it becomes a perf problem, add 'loose' comparison instead.
                         */
                    String cleaned = act.replace("":"", """");
                    if (!cleaned.equals(timezoneId)) {
                        throw new IndexOutOfBoundsException(""Mismatching time zone indicator: "" + timezoneId + "" given, resolves to "" + timezone.getID());
                    }
                }
            }
        } else {
            throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator + ""'"");
        }
        Calendar calendar = new GregorianCalendar(timezone);
        calendar.setLenient(false);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, seconds);
        calendar.set(Calendar.MILLISECOND, milliseconds);
        pos.setIndex(offset);
        return calendar.getTime();
        // If we get a ParseException it'll already have the right message/offset.
        // Other exception types can convert here.
    } catch (IndexOutOfBoundsException e) {
        fail = e;
    } catch (NumberFormatException e) {
        fail = e;
    } catch (IllegalArgumentException e) {
        fail = e;
    }
    String input = (date == null) ? null : ('""' + date + ""'"");
    String msg = fail.getMessage();
    if (msg == null || msg.isEmpty()) {
        msg = ""("" + fail.getClass().getName() + "")"";
    }
    ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex());
    ex.initCause(fail);
    throw ex;
}","public void test1313() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(1);
    try {
        ISO8601Utils.parse(""+0000"", parsePosition0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Failed to parse date [\""+0000']: +0000
        //
        verifyException(""com.google.gson.internal.bind.util.ISO8601Utils"", e);
    }
}",""
"public static String format(Date date, boolean millis, TimeZone tz) {
    Calendar calendar = new GregorianCalendar(tz, Locale.US);
    calendar.setTime(date);
    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
    int capacity = ""yyyy-MM-ddThh:mm:ss"".length();
    capacity += millis ? "".sss"".length() : 0;
    capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length();
    StringBuilder formatted = new StringBuilder(capacity);
    padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length());
    formatted.append('T');
    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length());
    if (millis) {
        formatted.append('.');
        padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length());
    }
    int offset = tz.getOffset(calendar.getTimeInMillis());
    if (offset != 0) {
        int hours = Math.abs((offset / (60 * 1000)) / 60);
        int minutes = Math.abs((offset / (60 * 1000)) % 60);
        formatted.append(offset < 0 ? '-' : '+');
        padInt(formatted, hours, ""hh"".length());
        formatted.append(':');
        padInt(formatted, minutes, ""mm"".length());
    } else {
        formatted.append('Z');
    }
    return formatted.toString();
}","public void test1414() throws Throwable {
    MockDate mockDate0 = new MockDate(1, 1, 1);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(1, ""1901-02-01T00:00:00Z"");
    String string0 = ISO8601Utils.format((Date) mockDate0, false, (TimeZone) simpleTimeZone0);
    assertEquals(""1901-02-01T00:00:00+00:00"", string0);
}","/**
 * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @param tz timezone to use for the formatting (UTC will produce 'Z')
 * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 */"
"public static String format(Date date, boolean millis, TimeZone tz) {
    Calendar calendar = new GregorianCalendar(tz, Locale.US);
    calendar.setTime(date);
    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
    int capacity = ""yyyy-MM-ddThh:mm:ss"".length();
    capacity += millis ? "".sss"".length() : 0;
    capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length();
    StringBuilder formatted = new StringBuilder(capacity);
    padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length());
    formatted.append('T');
    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length());
    if (millis) {
        formatted.append('.');
        padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length());
    }
    int offset = tz.getOffset(calendar.getTimeInMillis());
    if (offset != 0) {
        int hours = Math.abs((offset / (60 * 1000)) / 60);
        int minutes = Math.abs((offset / (60 * 1000)) % 60);
        formatted.append(offset < 0 ? '-' : '+');
        padInt(formatted, hours, ""hh"".length());
        formatted.append(':');
        padInt(formatted, minutes, ""mm"".length());
    } else {
        formatted.append('Z');
    }
    return formatted.toString();
}","public void test1515() throws Throwable {
    MockDate mockDate0 = new MockDate((-48), (-48), (-48), (-48), (-48), (-48));
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-48), ""1847-11-10T23:11:12Z"");
    String string0 = ISO8601Utils.format((Date) mockDate0, true, (TimeZone) simpleTimeZone0);
    assertEquals(""1847-11-10T23:11:11.952-00:00"", string0);
}","/**
 * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @param tz timezone to use for the formatting (UTC will produce 'Z')
 * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 */"
"public static String format(Date date, boolean millis, TimeZone tz) {
    Calendar calendar = new GregorianCalendar(tz, Locale.US);
    calendar.setTime(date);
    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
    int capacity = ""yyyy-MM-ddThh:mm:ss"".length();
    capacity += millis ? "".sss"".length() : 0;
    capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length();
    StringBuilder formatted = new StringBuilder(capacity);
    padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length());
    formatted.append('-');
    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length());
    formatted.append('T');
    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length());
    formatted.append(':');
    padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length());
    if (millis) {
        formatted.append('.');
        padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length());
    }
    int offset = tz.getOffset(calendar.getTimeInMillis());
    if (offset != 0) {
        int hours = Math.abs((offset / (60 * 1000)) / 60);
        int minutes = Math.abs((offset / (60 * 1000)) % 60);
        formatted.append(offset < 0 ? '-' : '+');
        padInt(formatted, hours, ""hh"".length());
        formatted.append(':');
        padInt(formatted, minutes, ""mm"".length());
    } else {
        formatted.append('Z');
    }
    return formatted.toString();
}","public void test1616() throws Throwable {
    MockDate mockDate0 = new MockDate(2254, (-2123), 2254, (-2123), (-496));
    TimeZone timeZone0 = TimeZone.getDefault();
    String string0 = ISO8601Utils.format((Date) mockDate0, true, timeZone0);
    assertEquals(""3983-01-05T04:44:00.000Z"", string0);
}","/**
 * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @param tz timezone to use for the formatting (UTC will produce 'Z')
 * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
 */"
"public static String format(Date date, boolean millis) {
    return format(date, millis, TIMEZONE_UTC);
}","public void test1717() throws Throwable {
    MockDate mockDate0 = new MockDate(2254, (-2123), 2254, (-2123), (-496));
    String string0 = ISO8601Utils.format((Date) mockDate0, false);
    assertEquals(""3983-01-05T04:44:00Z"", string0);
}","/**
 * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)
 *
 * @param date the date to format
 * @param millis true to include millis precision otherwise false
 * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'
 */"
"/*
    /**********************************************************
    /* Formatting
    /**********************************************************
     */
/**
 * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
 *
 * @param date the date to format
 * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'
 */
public static String format(Date date) {
    return format(date, false, TIMEZONE_UTC);
}","public void test1919() throws Throwable {
    // Undeclared exception!
    try {
        ISO8601Utils.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}",""
