focal_method,test_prefix,docstring
"public double getDeterminant() {
    double determinant = 1.0;
    for (int i = 0; i < lTData.length; ++i) {
        double lTii = lTData[i][i];
        determinant *= lTii * lTii;
    }
    return determinant;
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 1.0E-12, (-124.6528351558643));
    double double0 = choleskyDecompositionImpl0.getDeterminant();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1.0;
    for (int i = 0; i < lTData.length; ++i) {
        double lTii = lTData[i][i];
        determinant *= lTii * lTii;
    }
    return determinant;
}","public void test011() throws Throwable {
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl();
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0, (-1183.6668903126), (-1183.6668903126));
    double double0 = choleskyDecompositionImpl0.getDeterminant();
    assertEquals(1.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getL() {
    if (cachedL == null) {
        cachedL = getLT().transpose();
    }
    return cachedL;
}","public void test022() throws Throwable {
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl();
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0, (-1183.6668903126), (-1183.6668903126));
    // Undeclared exception!
    try {
        choleskyDecompositionImpl0.getL();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.DenseRealMatrix"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test033() throws Throwable {
    DenseRealMatrix denseRealMatrix0 = new DenseRealMatrix(2468, 2468);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(denseRealMatrix0, 0.0, 1805.616172939);
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test044() throws Throwable {
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl((RealMatrix) null, (-1010.877599918819), 2270.84505827051);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test055() throws Throwable {
    double[] doubleArray0 = new double[0];
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl(doubleArray0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0, (-1.0), 0.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test066() throws Throwable {
    DenseRealMatrix denseRealMatrix0 = new DenseRealMatrix(2504, 2504);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(denseRealMatrix0);
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test077() throws Throwable {
    double[] doubleArray0 = new double[0];
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl(doubleArray0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public RealMatrix getLT() {
    if (cachedLT == null) {
        cachedLT = MatrixUtils.createRealMatrix(lTData);
    }
    // return the cached matrix
    return cachedLT;
}","public void test088() throws Throwable {
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl();
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0, (-1183.6668903126), (-1183.6668903126));
    // Undeclared exception!
    try {
        choleskyDecompositionImpl0.getLT();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.DenseRealMatrix"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test099() throws Throwable {
    double[] doubleArray0 = new double[5];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1605.74765799);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(openMapRealMatrix0, 1.0, 3.1431336163519293E-9);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // not positive definite matrix
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test1010() throws Throwable {
    double[] doubleArray0 = new double[7];
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl(doubleArray0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0, (-1518.7014536), (-1939.9482595484867));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // a 7x1 matrix was provided instead of a square matrix
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test1111() throws Throwable {
    RealMatrixImpl realMatrixImpl0 = new RealMatrixImpl();
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrixImpl0);
    assertEquals(1.0E-10, CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD, 0.01);
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public double getDeterminant() {
    double determinant = 1.0;
    for (int i = 0; i < lTData.length; ++i) {
        double lTii = lTData[i][i];
        determinant *= lTii * lTii;
    }
    return determinant;
}","public void test1212() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 0.0, 0.0);
    double double0 = choleskyDecompositionImpl0.getDeterminant();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"double getFrobeniusNorm();","public void test1313() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 0.0, 0.0);
    choleskyDecompositionImpl0.getL();
    RealMatrix realMatrix1 = choleskyDecompositionImpl0.getLT();
    assertEquals(Double.NaN, realMatrix1.getFrobeniusNorm(), 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/FrobeniusNorm.html"">
 * Frobenius norm</a> of the matrix.
 *
 * @return norm
 */"
"double getFrobeniusNorm();","public void test1414() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 0.0, 0.0);
    choleskyDecompositionImpl0.getL();
    RealMatrix realMatrix1 = choleskyDecompositionImpl0.getL();
    assertEquals(Double.NaN, realMatrix1.getFrobeniusNorm(), 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/FrobeniusNorm.html"">
 * Frobenius norm</a> of the matrix.
 *
 * @return norm
 */"
"public RealMatrix getL() {
    if (cachedL == null) {
        cachedL = getLT().transpose();
    }
    return cachedL;
}","public void test1415() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 0.0, 0.0);
    choleskyDecompositionImpl0.getL();
    RealMatrix realMatrix1 = choleskyDecompositionImpl0.getL();
    assertNotNull(realMatrix1);
}","/**
 * {@inheritDoc}
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    if (!matrix.isSquare()) {
        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
    }
    final int order = matrix.getRowDimension();
    lTData = matrix.getData();
    cachedL = null;
    cachedLT = null;
    // check the matrix before transformation
    for (int i = 0; i < order; ++i) {
        final double[] lI = lTData[i];
        if (lTData[i][i] < absolutePositivityThreshold) {
            throw new NotPositiveDefiniteMatrixException();
        }
        // check off-diagonal elements (and reset them to 0)
        for (int j = i + 1; j < order; ++j) {
            final double[] lJ = lTData[j];
            final double lIJ = lI[j];
            final double lJI = lJ[i];
            final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
            if (Math.abs(lIJ - lJI) > maxDelta) {
                throw new NotSymmetricMatrixException();
            }
            lJ[i] = 0;
        }
    }
    // transform the matrix
    for (int i = 0; i < order; ++i) {
        final double[] ltI = lTData[i];
        // check diagonal element
        ltI[i] = Math.sqrt(ltI[i]);
        final double inverse = 1.0 / ltI[i];
        for (int q = order - 1; q > i; --q) {
            ltI[q] *= inverse;
            final double[] ltQ = lTData[q];
            for (int p = q; p < order; ++p) {
                ltQ[p] -= ltI[q] * ltI[p];
            }
        }
    }
}","public void test1516() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 3140.30398224132;
    doubleArray0[4] = 3140.30398224132;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 3140.30398224132);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(openMapRealMatrix0, (-1992.2776373530703), 3140.30398224132);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // not symmetric matrix
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * @param matrix the matrix to decompose
 * @param relativeSymmetryThreshold threshold above which off-diagonal
 * elements are considered too different and matrix not symmetric
 * @param absolutePositivityThreshold threshold below which diagonal
 * elements are considered null and matrix not positive definite
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test1617() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // not positive definite matrix
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test1718() throws Throwable {
    OpenMapRealMatrix openMapRealMatrix0 = new OpenMapRealMatrix(2146438111, 382);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(openMapRealMatrix0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // a 2,146,438,111x382 matrix was provided instead of a square matrix
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
"public double getDeterminant() {
    double determinant = 1.0;
    for (int i = 0; i < lTData.length; ++i) {
        double lTii = lTData[i][i];
        determinant *= lTii * lTii;
    }
    return determinant;
}","public void test1819() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct((RealVector) openMapRealVector0);
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = new CholeskyDecompositionImpl(realMatrix0, 0.0, 0.0);
    choleskyDecompositionImpl0.getSolver();
    assertEquals(Double.NaN, choleskyDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public CholeskyDecompositionImpl(final RealMatrix matrix) throws NonSquareMatrixException, NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
    this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
}","public void test1920() throws Throwable {
    CholeskyDecompositionImpl choleskyDecompositionImpl0 = null;
    try {
        choleskyDecompositionImpl0 = new CholeskyDecompositionImpl((RealMatrix) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.CholeskyDecompositionImpl"", e);
    }
}","/**
 * Calculates the Cholesky decomposition of the given matrix.
 * <p>
 * Calling this constructor is equivalent to call {@link
 * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the
 * thresholds set to the default values {@link
 * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link
 * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}
 * </p>
 * @param matrix the matrix to decompose
 * @exception NonSquareMatrixException if matrix is not square
 * @exception NotSymmetricMatrixException if matrix is not symmetric
 * @exception NotPositiveDefiniteMatrixException if the matrix is not
 * strictly positive definite
 * @see #CholeskyDecompositionImpl(RealMatrix, double, double)
 * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
 * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
 */"
