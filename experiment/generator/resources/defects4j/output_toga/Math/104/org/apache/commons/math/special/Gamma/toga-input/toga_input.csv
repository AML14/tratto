focal_method,test_prefix,docstring
"public static double regularizedGammaQ(double a, double x) throws MathException {
    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test000() throws Throwable {
    Gamma.regularizedGammaQ(0.0, (double) 3494);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function Q(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test011() throws Throwable {
    try {
        Gamma.regularizedGammaP(0.9999559702915715, 3.6899182659531625E-6, 3.6899182659531625E-6, 0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Maximal number of iterations (0) exceeded
        //
        verifyException(""org.apache.commons.math.special.Gamma"", e);
    }
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x) throws MathException {
    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test022() throws Throwable {
    Gamma.regularizedGammaP(1.0, 6.283185307179586);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x) throws MathException {
    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test033() throws Throwable {
    Gamma.regularizedGammaP(0.0, 2978.238);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test044() throws Throwable {
    Gamma.logGamma(0.0);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test055() throws Throwable {
    Gamma.regularizedGammaQ(622.8906486212, 9997.0, 9990.0, 1800);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(double a, double x) throws MathException {
    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test066() throws Throwable {
    Gamma.regularizedGammaQ(509.93820562505, 2978.238);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function Q(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test077() throws Throwable {
    Gamma.logGamma(2.0);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test088() throws Throwable {
    Gamma.logGamma(1.0);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test099() throws Throwable {
    // Undeclared exception!
    Gamma.regularizedGammaQ(0.5, 0.5, (-914.4947086760305), Integer.MAX_VALUE);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(double a, double x) throws MathException {
    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test1010() throws Throwable {
    // Undeclared exception!
    Gamma.regularizedGammaQ(1.0E-8, 1233.7072874555);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function Q(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test1111() throws Throwable {
    // Undeclared exception!
    Gamma.regularizedGammaP(1.0E-8, 4.652362892704858E-5, (-1109.29), Integer.MAX_VALUE);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x) throws MathException {
    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test1212() throws Throwable {
    // Undeclared exception!
    Gamma.regularizedGammaP(1.0E-8, 1184.443523678873);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test1313() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(1.7976931348623157E308, 2872.3, 14.136097974741746, 1701);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test1414() throws Throwable {
    try {
        Gamma.regularizedGammaQ(0.4007030019962433, 0.4007030019962433, 0.4007030019962433, (-5));
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Maximal number of iterations (-5) exceeded
        //
        verifyException(""org.apache.commons.math.special.Gamma"", e);
    }
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test1515() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(Double.NaN, 0.0, Double.NaN, Integer.MAX_VALUE);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test1616() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(1.7976931348623157E308, Double.NaN, (-2270.0977526), 2144888736);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test1717() throws Throwable {
    double double0 = Gamma.regularizedGammaP(1.7976931348623157E308, 891.739, 0.0, Integer.MAX_VALUE);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test1818() throws Throwable {
    double double0 = Gamma.regularizedGammaP(9951.0, 9968.0, Double.NaN, 660);
    assertEquals((-1.1790540527652342), double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test1919() throws Throwable {
    double double0 = Gamma.regularizedGammaP(293.348, 293.348, Double.NaN, 2999);
    assertEquals(0.023286012546278472, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test2020() throws Throwable {
    double double0 = Gamma.regularizedGammaP(0.49650146359570896, 0.0, (-1509.1051739439213), 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test2121() throws Throwable {
    double double0 = Gamma.regularizedGammaP(Double.NaN, 0.0, (-9.837447530487956E-5), (-1189));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test2222() throws Throwable {
    double double0 = Gamma.logGamma(3.399464998481189E-5);
    assertEquals(10.289287777823304, double0, 0.01);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
"public static double regularizedGammaQ(double a, double x) throws MathException {
    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test2323() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(2386.74403743, 1.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function Q(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test2424() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(0.8294376532046004, 0.0, 1440.30126582, Integer.MAX_VALUE);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test2525() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(793.257550644769, (-0.02456460149525469), (double) (-1), (-1));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 1.0;
    } else if (x < a || a < 1.0) {
        // use regularizedGammaP because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
    } else {
        // create continued fraction
        ContinuedFraction cf = new ContinuedFraction() {

            private static final long serialVersionUID = 5378525034886164398L;

            protected double getA(int n, double x) {
                return ((2.0 * n) + 1.0) - a + x;
            }

            protected double getB(int n, double x) {
                return n * (a - n);
            }
        };
        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
        ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
    }
    return ret;
}","public void test2626() throws Throwable {
    double double0 = Gamma.regularizedGammaQ((-2799.8316867812), 11.0, 11.0, 2672);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
 * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaQ(double a, double x) throws MathException {
    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test2727() throws Throwable {
    double double0 = Gamma.regularizedGammaQ(0.5401112953400191, 425.9);
    assertEquals((-1.8207657603852567E-14), double0, 0.01);
}","/**
 * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function Q(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x) throws MathException {
    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
}","public void test2828() throws Throwable {
    double double0 = Gamma.regularizedGammaP((double) 660, 0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * @param a the a parameter.
 * @param x the value.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test2929() throws Throwable {
    double double0 = Gamma.regularizedGammaP(0.9999999999999971, (-298.0), 0.9999999999999971, 2672);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test3030() throws Throwable {
    double double0 = Gamma.regularizedGammaP((-1.0), 1.0E-8, 9989.0, 660);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) throws MathException {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
        ret = Double.NaN;
    } else if (x == 0.0) {
        ret = 0.0;
    } else if (a >= 1.0 && x > a) {
        // use regularizedGammaQ because it should converge faster in this
        // case.
        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
    } else {
        // calculate series
        // current element index
        double n = 0.0;
        // n-th element in the series
        double an = 1.0 / a;
        // partial sum
        double sum = an;
        while (Math.abs(an) > epsilon && n < maxIterations) {
            // compute next element in the series
            n = n + 1.0;
            an = an * (x / (a + n));
            // update partial sum
            sum = sum + an;
        }
        if (n >= maxIterations) {
            throw new MaxIterationsExceededException(maxIterations);
        } else {
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
        }
    }
    return ret;
}","public void test3131() throws Throwable {
    double double0 = Gamma.regularizedGammaP((double) 3494, Double.NaN, Double.NaN, 3494);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the regularized gamma function P(a, x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
 * Regularized Gamma Function</a>, equation (1).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
 * Incomplete Gamma Function</a>, equation (4).</li>
 * <li>
 * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
 * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
 * </li>
 * </ul>
 *
 * @param a the a parameter.
 * @param x the value.
 * @param epsilon When the absolute value of the nth item in the
 *                series is less than epsilon the approximation ceases
 *                to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized gamma function P(a, x)
 * @throws MathException if the algorithm fails to converge.
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test3232() throws Throwable {
    double double0 = Gamma.logGamma((-3133.12394639));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
"public static double logGamma(double x) {
    double ret;
    if (Double.isNaN(x) || (x <= 0.0)) {
        ret = Double.NaN;
    } else {
        double g = 607.0 / 128.0;
        double sum = 0.0;
        for (int i = lanczos.length - 1; i > 0; --i) {
            sum = sum + (lanczos[i] / (x + i));
        }
        sum = sum + lanczos[0];
        double tmp = x + g + .5;
        ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);
    }
    return ret;
}","public void test3333() throws Throwable {
    double double0 = Gamma.logGamma(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the natural logarithm of the gamma function &#915;(x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
 * Gamma Function</a>, equation (28).</li>
 * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
 * Lanczos Approximation</a>, equations (1) through (5).</li>
 * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma approximation
 * </a></li>
 * </ul>
 *
 * @param x the value.
 * @return log(&#915;(x))
 */"
