focal_method,test_prefix,docstring
"public DormandPrince853Integrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince853StepInterpolator(), minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
}","public void test000() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertNotNull(dormandPrince853Integrator0);
}","/**
 * Simple constructor.
 * Build an eighth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test001() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test002() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getSafety() {
    return safety;
}","public void test003() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test004() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test005() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(1772.9071, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test006() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test007() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(1393.2544714988815, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test008() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(1094.9011498412, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test009() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test0010() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test0011() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test0013() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(1772.9071, (-1094.9011498412), 1772.9071, (-1094.9011498412));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[6];
    double[] doubleArray1 = new double[5];
    try {
        dormandPrince853Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 808.516339212, doubleArray0, 0.0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 0
        //
        verifyException(""org.apache.commons.math.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public DormandPrince54Integrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince54StepInterpolator(), minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
}","public void test0114() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertNotNull(dormandPrince54Integrator0);
}","/**
 * Simple constructor.
 * Build a fifth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0115() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(0.0012326388888888888, dormandPrince54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0116() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(0.0012326388888888888, dormandPrince54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test0117() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(10.0, dormandPrince54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public String getName() {
    return name;
}","public void test0118() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(""Dormand-Prince 5(4)"", dormandPrince54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test0119() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(5, dormandPrince54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test0120() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(0.9, dormandPrince54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test0121() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(0.2, dormandPrince54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test0122() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(0.0012326388888888888, dormandPrince54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0123() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    assertEquals(Double.NaN, dormandPrince54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test0124() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    double[] doubleArray0 = new double[1];
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(104).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test0125() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    double[] doubleArray0 = new double[1];
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(104).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(208, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test0126() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0012326388888888888, 0.0012326388888888888, 1677.095072, 1677.095072);
    double[] doubleArray0 = new double[1];
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(104).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    try {
        dormandPrince54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0012326388888888888, doubleArray0, 684.7876108027, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1 != 208
        //
        verifyException(""org.apache.commons.math.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public GraggBulirschStoerIntegrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
    setStabilityCheck(true, -1, -1, -1);
    setStepsizeControl(-1, -1, -1, -1);
    setOrderControl(-1, -1, -1);
    setInterpolationControl(true, -1);
}","public void test0227() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertNotNull(graggBulirschStoerIntegrator0);
}","/**
 * Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMinStep() {
    return minStep;
}","public void test0228() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertEquals(1582.4, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0229() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0230() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertEquals(1.0, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public String getName() {
    return name;
}","public void test0231() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0232() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    assertEquals(39.77939164944582, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test0233() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    assertEquals(1582.4, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0234() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0235() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    assertEquals(1.0, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public String getName() {
    return name;
}","public void test0236() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0237() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    assertEquals(39.77939164944582, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return evaluations.getMaximalCount();
}","public void test0238() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test0239() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(1582.4, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0240() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0241() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(1.0, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public String getName() {
    return name;
}","public void test0242() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0243() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1582.4, (-1.0), 0.0, 2527.1915914585);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(39.77939164944582, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public DormandPrince853Integrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince853StepInterpolator(), minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
}","public void test0344() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertNotNull(dormandPrince853Integrator0);
}","/**
 * Simple constructor.
 * Build an eighth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0345() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(0.0, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0346() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(0.0, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0347() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test0348() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test0349() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test0350() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test0351() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test0352() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(0.0, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test0353() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0354() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0355() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.0, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0356() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.0, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0357() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test0358() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test0359() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test0360() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test0361() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test0362() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(0.0, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test0363() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 0.0, 0.0, 0.0);
    double double0 = dormandPrince853Integrator0.getCurrentSignedStepsize();
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public HighamHall54Integrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, false, STATIC_C, STATIC_A, STATIC_B, new HighamHall54StepInterpolator(), minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
}","public void test0464() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertNotNull(highamHall54Integrator0);
}","/**
 * Simple constructor.
 * Build a fifth order Higham and Hall integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test0465() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(10.0, highamHall54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0466() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(1093.2452929, highamHall54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test0467() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(5, highamHall54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test0468() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(0.9, highamHall54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0469() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(1093.2452929, highamHall54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test0470() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(0.2, highamHall54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0471() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(Double.NaN, highamHall54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test0472() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(1093.2452929, highamHall54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test0473() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    assertEquals(""Higham-Hall 5(4)"", highamHall54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0474() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(1093.2452929, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test0475() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(10.0, highamHall54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0476() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(1093.2452929, highamHall54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test0477() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(5, highamHall54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test0478() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(0.9, highamHall54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0479() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(1093.2452929, highamHall54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test0480() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(0.2, highamHall54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0481() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(Double.NaN, highamHall54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test0482() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(1093.2452929, highamHall54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test0483() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-1093.2452929), (-1093.2452929), (-1093.2452929), 6275.5009334442775);
    double double0 = highamHall54Integrator0.getCurrentSignedStepsize();
    assertEquals(""Higham-Hall 5(4)"", highamHall54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public GraggBulirschStoerIntegrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
    setStabilityCheck(true, -1, -1, -1);
    setStepsizeControl(-1, -1, -1, -1);
    setOrderControl(-1, -1, -1);
    setInterpolationControl(true, -1);
}","public void test0584() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertNotNull(graggBulirschStoerIntegrator0);
}","/**
 * Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test0585() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertEquals(565.845047803, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0586() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertEquals(565.845047803, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test0587() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test0588() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertEquals(565.845047803, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test0589() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test0590() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test0591() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-565.845047803), (-565.845047803), (-1083.406), 330.933267253787);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public ThreeEighthesIntegrator(final double step) {
    super(""3/8"", STATIC_C, STATIC_A, STATIC_B, new ThreeEighthesStepInterpolator(), step);
}","public void test0692() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    assertNotNull(threeEighthesIntegrator0);
}","/**
 * Simple constructor.
 * Build a 3/8 integrator with the given step.
 * @param step integration step
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test0693() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test0694() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test0695() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test0696() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test0697() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test0698() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-414.3));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    // Undeclared exception!
    try {
        threeEighthesIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 1000.0, (double[]) null, 1000.0, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public DormandPrince853Integrator(final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince853StepInterpolator(), minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
}","public void test0799() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(3, doubleArray0.length);
}","/**
 * Simple constructor.
 * Build an eighth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test07102() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test07103() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test07104() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test07105() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public String getName() {
    return name;
}","public void test07106() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test07107() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test07108() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test07109() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test07110() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test07111() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test07112() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {
    final int n = primary.getDimension();
    this.primary = primary;
    this.primaryMapper = new EquationsMapper(0, n);
    this.time = Double.NaN;
    this.primaryState = new double[n];
    this.primaryStateDot = new double[n];
    this.components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();
}","public void test07113() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertNotNull(expandableStatefulODE0);
}","/**
 * Build an expandable set from its primary ODE set.
 * @param primary the primary set of differential equations to be integrated.
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test07114() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getTime() {
    return time;
}","public void test07115() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(Double.NaN, expandableStatefulODE0.getTime(), 0.01);
}","/**
 * Get current time.
 * @return current time
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = new double[y.length];
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    setStateInitialized(false);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test07116() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    try {
        dormandPrince853Integrator0.integrate(expandableStatefulODE0, (-1.0));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 != 3
        //
        verifyException(""org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public ThreeEighthesIntegrator(final double step) {
    super(""3/8"", STATIC_C, STATIC_A, STATIC_B, new ThreeEighthesStepInterpolator(), step);
}","public void test08117() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    assertNotNull(threeEighthesIntegrator0);
}","/**
 * Simple constructor.
 * Build a 3/8 integrator with the given step.
 * @param step integration step
 */"
"public String getName() {
    return name;
}","public void test08118() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test08119() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test08120() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test08121() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.setMaxEvaluations(0);
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test08122() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.setMaxEvaluations(0);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test08123() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.setMaxEvaluations(0);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException {
    evaluations.incrementCount();
    expandable.computeDerivatives(t, y, yDot);
}","public void test08124() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.setMaxEvaluations(0);
    double[] doubleArray0 = new double[1];
    try {
        threeEighthesIntegrator0.computeDerivatives(804.250840028896, doubleArray0, doubleArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded
        //
        verifyException(""org.apache.commons.math.util.Incrementor$1"", e);
    }
}","/**
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 */"
"public DormandPrince853Integrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince853StepInterpolator(), minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
}","public void test09125() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertNotNull(dormandPrince853Integrator0);
}","/**
 * Simple constructor.
 * Build an eighth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMinStep() {
    return minStep;
}","public void test09126() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(0.0, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test09127() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test09128() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(3.141592653589793, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public String getName() {
    return name;
}","public void test09129() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test09130() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test09131() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test09132() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test09133() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test09134() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    assertEquals(0.0, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test09135() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(0.0, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test09136() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test09137() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(3.141592653589793, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public String getName() {
    return name;
}","public void test09138() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test09139() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test09140() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test09141() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test09142() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test09143() throws Throwable {
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, 3.141592653589793, 3.141592653589793, 0.0);
    dormandPrince853Integrator0.setMaxEvaluations((-822));
    assertEquals(0.0, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public ThreeEighthesIntegrator(final double step) {
    super(""3/8"", STATIC_C, STATIC_A, STATIC_B, new ThreeEighthesStepInterpolator(), step);
}","public void test10144() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    assertNotNull(threeEighthesIntegrator0);
}","/**
 * Simple constructor.
 * Build a 3/8 integrator with the given step.
 * @param step integration step
 */"
"public String getName() {
    return name;
}","public void test10145() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test10146() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test10147() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test10148() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, 1344.57060599318, (-622.4274438751), 9, (UnivariateRealSolver) null);
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test10149() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, 1344.57060599318, (-622.4274438751), 9, (UnivariateRealSolver) null);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test10150() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, 1344.57060599318, (-622.4274438751), 9, (UnivariateRealSolver) null);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public EulerIntegrator(final double step) {
    super(""Euler"", STATIC_C, STATIC_A, STATIC_B, new EulerStepInterpolator(), step);
}","public void test11151() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    assertNotNull(eulerIntegrator0);
}","/**
 * Simple constructor.
 * Build an Euler integrator with the given step.
 * @param step integration step
 */"
"public String getName() {
    return name;
}","public void test11152() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    assertEquals(""Euler"", eulerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test11153() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test11154() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public StepNormalizer(final double h, final FixedStepHandler handler, final StepNormalizerMode mode) {
    this(h, handler, mode, StepNormalizerBounds.FIRST);
}","public void test11155() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    FixedStepHandler fixedStepHandler0 = mock(FixedStepHandler.class, new ViolatedAssumptionAnswer());
    StepNormalizerMode stepNormalizerMode0 = StepNormalizerMode.MULTIPLES;
    StepNormalizer stepNormalizer0 = new StepNormalizer(1942.7446384883, fixedStepHandler0, stepNormalizerMode0);
    assertNotNull(stepNormalizer0);
}","/**
 * Simple constructor. Uses {@link StepNormalizerBounds#FIRST FIRST}
 * bounds setting.
 * @param h fixed time step (sign is not used)
 * @param handler fixed time step handler to wrap
 * @param mode step normalizer mode to use
 * @since 3.0
 */"
"public String getName() {
    return name;
}","public void test11156() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    FixedStepHandler fixedStepHandler0 = mock(FixedStepHandler.class, new ViolatedAssumptionAnswer());
    StepNormalizerMode stepNormalizerMode0 = StepNormalizerMode.MULTIPLES;
    StepNormalizer stepNormalizer0 = new StepNormalizer(1942.7446384883, fixedStepHandler0, stepNormalizerMode0);
    eulerIntegrator0.addStepHandler(stepNormalizer0);
    assertEquals(""Euler"", eulerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test11157() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    FixedStepHandler fixedStepHandler0 = mock(FixedStepHandler.class, new ViolatedAssumptionAnswer());
    StepNormalizerMode stepNormalizerMode0 = StepNormalizerMode.MULTIPLES;
    StepNormalizer stepNormalizer0 = new StepNormalizer(1942.7446384883, fixedStepHandler0, stepNormalizerMode0);
    eulerIntegrator0.addStepHandler(stepNormalizer0);
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test11158() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(1.0);
    FixedStepHandler fixedStepHandler0 = mock(FixedStepHandler.class, new ViolatedAssumptionAnswer());
    StepNormalizerMode stepNormalizerMode0 = StepNormalizerMode.MULTIPLES;
    StepNormalizer stepNormalizer0 = new StepNormalizer(1942.7446384883, fixedStepHandler0, stepNormalizerMode0);
    eulerIntegrator0.addStepHandler(stepNormalizer0);
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException {
    evaluations.incrementCount();
    expandable.computeDerivatives(t, y, yDot);
}","public void test12163() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    double[] doubleArray0 = new double[1];
    // Undeclared exception!
    try {
        threeEighthesIntegrator0.computeDerivatives(804.250840028896, doubleArray0, doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 */"
"public DormandPrince54Integrator(final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince54StepInterpolator(), minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
}","public void test13164() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(0, doubleArray0.length);
}","/**
 * Simple constructor.
 * Build a fifth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */"
"public String getName() {
    return name;
}","public void test13167() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(""Dormand-Prince 5(4)"", dormandPrince54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test13168() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(419.342263060406, dormandPrince54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test13169() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(Double.NaN, dormandPrince54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test13170() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(0.2, dormandPrince54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test13171() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(5, dormandPrince54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test13172() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(903.4061955756142, dormandPrince54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSafety() {
    return safety;
}","public void test13173() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(0.9, dormandPrince54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test13174() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(1946.24493188, dormandPrince54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test13175() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    assertEquals(10.0, dormandPrince54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test13176() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test13177() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test13178() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(419.342263060406, 1946.24493188, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    try {
        dormandPrince54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (double) 5, doubleArray0, (double) 5, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // too small integration interval: length = 0
        //
        verifyException(""org.apache.commons.math.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public AdamsBashforthIntegrator(final int nSteps, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) throws IllegalArgumentException {
    super(METHOD_NAME, nSteps, nSteps, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
}","public void test14179() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(0, doubleArray0.length);
}","/**
 * Build an Adams-Bashforth integrator with the given order and step control parameters.
 * @param nSteps number of steps of the method excluding the one being computed
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 * @exception IllegalArgumentException if order is 1 or less
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test14182() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(0.2, adamsBashforthIntegrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test14183() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(0.9, adamsBashforthIntegrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test14184() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(Double.NaN, adamsBashforthIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test14185() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(893.080324795, adamsBashforthIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test14186() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(893.080324795, adamsBashforthIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test14187() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(1.0905077326652577, adamsBashforthIntegrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public String getName() {
    return name;
}","public void test14188() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(""Adams-Bashforth"", adamsBashforthIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test14189() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    assertEquals(893.080324795, adamsBashforthIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test14190() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test14191() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {
    final int n = primary.getDimension();
    this.primary = primary;
    this.primaryMapper = new EquationsMapper(0, n);
    this.time = Double.NaN;
    this.primaryState = new double[n];
    this.primaryStateDot = new double[n];
    this.components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();
}","public void test14192() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertNotNull(expandableStatefulODE0);
}","/**
 * Build an expandable set from its primary ODE set.
 * @param primary the primary set of differential equations to be integrated.
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test14193() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getTime() {
    return time;
}","public void test14194() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(Double.NaN, expandableStatefulODE0.getTime(), 0.01);
}","/**
 * Get current time.
 * @return current time
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > equations.getTime();
    // initialize working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final double[] yDot = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
    interpolator.reinitialize(y, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    // set up integration control objects
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    setStateInitialized(false);
    // compute the initial Nordsieck vector using the configured starter integrator
    start(equations.getTime(), y, t);
    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
    interpolator.storeTime(stepStart);
    final int lastRow = nordsieck.getRowDimension() - 1;
    // reuse the step that was chosen by the starter integrator
    double hNew = stepSize;
    interpolator.rescale(hNew);
    // main integration loop
    isLastStep = false;
    do {
        double error = 10;
        while (error >= 1.0) {
            stepSize = hNew;
            // evaluate error using the last term of the Taylor expansion
            error = 0;
            for (int i = 0; i < mainSetDimension; ++i) {
                final double yScale = FastMath.abs(y[i]);
                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
                final double ratio = nordsieck.getEntry(lastRow, i) / tol;
                error += ratio * ratio;
            }
            error = FastMath.sqrt(error / mainSetDimension);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = computeStepGrowShrinkFactor(error);
                hNew = filterStep(stepSize * factor, forward, false);
                interpolator.rescale(hNew);
            }
        }
        // predict a first estimate of the state at step end
        final double stepEnd = stepStart + stepSize;
        interpolator.shift();
        interpolator.setInterpolatedTime(stepEnd);
        System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
        // evaluate the derivative
        computeDerivatives(stepEnd, y, yDot);
        // update Nordsieck vector
        final double[] predictedScaled = new double[y0.length];
        for (int j = 0; j < y0.length; ++j) {
            predictedScaled[j] = stepSize * yDot[j];
        }
        final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
        updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);
        interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);
        // discrete events handling
        interpolator.storeTime(stepEnd);
        stepStart = acceptStep(interpolator, y, yDot, t);
        scaled = predictedScaled;
        nordsieck = nordsieckTmp;
        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (resetOccurred) {
                // some events handler has triggered changes that
                // invalidate the derivatives, we need to restart from scratch
                start(stepStart, y, t);
                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
            }
            // stepsize control for next step
            final double factor = computeStepGrowShrinkFactor(error);
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
            interpolator.rescale(hNew);
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test14195() throws Throwable {
    double[] doubleArray0 = new double[0];
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(8, 893.080324795, 893.080324795, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    try {
        adamsBashforthIntegrator0.integrate(expandableStatefulODE0, (-2428.4));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix must have at least one column
        //
        verifyException(""org.apache.commons.math.linear.Array2DRowRealMatrix"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public GraggBulirschStoerIntegrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
    setStabilityCheck(true, -1, -1, -1);
    setStepsizeControl(-1, -1, -1, -1);
    setOrderControl(-1, -1, -1);
    setInterpolationControl(true, -1);
}","public void test15196() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertNotNull(graggBulirschStoerIntegrator0);
}","/**
 * Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test15197() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test15198() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertEquals(3396.3176252791, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test15199() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test15200() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test15201() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test15202() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test15203() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test15204() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test15205() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    assertEquals(3396.3176252791, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test15206() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test15207() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test15208() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {
    final int n = primary.getDimension();
    this.primary = primary;
    this.primaryMapper = new EquationsMapper(0, n);
    this.time = Double.NaN;
    this.primaryState = new double[n];
    this.primaryStateDot = new double[n];
    this.components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();
}","public void test15209() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertNotNull(expandableStatefulODE0);
}","/**
 * Build an expandable set from its primary ODE set.
 * @param primary the primary set of differential equations to be integrated.
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test15210() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getTime() {
    return time;
}","public void test15211() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-3396.3176252791), Double.NaN, (-1568.24962368321), (-1568.24962368321));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    graggBulirschStoerIntegrator0.addEventHandler(eventHandler0, Double.NaN, 2166.82, 0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(Double.NaN, expandableStatefulODE0.getTime(), 0.01);
}","/**
 * Get current time.
 * @return current time
 */"
"public MidpointIntegrator(final double step) {
    super(""midpoint"", STATIC_C, STATIC_A, STATIC_B, new MidpointStepInterpolator(), step);
}","public void test16212() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    assertNotNull(midpointIntegrator0);
}","/**
 * Simple constructor.
 * Build a midpoint integrator with the given step.
 * @param step integration step
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test16213() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test16214() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test16215() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    assertEquals(""midpoint"", midpointIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test16216() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test16217() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test16218() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 330.933267253787, doubleArray0);
    assertEquals(0, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test16221() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 330.933267253787, doubleArray0);
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test16222() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 330.933267253787, doubleArray0);
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test16223() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 330.933267253787, doubleArray0);
    assertEquals(""midpoint"", midpointIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test16224() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-588.160007279939));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 330.933267253787, doubleArray0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public GraggBulirschStoerIntegrator(final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {
    super(METHOD_NAME, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
    setStabilityCheck(true, -1, -1, -1);
    setStepsizeControl(-1, -1, -1, -1);
    setOrderControl(-1, -1, -1);
    setInterpolationControl(true, -1);
}","public void test17225() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertNotNull(graggBulirschStoerIntegrator0);
}","/**
 * Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param scalAbsoluteTolerance allowed absolute error
 * @param scalRelativeTolerance allowed relative error
 */"
"public double getMinStep() {
    return minStep;
}","public void test17226() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertEquals(588.160007279939, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test17227() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertEquals(330.933267253787, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test17228() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertEquals(441.1821765180019, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test17229() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test17230() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test17231() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    graggBulirschStoerIntegrator0.setMaxEvaluations(544);
    assertEquals(588.160007279939, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test17232() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    graggBulirschStoerIntegrator0.setMaxEvaluations(544);
    assertEquals(330.933267253787, graggBulirschStoerIntegrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test17233() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    graggBulirschStoerIntegrator0.setMaxEvaluations(544);
    assertEquals(441.1821765180019, graggBulirschStoerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test17234() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    graggBulirschStoerIntegrator0.setMaxEvaluations(544);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test17235() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator((-588.160007279939), 330.933267253787, 3443.0337974, 330.933267253787);
    graggBulirschStoerIntegrator0.setMaxEvaluations(544);
    assertEquals(""Gragg-Bulirsch-Stoer"", graggBulirschStoerIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public DormandPrince853Integrator(final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {
    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince853StepInterpolator(), minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
}","public void test18236() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(0, doubleArray0.length);
}","/**
 * Simple constructor.
 * Build an eighth order Dormand-Prince integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test18239() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test18240() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(844.63099033, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test18241() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test18242() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public String getName() {
    return name;
}","public void test18243() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test18244() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(844.63099033, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test18245() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test18246() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(844.63099033, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test18247() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {
    addEventHandler(handler, maxCheckInterval, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5));
}","public void test18248() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(0, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test18250() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test18251() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(844.63099033, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test18252() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test18253() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public String getName() {
    return name;
}","public void test18254() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test18255() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(844.63099033, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test18256() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test18257() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(844.63099033, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test18258() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public Collection<EventHandler> getEventHandlers() {
    final List<EventHandler> list = new ArrayList<EventHandler>();
    for (EventState state : eventsStates) {
        list.add(state.getEventHandler());
    }
    return Collections.unmodifiableCollection(list);
}","public void test18260() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(0, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test18263() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test18264() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(844.63099033, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test18265() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test18266() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public String getName() {
    return name;
}","public void test18267() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test18268() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(844.63099033, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test18269() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test18270() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(844.63099033, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test18271() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(844.63099033, 844.63099033, doubleArray0, doubleArray0);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(eventHandler0).toString();
    dormandPrince853Integrator0.addEventHandler(eventHandler0, 844.63099033, 0.0, 782);
    Collection<EventHandler> collection0 = dormandPrince853Integrator0.getEventHandlers();
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test19276() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.clearEventHandlers();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test19277() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.clearEventHandlers();
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test19278() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    threeEighthesIntegrator0.clearEventHandlers();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test20283() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.clearStepHandlers();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test20284() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.clearStepHandlers();
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test20285() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.clearStepHandlers();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return evaluations.getMaximalCount();
}","public void test21290() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    int int0 = threeEighthesIntegrator0.getMaxEvaluations();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test21291() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    int int0 = threeEighthesIntegrator0.getMaxEvaluations();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test21292() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    int int0 = threeEighthesIntegrator0.getMaxEvaluations();
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test21293() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    int int0 = threeEighthesIntegrator0.getMaxEvaluations();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public Collection<StepHandler> getStepHandlers() {
    return Collections.unmodifiableCollection(stepHandlers);
}","public void test22306() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(3, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test22309() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(Double.NaN, dormandPrince853Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test22310() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(""Dormand-Prince 8 (5, 3)"", dormandPrince853Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test22311() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test22312() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(10.0, dormandPrince853Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test22313() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getSafety() {
    return safety;
}","public void test22314() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(0.9, dormandPrince853Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public double getMinStep() {
    return minStep;
}","public void test22315() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(2918.610019620804, dormandPrince853Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test22316() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(0.2, dormandPrince853Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"@Override
public int getOrder() {
    return 8;
}","public void test22317() throws Throwable {
    double[] doubleArray0 = new double[3];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(2918.610019620804, 2918.610019620804, doubleArray0, doubleArray0);
    Collection<StepHandler> collection0 = dormandPrince853Integrator0.getStepHandlers();
    assertEquals(8, dormandPrince853Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public ThreeEighthesIntegrator(final double step) {
    super(""3/8"", STATIC_C, STATIC_A, STATIC_B, new ThreeEighthesStepInterpolator(), step);
}","public void test23318() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    assertNotNull(threeEighthesIntegrator0);
}","/**
 * Simple constructor.
 * Build a 3/8 integrator with the given step.
 * @param step integration step
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test23319() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test23320() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test23321() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test23322() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    double double0 = threeEighthesIntegrator0.getCurrentStepStart();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test23323() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    double double0 = threeEighthesIntegrator0.getCurrentStepStart();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test23324() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    double double0 = threeEighthesIntegrator0.getCurrentStepStart();
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test23325() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(519.5);
    double double0 = threeEighthesIntegrator0.getCurrentStepStart();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public HighamHall54Integrator(final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {
    super(METHOD_NAME, false, STATIC_C, STATIC_A, STATIC_B, new HighamHall54StepInterpolator(), minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
}","public void test24326() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(8, doubleArray0.length);
}","/**
 * Simple constructor.
 * Build a fifth order Higham and Hall integrator with the given step bounds
 * @param minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test24329() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(Double.NaN, highamHall54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test24330() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(5, highamHall54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test24331() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(590.3, highamHall54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMinStep() {
    return minStep;
}","public void test24332() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(590.3, highamHall54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test24333() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(10.0, highamHall54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public String getName() {
    return name;
}","public void test24334() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(""Higham-Hall 5(4)"", highamHall54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test24335() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(590.3, highamHall54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test24336() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(0.2, highamHall54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test24337() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    assertEquals(0.9, highamHall54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public String getName() {
    return name;
}","public void test24338() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(8, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test24342() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(Double.NaN, highamHall54Integrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getOrder() {
    return 5;
}","public void test24343() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(5, highamHall54Integrator0.getOrder());
}","/**
 * {@inheritDoc}
 */"
"public double getMaxStep() {
    return maxStep;
}","public void test24344() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(590.3, highamHall54Integrator0.getMaxStep(), 0.01);
}","/**
 * Get the maximal step.
 * @return maximal step
 */"
"public double getMinStep() {
    return minStep;
}","public void test24345() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(590.3, highamHall54Integrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public double getMaxGrowth() {
    return maxGrowth;
}","public void test24346() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(10.0, highamHall54Integrator0.getMaxGrowth(), 0.01);
}","/**
 * Get the maximal growth factor for stepsize control.
 * @return maximal growth factor
 */"
"public String getName() {
    return name;
}","public void test24347() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(""Higham-Hall 5(4)"", highamHall54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test24348() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(590.3, highamHall54Integrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMinReduction() {
    return minReduction;
}","public void test24349() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(0.2, highamHall54Integrator0.getMinReduction(), 0.01);
}","/**
 * Get the minimal reduction factor for stepsize control.
 * @return minimal reduction factor
 */"
"public double getSafety() {
    return safety;
}","public void test24350() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(590.3, 590.3, doubleArray0, doubleArray0);
    String string0 = highamHall54Integrator0.getName();
    assertEquals(0.9, highamHall54Integrator0.getSafety(), 0.01);
}","/**
 * Get the safety factor for stepsize control.
 * @return safety factor
 */"
"public int getEvaluations() {
    return evaluations.getCount();
}","public void test25355() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    int int0 = threeEighthesIntegrator0.getEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test25356() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    int int0 = threeEighthesIntegrator0.getEvaluations();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test25357() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    int int0 = threeEighthesIntegrator0.getEvaluations();
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public String getName() {
    return name;
}","public void test25358() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    int int0 = threeEighthesIntegrator0.getEvaluations();
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test26363() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test26364() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {
    final int n = primary.getDimension();
    this.primary = primary;
    this.primaryMapper = new EquationsMapper(0, n);
    this.time = Double.NaN;
    this.primaryState = new double[n];
    this.primaryStateDot = new double[n];
    this.components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();
}","public void test26365() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertNotNull(expandableStatefulODE0);
}","/**
 * Build an expandable set from its primary ODE set.
 * @param primary the primary set of differential equations to be integrated.
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test26366() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getTime() {
    return time;
}","public void test26367() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(Double.NaN, expandableStatefulODE0.getTime(), 0.01);
}","/**
 * Get current time.
 * @return current time
 */"
"public String getName() {
    return name;
}","public void test27372() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    assertEquals(""3/8"", threeEighthesIntegrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test27373() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test27374() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    assertEquals(Double.NaN, threeEighthesIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public FirstOrderConverter(final SecondOrderDifferentialEquations equations) {
    this.equations = equations;
    dimension = equations.getDimension();
    z = new double[dimension];
    zDot = new double[dimension];
    zDDot = new double[dimension];
}","public void test27375() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertNotNull(firstOrderConverter0);
}","/**
 * Simple constructor.
 * Build a converter around a second order equations set.
 * @param equations second order equations set to convert
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test27376() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {
    final int n = primary.getDimension();
    this.primary = primary;
    this.primaryMapper = new EquationsMapper(0, n);
    this.time = Double.NaN;
    this.primaryState = new double[n];
    this.primaryStateDot = new double[n];
    this.components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();
}","public void test27377() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertNotNull(expandableStatefulODE0);
}","/**
 * Build an expandable set from its primary ODE set.
 * @param primary the primary set of differential equations to be integrated.
 */"
"public int getDimension() {
    return 2 * dimension;
}","public void test27378() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(0, firstOrderConverter0.getDimension());
}","/**
 * Get the dimension of the problem.
 * <p>The dimension of the first order problem is twice the
 * dimension of the underlying second order problem.</p>
 * @return dimension of the problem
 */"
"public double getTime() {
    return time;
}","public void test27379() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    assertEquals(Double.NaN, expandableStatefulODE0.getTime(), 0.01);
}","/**
 * Get current time.
 * @return current time
 */"
"public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
    final double[] yDotTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    setStateInitialized(false);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // first stage
        computeDerivatives(stepStart, y, yDotK[0]);
        // next stages
        for (int k = 1; k < stages; ++k) {
            for (int j = 0; j < y0.length; ++j) {
                double sum = a[k - 1][0] * yDotK[0][j];
                for (int l = 1; l < k; ++l) {
                    sum += a[k - 1][l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
        }
        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
            double sum = b[0] * yDotK[0][j];
            for (int l = 1; l < stages; ++l) {
                sum += b[l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
        }
        // discrete events handling
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            // stepsize control for next step
            final double nextT = stepStart + stepSize;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            if (nextIsLast) {
                stepSize = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    stepStart = Double.NaN;
    stepSize = Double.NaN;
}","public void test27380() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator((-622.4274438751));
    threeEighthesIntegrator0.addEventHandler((EventHandler) null, (-1.0), (-1.0), 2699);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    // Undeclared exception!
    try {
        threeEighthesIntegrator0.integrate(expandableStatefulODE0, (-2736.06));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.ode.events.EventState"", e);
    }
}","/**
 * {@inheritDoc}
 */"
