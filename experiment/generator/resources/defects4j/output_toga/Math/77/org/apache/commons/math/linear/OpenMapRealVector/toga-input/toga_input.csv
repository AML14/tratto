focal_method,test_prefix,docstring
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(0.0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test001() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(0.0);
    assertEquals(7, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test002() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(0.0);
    assertEquals(6, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test013() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue((-30));
    double double0 = openMapRealVector1.dotProduct(openMapRealVector0);
    assertEquals((-0.03333333333333333), openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test014() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue((-30));
    double double0 = openMapRealVector1.dotProduct(openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * Iterates over the smaller of the two.
 * @param v The vector to compute the dot product with
 * @return The dot product of <code>this</code> and <code>v</code>
 * @throws IllegalArgumentException If the dimensions don't match
 */"
"public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test025() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    // Undeclared exception!
    try {
        openMapRealVector0.unitVector();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // cannot normalize a zero norm vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double[] toArray() {
    return getData();
}","public void test036() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = openMapRealVector0.toArray();
    assertEquals(6, doubleArray1.length);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test037() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = openMapRealVector0.toArray();
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test048() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getSparcity();
    assertEquals(4, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test049() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getSparcity();
    assertEquals(0.0, double0, 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    }
    return getDistance(v.getData());
}","public void test0510() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    double double0 = openMapRealVector0.getDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0511() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    double double0 = openMapRealVector0.getDistance((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test0612() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(2904.7477);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0613() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(2904.7477);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0614() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(2904.7477);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test0615() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(2904.7477);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public void setSubVector(int index, RealVector v) throws MatrixIndexException {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    setSubVector(index, v.getData());
}","public void test0716() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(31, 2642.9524372);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    try {
        openMapRealVector0.setSubVector(31, (RealVector) arrayRealVector0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // index 31 out of allowed range [0, 30]
        //
        verifyException(""org.apache.commons.math.linear.AbstractRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test0817() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertEquals(2, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0818() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.projection(doubleArray0);
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0819() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.projection(doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0920() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    assertEquals(Double.NaN, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1021() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1022() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    }
    return subtract(v.getData());
}","public void test1023() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1024() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1226() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1227() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    Double[] doubleArray1 = new Double[1];
    doubleArray1[0] = (Double) openMapRealVector0.DEFAULT_ZERO_TOLERANCE;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1);
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector(Double[] values, double epsilon) {
    virtualSize = values.length;
    entries = new OpenIntToDoubleHashMap(0.0);
    this.epsilon = epsilon;
    for (int key = 0; key < values.length; key++) {
        double value = values[key].doubleValue();
        if (!isDefaultValue(value)) {
            entries.put(key, value);
        }
    }
}","public void test1328() throws Throwable {
    Double[] doubleArray0 = new Double[8];
    doubleArray0[0] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector(doubleArray0, 393.1155872284155);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.OpenMapRealVector"", e);
    }
}","/**
 * Create from a Double array.
 * Only non-zero entries will be stored
 * @param values The set of values to create from
 * @param epsilon The tolerance for having a value considered zero
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1429() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1430() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1431() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1532() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    openMapRealVector0.add((RealVector) arrayRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public RealVector add(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return add((OpenMapRealVector) v);
    } else {
        return super.add(v);
    }
}","public void test1633() throws Throwable {
    double[] doubleArray0 = new double[12];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add((RealVector) openMapRealVector0);
    assertNotSame(realVector0, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1634() throws Throwable {
    double[] doubleArray0 = new double[12];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1635() throws Throwable {
    double[] doubleArray0 = new double[12];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add((RealVector) openMapRealVector0);
    assertTrue(realVector0.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1736() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertEquals(1.0, openMapRealVector2.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1737() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertTrue(openMapRealVector2.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    boolean copyThis = entries.size() > v.entries.size();
    OpenMapRealVector res = copyThis ? this.copy() : v.copy();
    Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();
    OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (randomAccess.containsKey(key)) {
            res.setEntry(key, randomAccess.get(key) + iter.value());
        } else {
            res.setEntry(key, iter.value());
        }
    }
    return res;
}","public void test1738() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertNotSame(openMapRealVector2, openMapRealVector0);
}","/**
 * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.
 * @param v Vector to add with
 * @return The sum of <code>this</code> with <code>v</code>
 * @throws IllegalArgumentException If the dimensions don't match
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1839() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = (-1474.733152693);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertEquals(1.0, openMapRealVector2.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1840() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = (-1474.733152693);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test1941() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 5;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 5);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) openMapRealVector0);
    assertEquals(4, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1942() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 5;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 5);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2043() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(7);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertEquals(7, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector append(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return append((OpenMapRealVector) v);
    }
    return append(v.getData());
}","public void test2044() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(7);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2045() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(7);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2146() throws Throwable {
    double[] doubleArray0 = new double[12];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(doubleArray0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2147() throws Throwable {
    double[] doubleArray0 = new double[12];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(doubleArray0);
    assertEquals(24, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2248() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.dotProduct(openMapRealVector0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test2249() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.dotProduct(openMapRealVector0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * Iterates over the smaller of the two.
 * @param v The vector to compute the dot product with
 * @return The dot product of <code>this</code> and <code>v</code>
 * @throws IllegalArgumentException If the dimensions don't match
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2350() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.dotProduct(doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2451() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide((RealVector) openMapRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertTrue(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2453() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide((RealVector) openMapRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2554() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2555() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v[iter.key()]);
    }
    return res;
}","public void test2556() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2657() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}","public void test2658() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) openMapRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2659() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2660() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) openMapRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2761() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}","public void test2762() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2763() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2864() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-37.594487));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2865() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-37.594487));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2866() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-37.594487));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(1, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2967() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(Integer.MAX_VALUE, (-286.019692818355));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(Integer.MAX_VALUE).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue(1.0E-12);
    openMapRealVector0.getSubVector(32, 32);
    assertEquals(4.656612875245797E-10, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double[] getData() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test3068() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    double[] doubleArray1 = openMapRealVector0.getData();
    assertEquals(16, doubleArray1.length);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3069() throws Throwable {
    double[] doubleArray0 = new double[16];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    double[] doubleArray1 = openMapRealVector0.getData();
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    }
    return getDistance(v.getData());
}","public void test3170() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    double double0 = openMapRealVector1.getDistance((RealVector) openMapRealVector0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3171() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    double double0 = openMapRealVector1.getDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    }
    return getDistance(v.getData());
}","public void test3272() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(31, 2642.9524372);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    double double0 = openMapRealVector0.getDistance((RealVector) arrayRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3373() throws Throwable {
    double[] doubleArray0 = new double[12];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getL1Distance(openMapRealVector0);
    assertEquals(0.08333333333333333, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getL1Distance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
        max += delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            double delta = Math.abs(iter.value());
            max += Math.abs(delta);
        }
    }
    return max;
}","public void test3374() throws Throwable {
    double[] doubleArray0 = new double[12];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getL1Distance(openMapRealVector0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Distance between two vectors.
 * <p>This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * elements differences.</p>
 * @param v vector to which distance is requested
 * @return distance between two vectors.
 */"
"public double getL1Distance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
        max += delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            double delta = Math.abs(iter.value());
            max += Math.abs(delta);
        }
    }
    return max;
}","public void test3475() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 3060.547789164;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(1, 1252);
    openMapRealVector1.getL1Distance(openMapRealVector0);
}","/**
 * Distance between two vectors.
 * <p>This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * elements differences.</p>
 * @param v vector to which distance is requested
 * @return distance between two vectors.
 */"
"public double getL1Distance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    }
    return getL1Distance(v.getData());
}","public void test3576() throws Throwable {
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getL1Distance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3677() throws Throwable {
    double[] doubleArray0 = new double[2];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getL1Distance((RealVector) arrayRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getL1Distance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    }
    return getL1Distance(v.getData());
}","public void test3678() throws Throwable {
    double[] doubleArray0 = new double[2];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getL1Distance((RealVector) arrayRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3779() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getLInfNorm();
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getLInfNorm() {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        max += iter.value();
    }
    return max;
}","public void test3780() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getLInfNorm();
    assertEquals(Double.NaN, double0, 0.01);
}",""
"public double getLInfDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3881() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3882() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3983() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    openMapRealVector0.mapSinToSelf();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getLInfDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3984() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    openMapRealVector0.mapSinToSelf();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.1585290151921035, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4085() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue((-30));
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals((-0.03333333333333333), openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getLInfDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test4086() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue((-30));
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4187() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2146857538).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue(1.0E-12);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals((-0.03333333333333333), openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getLInfDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test4188() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-30));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2146857538).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue(1.0E-12);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(1.0E-12, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfDistance(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test4289() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(31, 2642.9524372);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    openMapRealVector0.unitize();
    double double0 = openMapRealVector0.getLInfDistance((RealVector) arrayRealVector0);
    assertEquals(2642.7728318979734, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4290() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(31, 2642.9524372);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    openMapRealVector0.unitize();
    double double0 = openMapRealVector0.getLInfDistance((RealVector) arrayRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test4391() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4392() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4493() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test4494() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test4595() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-2593.85329175));
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.mapPow((-2593.85329175));
    boolean boolean0 = openMapRealVector1.isInfinite();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4596() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-2593.85329175));
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.mapPow((-2593.85329175));
    boolean boolean0 = openMapRealVector1.isInfinite();
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4597() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-2593.85329175));
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.mapPow((-2593.85329175));
    boolean boolean0 = openMapRealVector1.isInfinite();
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4698() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-597.076839365));
    boolean boolean0 = openMapRealVector0.isNaN();
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public boolean isNaN() {
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        if (Double.isNaN(iter.value())) {
            return true;
        }
    }
    return false;
}","public void test4699() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-597.076839365));
    boolean boolean0 = openMapRealVector0.isNaN();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test47100() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.isNaN();
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public boolean isNaN() {
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        if (Double.isNaN(iter.value())) {
            return true;
        }
    }
    return false;
}","public void test47101() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.isNaN();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test48102() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"int getColumnDimension();","public void test48103() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(2, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test48104() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(2, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test49105() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test49106() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) openMapRealVector0);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test50107() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.setSubVector(0, doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test51108() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-30));
    openMapRealVector0.set((-30));
    assertEquals((-30), openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test52109() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-2593.85329175));
    openMapRealVector0.set(1455.0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    }
    return subtract(v.getData());
}","public void test53110() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.subtract((RealVector) openMapRealVector0);
    assertNotSame(openMapRealVector2, openMapRealVector1);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test53111() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.subtract((RealVector) openMapRealVector0);
    assertTrue(openMapRealVector2.equals((Object) openMapRealVector1));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test53112() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.subtract((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test53113() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1499.91);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.subtract((RealVector) openMapRealVector0);
    assertEquals(0.0, openMapRealVector2.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    }
    return subtract(v.getData());
}","public void test54114() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test54115() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test54116() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealVector realVector0 = openMapRealVector0.add(doubleArray0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(realVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test55117() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = Double.NaN;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.hashCode();
    assertEquals(0.5, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test56118() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertTrue(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test56119() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test57120() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test57121() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector0);
    assertTrue(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test58122() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals((Object) null);
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test58123() throws Throwable {
    double[] doubleArray0 = new double[6];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals((Object) null);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test59124() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals("":/`q:0[Oe7aJ"");
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test59125() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    boolean boolean0 = openMapRealVector0.equals("":/`q:0[Oe7aJ"");
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test60126() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 1);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test60127() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 1);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(3, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test60128() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 1);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(0.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test60129() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 1);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test61130() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NaN);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(0.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test61131() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NaN);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test61132() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NaN);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test61133() throws Throwable {
    double[] doubleArray0 = new double[7];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NaN);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test62134() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.add(openMapRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertFalse(boolean0);
}","/**
 * <p> Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.</p>
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test62135() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1.0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.add(openMapRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
