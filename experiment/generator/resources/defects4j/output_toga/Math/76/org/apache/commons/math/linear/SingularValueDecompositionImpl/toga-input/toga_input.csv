focal_method,test_prefix,docstring
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[24];
    doubleArray0[0] = (-1469.24165998819);
    doubleArray0[5] = (-651.4657703215);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0, 5);
    double double0 = singularValueDecompositionImpl0.getConditionNumber();
    assertEquals(15702.66575521932, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public DecompositionSolver getSolver() {
    return new Solver(singularValues, getUT(), getV(), getRank() == Math.max(m, n));
}","public void test022() throws Throwable {
    double[] doubleArray0 = new double[3];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getSolver();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // row index -1 out of allowed range [0, 0]
        //
        verifyException(""org.apache.commons.math.linear.MatrixUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double[] getSingularValues() throws InvalidMatrixException {
    return singularValues.clone();
}","public void test033() throws Throwable {
    double[] doubleArray0 = new double[14];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    double[] doubleArray1 = singularValueDecompositionImpl0.getSingularValues();
    assertArrayEquals(new double[] { 28363.113150986705 }, doubleArray1, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test045() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 1657.6410258812;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 117);
    double double0 = singularValueDecompositionImpl0.getNorm();
    assertEquals(1657.6410258812, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getUT() throws InvalidMatrixException {
    if (cachedUt == null) {
        cachedUt = getU().transpose();
    }
    // return the cached matrix
    return cachedUt;
}","public void test056() throws Throwable {
    double[][] doubleArray0 = new double[1][4];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getUT();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // column index -1 out of allowed range [0, 0]
        //
        verifyException(""org.apache.commons.math.linear.MatrixUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    // return the cached matrix
    return cachedU;
}","public void test067() throws Throwable {
    double[] doubleArray0 = new double[14];
    doubleArray0[0] = (-119.0863408434962);
    doubleArray0[2] = (-200.7204561);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getCovariance(0.0);
    // Undeclared exception!
    singularValueDecompositionImpl0.getU();
}","/**
 * {@inheritDoc}
 */"
"public DecompositionSolver getSolver() {
    return new Solver(singularValues, getUT(), getV(), getRank() == Math.max(m, n));
}","public void test078() throws Throwable {
    double[] doubleArray0 = new double[24];
    doubleArray0[0] = (-1469.24165998819);
    doubleArray0[2] = 1042.9999;
    doubleArray0[5] = (-651.4657703215);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0, 5);
    singularValueDecompositionImpl0.getSolver();
    singularValueDecompositionImpl0.getSolver();
    // Undeclared exception!
    singularValueDecompositionImpl0.getSolver();
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getS() throws InvalidMatrixException {
    if (cachedS == null) {
        // cache the matrix for subsequent calls
        cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);
    }
    return cachedS;
}","public void test089() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    double[][] doubleArray0 = new double[1][7];
    array2DRowRealMatrix0.data = doubleArray0;
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getS();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // invalid row dimension 0 (must be positive)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getRank() throws IllegalStateException {
    final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);
    for (int i = singularValues.length - 1; i >= 0; --i) {
        if (singularValues[i] > threshold) {
            return i + 1;
        }
    }
    return 0;
}","public void test0910() throws Throwable {
    OpenMapRealMatrix openMapRealMatrix0 = new OpenMapRealMatrix(7, 7);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(openMapRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getRank();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getCovariance(final double minSingularValue) {
    // get the number of singular values to consider
    final int p = singularValues.length;
    int dimension = 0;
    while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {
        ++dimension;
    }
    if (dimension == 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cutoff singular value is {0}, should be at most {1}"", minSingularValue, singularValues[0]);
    }
    final double[][] data = new double[dimension][p];
    getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {

        /**
         * {@inheritDoc}
         */
        @Override
        public void visit(final int row, final int column, final double value) {
            data[row][column] = value / singularValues[row];
        }
    }, 0, dimension - 1, 0, p - 1);
    RealMatrix jv = new Array2DRowRealMatrix(data, false);
    return jv.transpose().multiply(jv);
}","public void test1011() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (-4091.30585795025);
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getCovariance(Double.POSITIVE_INFINITY);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cutoff singular value is \u221E, should be at most 4,091.306
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {
    m = matrix.getRowDimension();
    n = matrix.getColumnDimension();
    cachedU = null;
    cachedS = null;
    cachedV = null;
    cachedVt = null;
    // transform the matrix to bidiagonal
    transformer = new BiDiagonalTransformer(matrix);
    mainBidiagonal = transformer.getMainDiagonalRef();
    secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
    // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)
    mainTridiagonal = new double[mainBidiagonal.length];
    secondaryTridiagonal = new double[mainBidiagonal.length - 1];
    double a = mainBidiagonal[0];
    mainTridiagonal[0] = a * a;
    for (int i = 1; i < mainBidiagonal.length; ++i) {
        final double b = secondaryBidiagonal[i - 1];
        secondaryTridiagonal[i - 1] = a * b;
        a = mainBidiagonal[i];
        mainTridiagonal[i] = a * a + b * b;
    }
    // compute singular values
    eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);
    final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
    int p = Math.min(max, eigenValues.length);
    while ((p > 0) && (eigenValues[p - 1] <= 0)) {
        --p;
    }
    singularValues = new double[p];
    for (int i = 0; i < p; ++i) {
        singularValues[i] = Math.sqrt(eigenValues[i]);
    }
}","public void test1112() throws Throwable {
    OpenMapRealMatrix openMapRealMatrix0 = new OpenMapRealMatrix(2088, 2088);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(openMapRealMatrix0, 0);
}","/**
 * Calculates the Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param max maximal number of singular values to compute
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {
    m = matrix.getRowDimension();
    n = matrix.getColumnDimension();
    cachedU = null;
    cachedS = null;
    cachedV = null;
    cachedVt = null;
    // transform the matrix to bidiagonal
    transformer = new BiDiagonalTransformer(matrix);
    mainBidiagonal = transformer.getMainDiagonalRef();
    secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
    // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)
    mainTridiagonal = new double[mainBidiagonal.length];
    secondaryTridiagonal = new double[mainBidiagonal.length - 1];
    double a = mainBidiagonal[0];
    mainTridiagonal[0] = a * a;
    for (int i = 1; i < mainBidiagonal.length; ++i) {
        final double b = secondaryBidiagonal[i - 1];
        secondaryTridiagonal[i - 1] = a * b;
        a = mainBidiagonal[i];
        mainTridiagonal[i] = a * a + b * b;
    }
    // compute singular values
    eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);
    final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
    int p = Math.min(max, eigenValues.length);
    while ((p > 0) && (eigenValues[p - 1] <= 0)) {
        --p;
    }
    singularValues = new double[p];
    for (int i = 0; i < p; ++i) {
        singularValues[i] = Math.sqrt(eigenValues[i]);
    }
}","public void test1213() throws Throwable {
    double[] doubleArray0 = new double[12];
    doubleArray0[0] = (-1469.24165998819);
    doubleArray0[3] = 0.10664378144610108;
    doubleArray0[5] = (-651.4657703215);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0, 5);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        //
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param max maximal number of singular values to compute
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {
    m = matrix.getRowDimension();
    n = matrix.getColumnDimension();
    cachedU = null;
    cachedS = null;
    cachedV = null;
    cachedVt = null;
    // transform the matrix to bidiagonal
    transformer = new BiDiagonalTransformer(matrix);
    mainBidiagonal = transformer.getMainDiagonalRef();
    secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
    // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)
    mainTridiagonal = new double[mainBidiagonal.length];
    secondaryTridiagonal = new double[mainBidiagonal.length - 1];
    double a = mainBidiagonal[0];
    mainTridiagonal[0] = a * a;
    for (int i = 1; i < mainBidiagonal.length; ++i) {
        final double b = secondaryBidiagonal[i - 1];
        secondaryTridiagonal[i - 1] = a * b;
        a = mainBidiagonal[i];
        mainTridiagonal[i] = a * a + b * b;
    }
    // compute singular values
    eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);
    final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
    int p = Math.min(max, eigenValues.length);
    while ((p > 0) && (eigenValues[p - 1] <= 0)) {
        --p;
    }
    singularValues = new double[p];
    for (int i = 0; i < p; ++i) {
        singularValues[i] = Math.sqrt(eigenValues[i]);
    }
}","public void test1314() throws Throwable {
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl((RealMatrix) null, (-2635));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * Calculates the Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param max maximal number of singular values to compute
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {
    m = matrix.getRowDimension();
    n = matrix.getColumnDimension();
    cachedU = null;
    cachedS = null;
    cachedV = null;
    cachedVt = null;
    // transform the matrix to bidiagonal
    transformer = new BiDiagonalTransformer(matrix);
    mainBidiagonal = transformer.getMainDiagonalRef();
    secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
    // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)
    mainTridiagonal = new double[mainBidiagonal.length];
    secondaryTridiagonal = new double[mainBidiagonal.length - 1];
    double a = mainBidiagonal[0];
    mainTridiagonal[0] = a * a;
    for (int i = 1; i < mainBidiagonal.length; ++i) {
        final double b = secondaryBidiagonal[i - 1];
        secondaryTridiagonal[i - 1] = a * b;
        a = mainBidiagonal[i];
        mainTridiagonal[i] = a * a + b * b;
    }
    // compute singular values
    eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);
    final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
    int p = Math.min(max, eigenValues.length);
    while ((p > 0) && (eigenValues[p - 1] <= 0)) {
        --p;
    }
    singularValues = new double[p];
    for (int i = 0; i < p; ++i) {
        singularValues[i] = Math.sqrt(eigenValues[i]);
    }
}","public void test1415() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BiDiagonalTransformer"", e);
    }
}","/**
 * Calculates the Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param max maximal number of singular values to compute
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {
    m = matrix.getRowDimension();
    n = matrix.getColumnDimension();
    cachedU = null;
    cachedS = null;
    cachedV = null;
    cachedVt = null;
    // transform the matrix to bidiagonal
    transformer = new BiDiagonalTransformer(matrix);
    mainBidiagonal = transformer.getMainDiagonalRef();
    secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
    // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)
    mainTridiagonal = new double[mainBidiagonal.length];
    secondaryTridiagonal = new double[mainBidiagonal.length - 1];
    double a = mainBidiagonal[0];
    mainTridiagonal[0] = a * a;
    for (int i = 1; i < mainBidiagonal.length; ++i) {
        final double b = secondaryBidiagonal[i - 1];
        secondaryTridiagonal[i - 1] = a * b;
        a = mainBidiagonal[i];
        mainTridiagonal[i] = a * a + b * b;
    }
    // compute singular values
    eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);
    final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
    int p = Math.min(max, eigenValues.length);
    while ((p > 0) && (eigenValues[p - 1] <= 0)) {
        --p;
    }
    singularValues = new double[p];
    for (int i = 0; i < p; ++i) {
        singularValues[i] = Math.sqrt(eigenValues[i]);
    }
}","public void test1516() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(1, 1);
    double[][] doubleArray0 = new double[4][2];
    double[] doubleArray1 = new double[4];
    doubleArray0[2] = doubleArray1;
    array2DRowRealMatrix0.data = doubleArray0;
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 46);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Calculates the Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param max maximal number of singular values to compute
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {
    this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
}","public void test1617() throws Throwable {
    OpenMapRealMatrix openMapRealMatrix0 = new OpenMapRealMatrix(2328, 2328);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(openMapRealMatrix0);
}","/**
 * Calculates the compact Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {
    this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
}","public void test1718() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    doubleArray0[1] = 3341.3125;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        //
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the compact Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {
    this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
}","public void test1819() throws Throwable {
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl((RealMatrix) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * Calculates the compact Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {
    this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
}","public void test1920() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BiDiagonalTransformer"", e);
    }
}","/**
 * Calculates the compact Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException {
    this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
}","public void test2021() throws Throwable {
    double[] doubleArray0 = new double[3];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    double[][] doubleArray1 = new double[8][2];
    doubleArray1[1] = doubleArray0;
    array2DRowRealMatrix0.data = doubleArray1;
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = null;
    try {
        singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Calculates the compact Singular Value Decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public int getRank() throws IllegalStateException {
    final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);
    for (int i = singularValues.length - 1; i >= 0; --i) {
        if (singularValues[i] > threshold) {
            return i + 1;
        }
    }
    return 0;
}","public void test2122() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    int int0 = singularValueDecompositionImpl0.getRank();
    assertEquals(1, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test2123() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    int int0 = singularValueDecompositionImpl0.getRank();
    assertEquals(28363.113150986705, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getVT() throws InvalidMatrixException {
    if (cachedVt == null) {
        cachedVt = getV().transpose();
    }
    // return the cached matrix
    return cachedVt;
}","public void test2224() throws Throwable {
    BlockRealMatrix blockRealMatrix0 = new BlockRealMatrix(9, 1);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(blockRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getVT();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // column index -1 out of allowed range [0, 0]
        //
        verifyException(""org.apache.commons.math.linear.MatrixUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test2325() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    assertEquals(1, realMatrix1.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test2326() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    RealMatrix realMatrix2 = singularValueDecompositionImpl0.getVT();
    assertEquals(1, realMatrix2.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test2327() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    RealMatrix realMatrix2 = singularValueDecompositionImpl0.getVT();
    assertEquals(28363.113150986705, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test2428() throws Throwable {
    double[][] doubleArray0 = new double[2][5];
    double[] doubleArray1 = new double[3];
    doubleArray1[1] = (-1.0);
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[3];
    doubleArray2[0] = 1.05;
    doubleArray0[1] = doubleArray2;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, true);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, Integer.MAX_VALUE);
    RealMatrix realMatrix0 = singularValueDecompositionImpl0.getV();
    assertEquals(1.05, singularValueDecompositionImpl0.getConditionNumber(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test2429() throws Throwable {
    double[][] doubleArray0 = new double[2][5];
    double[] doubleArray1 = new double[3];
    doubleArray1[1] = (-1.0);
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[3];
    doubleArray2[0] = 1.05;
    doubleArray0[1] = doubleArray2;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, true);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, Integer.MAX_VALUE);
    RealMatrix realMatrix0 = singularValueDecompositionImpl0.getV();
    assertEquals(2, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
            cachedV = transformer.getV().multiply(e);
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[n][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < n; ++i) {
                wData[i] = new double[p];
            }
            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
        }
    }
    // return the cached matrix
    return cachedV;
}","public void test2530() throws Throwable {
    double[] doubleArray0 = new double[3];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getV();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // column index -1 out of allowed range [0, 0]
        //
        verifyException(""org.apache.commons.math.linear.MatrixUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    // return the cached matrix
    return cachedU;
}","public void test2631() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    double[][] doubleArray0 = new double[1][7];
    array2DRowRealMatrix0.data = doubleArray0;
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getU();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // column index -1 out of allowed range [0, 0]
        //
        verifyException(""org.apache.commons.math.linear.MatrixUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test2732() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[1] = (-1314.9147069);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getU();
    singularValueDecompositionImpl0.getU();
    assertEquals(1729000.686421913, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"boolean isNonSingular();","public void test2833() throws Throwable {
    double[] doubleArray0 = new double[11];
    doubleArray0[0] = 0.5;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    DecompositionSolver decompositionSolver0 = singularValueDecompositionImpl0.getSolver();
    assertTrue(decompositionSolver0.isNonSingular());
}","/**
 * Check if the decomposed matrix is non-singular.
 * @return true if the decomposed matrix is non-singular
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test2834() throws Throwable {
    double[] doubleArray0 = new double[11];
    doubleArray0[0] = 0.5;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    DecompositionSolver decompositionSolver0 = singularValueDecompositionImpl0.getSolver();
    assertEquals(0.5, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getRank() throws IllegalStateException {
    final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);
    for (int i = singularValues.length - 1; i >= 0; --i) {
        if (singularValues[i] > threshold) {
            return i + 1;
        }
    }
    return 0;
}","public void test2935() throws Throwable {
    double[] doubleArray0 = new double[3];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.mapLog10ToSelf();
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    int int0 = singularValueDecompositionImpl0.getRank();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getCovariance(final double minSingularValue) {
    // get the number of singular values to consider
    final int p = singularValues.length;
    int dimension = 0;
    while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {
        ++dimension;
    }
    if (dimension == 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cutoff singular value is {0}, should be at most {1}"", minSingularValue, singularValues[0]);
    }
    final double[][] data = new double[dimension][p];
    getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {

        /**
         * {@inheritDoc}
         */
        @Override
        public void visit(final int row, final int column, final double value) {
            data[row][column] = value / singularValues[row];
        }
    }, 0, dimension - 1, 0, p - 1);
    RealMatrix jv = new Array2DRowRealMatrix(data, false);
    return jv.transpose().multiply(jv);
}","public void test3036() throws Throwable {
    double[] doubleArray0 = new double[3];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getCovariance(140.5950535212718);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test3137() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    doubleArray0[2] = (-200.7204561);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(1190.52);
    assertEquals(6.6982543727467088E16, singularValueDecompositionImpl0.getConditionNumber(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test3138() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    doubleArray0[2] = (-200.7204561);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(1190.52);
    assertEquals(3, realMatrix1.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRank() throws IllegalStateException {
    final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);
    for (int i = singularValues.length - 1; i >= 0; --i) {
        if (singularValues[i] > threshold) {
            return i + 1;
        }
    }
    return 0;
}","public void test3239() throws Throwable {
    double[][] doubleArray0 = new double[2][5];
    double[] doubleArray1 = new double[3];
    doubleArray1[1] = 1.05;
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[3];
    doubleArray2[0] = 1.05;
    doubleArray0[1] = doubleArray2;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, true);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, Integer.MAX_VALUE);
    DecompositionSolver decompositionSolver0 = singularValueDecompositionImpl0.getSolver();
    assertEquals(2, singularValueDecompositionImpl0.getRank());
}","/**
 * {@inheritDoc}
 */"
"boolean isNonSingular();","public void test3240() throws Throwable {
    double[][] doubleArray0 = new double[2][5];
    double[] doubleArray1 = new double[3];
    doubleArray1[1] = 1.05;
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[3];
    doubleArray2[0] = 1.05;
    doubleArray0[1] = doubleArray2;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, true);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, Integer.MAX_VALUE);
    DecompositionSolver decompositionSolver0 = singularValueDecompositionImpl0.getSolver();
    assertFalse(decompositionSolver0.isNonSingular());
}","/**
 * Check if the decomposed matrix is non-singular.
 * @return true if the decomposed matrix is non-singular
 */"
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test3241() throws Throwable {
    double[][] doubleArray0 = new double[2][5];
    double[] doubleArray1 = new double[3];
    doubleArray1[1] = 1.05;
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[3];
    doubleArray2[0] = 1.05;
    doubleArray0[1] = doubleArray2;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, true);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, Integer.MAX_VALUE);
    DecompositionSolver decompositionSolver0 = singularValueDecompositionImpl0.getSolver();
    assertEquals(1.0, singularValueDecompositionImpl0.getConditionNumber(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test3342() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    assertEquals(1, realMatrix1.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test3343() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    RealMatrix realMatrix2 = singularValueDecompositionImpl0.getV();
    assertEquals(28363.113150986705, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test3344() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getCovariance(0.0);
    RealMatrix realMatrix2 = singularValueDecompositionImpl0.getV();
    assertEquals(1, realMatrix2.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public RealMatrix getS() throws InvalidMatrixException {
    if (cachedS == null) {
        // cache the matrix for subsequent calls
        cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);
    }
    return cachedS;
}","public void test3445() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getS();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getS();
    assertNotNull(realMatrix1);
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test3446() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getS();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getS();
    assertEquals(1, realMatrix1.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test3447() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getS();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getS();
    assertEquals(28363.113150986705, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test3548() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getUT();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getUT();
    assertEquals(1.0, singularValueDecompositionImpl0.getConditionNumber(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test3549() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getUT();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getUT();
    assertEquals(28363.113150986705, singularValueDecompositionImpl0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getUT() throws InvalidMatrixException {
    if (cachedUt == null) {
        cachedUt = getU().transpose();
    }
    // return the cached matrix
    return cachedUt;
}","public void test3550() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-119.0863408434962);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    singularValueDecompositionImpl0.getUT();
    RealMatrix realMatrix1 = singularValueDecompositionImpl0.getUT();
    assertNotNull(realMatrix1);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() throws InvalidMatrixException {
    return singularValues[0];
}","public void test3651() throws Throwable {
    double[][] doubleArray0 = new double[1][3];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0, 2);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getNorm();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double[] getSingularValues() throws InvalidMatrixException {
    return singularValues.clone();
}","public void test3752() throws Throwable {
    double[] doubleArray0 = new double[5];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector0.outerProduct(arrayRealVector0);
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(realMatrix0);
    double[] doubleArray1 = singularValueDecompositionImpl0.getSingularValues();
    assertEquals(0, doubleArray1.length);
}","/**
 * {@inheritDoc}
 */"
"public double getConditionNumber() throws InvalidMatrixException {
    return singularValues[0] / singularValues[singularValues.length - 1];
}","public void test3853() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    double[][] doubleArray0 = new double[1][7];
    array2DRowRealMatrix0.data = doubleArray0;
    SingularValueDecompositionImpl singularValueDecompositionImpl0 = new SingularValueDecompositionImpl(array2DRowRealMatrix0);
    // Undeclared exception!
    try {
        singularValueDecompositionImpl0.getConditionNumber();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.SingularValueDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
