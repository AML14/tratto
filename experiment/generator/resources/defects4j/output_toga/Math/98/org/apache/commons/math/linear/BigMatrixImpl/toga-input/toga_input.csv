focal_method,test_prefix,docstring
"public BigDecimal[] getColumn(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int i = 0; i < nRows; i++) {
        out[i] = data[i][col];
    }
    return out;
}","public void test0000() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(3376, 324);
    try {
        bigMatrixImpl0.getColumn(3376);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal column argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test0011() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray1[0] = 1.0;
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.hashCode();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test0012() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray1[0] = 1.0;
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.hashCode();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != this.getRowDimension()) {
        throw new IllegalArgumentException(""Incorrect row dimension"");
    }
    if (!this.isSquare()) {
        throw new InvalidMatrixException(""coefficient matrix is not square"");
    }
    if (this.isSingular()) {
        // side effect: compute LU decomp
        throw new InvalidMatrixException(""Matrix is singular."");
    }
    final int nCol = this.getColumnDimension();
    final int nColB = b.getColumnDimension();
    final int nRowB = b.getRowDimension();
    // Apply permutations to b
    final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
    for (int row = 0; row < nRowB; row++) {
        final BigDecimal[] bpRow = bp[row];
        for (int col = 0; col < nColB; col++) {
            bpRow[col] = b.getEntry(permutation[row], col);
        }
    }
    // Solve LY = b
    for (int col = 0; col < nCol; col++) {
        for (int i = col + 1; i < nCol; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    // Solve UX = Y
    for (int col = nCol - 1; col >= 0; col--) {
        final BigDecimal[] bpCol = bp[col];
        final BigDecimal luDiag = lu[col][col];
        for (int j = 0; j < nColB; j++) {
            bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
        }
        for (int i = 0; i < col; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    return new BigMatrixImpl(bp, false);
}","public void test0023() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigMatrixImpl bigMatrixImpl1 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Incorrect row dimension
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  matrix of constant vectors forming RHS of linear systems to
 * to solve
 * @return matrix of solution vectors
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    if (v.length != nRows) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nCols];
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nRows; i++) {
            sum = sum.add(data[i][col].multiply(v[i]));
        }
        out[col] = sum;
    }
    return out;
}","public void test0034() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[] bigDecimalArray0 = new BigDecimal[9];
    try {
        bigMatrixImpl0.preMultiply(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
 *
 * @param v the row vector to premultiply by
 * @return v*this
 * @throws IllegalArgumentException if rowDimension != v.size()
 */"
"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}","public void test0045() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(1498, 1498);
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    try {
        bigMatrixImpl0.operate(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public BigMatrixImpl(BigDecimal[][] d) {
    this.copyIn(d);
    lu = null;
}","public void test0056() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[7][9];
    BigDecimal[] bigDecimalArray1 = new BigDecimal[6];
    bigDecimalArray0[1] = bigDecimalArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>The input array is copied, not referenced. This constructor has
 * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}
 * with the second argument set to <code>true</code>.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test0067() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[8][0];
    BigDecimal[] bigDecimalArray1 = new BigDecimal[9];
    bigDecimalArray0[0] = bigDecimalArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test0078() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.transpose();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test0079() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.transpose();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test00710() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.transpose();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test00711() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.transpose();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test00812() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test00813() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test00814() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test00815() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test00816() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertFalse(bigMatrixImpl1.isSquare());
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test00917() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertFalse(bigMatrixImpl1.equals((Object) bigMatrixImpl0));
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test00918() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test00919() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test00920() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test00921() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test01022() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test01023() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    assertFalse(bigMatrixImpl1.equals((Object) bigMatrixImpl0));
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01024() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01025() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01026() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01127() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01128() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test01129() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertFalse(bigMatrixImpl1.equals((Object) bigMatrixImpl0));
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getScale() {
    return scale;
}","public void test01130() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01131() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"int getColumnDimension();","public void test01232() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    assertEquals(2, bigMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01233() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.preMultiply(bigMatrix0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01234() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.preMultiply(bigMatrix0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01235() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.preMultiply(bigMatrix0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01236() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[2];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.preMultiply(bigMatrix0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test01337() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    assertEquals(7, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01338() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.operate(doubleArray1);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01339() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.operate(doubleArray1);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test01440() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test01441() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01442() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01443() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01544() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.inverse();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01545() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.inverse();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01546() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.inverse();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal getTrace() throws IllegalArgumentException {
    if (!isSquare()) {
        throw new IllegalArgumentException(""matrix is not square"");
    }
    BigDecimal trace = data[0][0];
    for (int i = 1; i < this.getRowDimension(); i++) {
        trace = trace.add(data[i][i]);
    }
    return trace;
}","public void test01647() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getTrace();
    assertNull(bigDecimal0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MatrixTrace.html"">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).
 *
 * @return trace
 *
 * @throws IllegalArgumentException if this matrix is not square.
 */"
"public int getScale() {
    return scale;
}","public void test01648() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getTrace();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01649() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getTrace();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01750() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getTrace();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01752() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getTrace();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test01853() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getRowMatrix(0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test01854() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getRowMatrix(0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01855() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getRowMatrix(0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01856() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getRowMatrix(0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test01957() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[5];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    bigDecimalArray0[3] = bigDecimal0;
    bigDecimalArray0[4] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getNorm();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test01958() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[5];
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    bigDecimalArray0[3] = bigDecimal0;
    bigDecimalArray0[4] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getNorm();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test02060() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[9];
    BigDecimal bigDecimal0 = new BigDecimal(0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[1];
    bigDecimalArray0[3] = bigDecimalArray0[1];
    BigDecimal bigDecimal1 = new BigDecimal(834);
    bigDecimalArray0[4] = bigDecimal1;
    bigDecimalArray0[5] = bigDecimal0;
    bigDecimalArray0[6] = bigDecimalArray0[4];
    bigDecimalArray0[7] = bigDecimalArray0[2];
    bigDecimalArray0[8] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal2 = bigMatrixImpl0.getNorm();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02062() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[9];
    BigDecimal bigDecimal0 = new BigDecimal(0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[1];
    bigDecimalArray0[3] = bigDecimalArray0[1];
    BigDecimal bigDecimal1 = new BigDecimal(834);
    bigDecimalArray0[4] = bigDecimal1;
    bigDecimalArray0[5] = bigDecimal0;
    bigDecimalArray0[6] = bigDecimalArray0[4];
    bigDecimalArray0[7] = bigDecimalArray0[2];
    bigDecimalArray0[8] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal2 = bigMatrixImpl0.getNorm();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test02163() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getEntryAsDouble(0, 0);
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getScale() {
    return scale;
}","public void test02164() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getEntryAsDouble(0, 0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02165() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getEntryAsDouble(0, 0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02266() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    bigMatrixImpl0.getDataRef();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test02267() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    bigMatrixImpl0.getDataRef();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02368() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getColumnDimension();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test02369() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getColumnDimension();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test02470() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test02471() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02472() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02473() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02574() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test02575() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02576() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test02577() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.copy();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02678() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test02679() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test02680() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test02681() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertFalse(bigMatrixImpl1.isSquare());
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test02682() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(5, bigMatrixImpl1.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test02683() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix transpose() {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[nCols][nRows];
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            outData[col][row] = dataRow[col];
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test02784() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.transpose();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the transpose matrix.
 *
 * @return transpose matrix
 */"
"public BigMatrix transpose() {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[nCols][nRows];
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            outData[col][row] = dataRow[col];
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test02885() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.transpose();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the transpose matrix.
 *
 * @return transpose matrix
 */"
"public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].subtract(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test02986() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.subtract(bigMatrixImpl0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
    final int nRows = this.getRowDimension();
    if (b.length != nRows) {
        throw new IllegalArgumentException(""constant vector has wrong length"");
    }
    final BigMatrix bMatrix = new BigMatrixImpl(b);
    final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int row = 0; row < nRows; row++) {
        out[row] = solution[row][0];
    }
    return out;
}","public void test03087() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ZERO;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.solve(bigDecimalArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // Matrix is singular.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  array of constants forming RHS of linear systems to
 * to solve
 * @return solution array
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
    final int nRows = this.getRowDimension();
    if (b.length != nRows) {
        throw new IllegalArgumentException(""constant vector has wrong length"");
    }
    final BigMatrix bMatrix = new BigMatrixImpl(b);
    final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int row = 0; row < nRows; row++) {
        out[row] = solution[row][0];
    }
    return out;
}","public void test03188() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.solve(bigDecimalArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  array of constants forming RHS of linear systems to
 * to solve
 * @return solution array
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
    final int nRows = this.getRowDimension();
    if (b.length != nRows) {
        throw new IllegalArgumentException(""constant vector has wrong length"");
    }
    final BigMatrix bMatrix = new BigMatrixImpl(b);
    final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int row = 0; row < nRows; row++) {
        out[row] = solution[row][0];
    }
    return out;
}","public void test03289() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.solve(bigDecimalArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  array of constants forming RHS of linear systems to
 * to solve
 * @return solution array
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test03390() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[][] bigDecimalArray1 = new BigDecimal[5][3];
    bigDecimalArray1[1] = null;
    // Undeclared exception!
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray1, 1, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public BigMatrix scalarMultiply(BigDecimal d) {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].multiply(d);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test03491() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.scalarMultiply((BigDecimal) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of multiplying each entry of this by <code>d</code>
 * @param d  value to multiply all entries by
 * @return d * this
 */"
"public BigMatrix scalarMultiply(BigDecimal d) {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].multiply(d);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test03592() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal0 = new BigDecimal((-727));
    // Undeclared exception!
    try {
        bigMatrixImpl0.scalarMultiply(bigDecimal0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of multiplying each entry of this by <code>d</code>
 * @param d  value to multiply all entries by
 * @return d * this
 */"
"public BigMatrix scalarAdd(BigDecimal d) {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(d);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test03693() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    BigDecimal bigDecimal0 = new BigDecimal(3051L);
    // Undeclared exception!
    try {
        bigMatrixImpl0.scalarAdd(bigDecimal0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of adding d to each entry of this.
 *
 * @param d    value to be added to each entry
 * @return     d + this
 */"
"public BigMatrix scalarAdd(BigDecimal d) {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(d);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test03794() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal0 = BigMatrixImpl.ZERO;
    // Undeclared exception!
    try {
        bigMatrixImpl0.scalarAdd(bigDecimal0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of adding d to each entry of this.
 *
 * @param d    value to be added to each entry
 * @return     d + this
 */"
"public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    if (v.length != nRows) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nCols];
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nRows; i++) {
            sum = sum.add(data[i][col].multiply(v[i]));
        }
        out[col] = sum;
    }
    return out;
}","public void test03895() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.preMultiply(bigDecimalArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
 *
 * @param v the row vector to premultiply by
 * @return v*this
 * @throws IllegalArgumentException if rowDimension != v.size()
 */"
"public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {
    return m.multiply(this);
}","public void test03996() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(121, 121);
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[7][2];
    BigMatrixImpl bigMatrixImpl1 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.preMultiply((BigMatrix) bigMatrixImpl1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrices are not multiplication compatible.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result premultiplying this by <code>m</code>.
 * @param m    matrix to premultiply by
 * @return     m * this
 * @throws     IllegalArgumentException
 *             if rowDimension(this) != columnDimension(m)
 */"
"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}","public void test04097() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = new BigDecimal[1];
    // Undeclared exception!
    try {
        bigMatrixImpl0.operate(bigDecimalArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
    final BigDecimal[] bd = new BigDecimal[v.length];
    for (int i = 0; i < bd.length; i++) {
        bd[i] = new BigDecimal(v[i]);
    }
    return operate(bd);
}","public void test04198() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        bigMatrixImpl0.operate(doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
    final BigDecimal[] bd = new BigDecimal[v.length];
    for (int i = 0; i < bd.length; i++) {
        bd[i] = new BigDecimal(v[i]);
    }
    return operate(bd);
}","public void test04299() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    double[] doubleArray0 = new double[3];
    // Undeclared exception!
    try {
        bigMatrixImpl0.operate(doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {
    if (this.getColumnDimension() != m.getRowDimension()) {
        throw new IllegalArgumentException(""Matrices are not multiplication compatible."");
    }
    final int nRows = this.getRowDimension();
    final int nCols = m.getColumnDimension();
    final int nSum = this.getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < nCols; col++) {
            BigDecimal sum = ZERO;
            for (int i = 0; i < nSum; i++) {
                sum = sum.add(dataRow[i].multiply(m.data[i][col]));
            }
            outDataRow[col] = sum;
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test043100() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(467, 17);
    // Undeclared exception!
    try {
        bigMatrixImpl0.multiply((BigMatrixImpl) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of postmultiplying this by <code>m</code>.
 * @param m    matrix to postmultiply by
 * @return     this*m
 * @throws     IllegalArgumentException
 *             if columnDimension(this) != rowDimension(m)
 */"
"public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
    try {
        return multiply((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        if (this.getColumnDimension() != m.getRowDimension()) {
            throw new IllegalArgumentException(""Matrices are not multiplication compatible."");
        }
        final int nRows = this.getRowDimension();
        final int nCols = m.getColumnDimension();
        final int nSum = this.getColumnDimension();
        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
        for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                BigDecimal sum = ZERO;
                for (int i = 0; i < nSum; i++) {
                    sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
                }
                outDataRow[col] = sum;
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test044101() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of postmultiplying this by <code>m</code>.
 * @param m    matrix to postmultiply by
 * @return     this*m
 * @throws     IllegalArgumentException
 *             if columnDimension(this) != rowDimension(m)
 */"
"public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
    try {
        return multiply((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        if (this.getColumnDimension() != m.getRowDimension()) {
            throw new IllegalArgumentException(""Matrices are not multiplication compatible."");
        }
        final int nRows = this.getRowDimension();
        final int nCols = m.getColumnDimension();
        final int nSum = this.getColumnDimension();
        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
        for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                BigDecimal sum = ZERO;
                for (int i = 0; i < nSum; i++) {
                    sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
                }
                outDataRow[col] = sum;
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test045102() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the result of postmultiplying this by <code>m</code>.
 * @param m    matrix to postmultiply by
 * @return     this*m
 * @throws     IllegalArgumentException
 *             if columnDimension(this) != rowDimension(m)
 */"
"public void luDecompose() throws InvalidMatrixException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (nRows != nCols) {
        throw new InvalidMatrixException(""LU decomposition requires that the matrix be square."");
    }
    lu = this.getData();
    // Initialize permutation array and parity
    permutation = new int[nRows];
    for (int row = 0; row < nRows; row++) {
        permutation[row] = row;
    }
    parity = 1;
    // Loop over columns
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        // upper
        for (int row = 0; row < col; row++) {
            final BigDecimal[] luRow = lu[row];
            sum = luRow[col];
            for (int i = 0; i < row; i++) {
                sum = sum.subtract(luRow[i].multiply(lu[i][col]));
            }
            luRow[col] = sum;
        }
        // lower
        // permutation row
        int max = col;
        BigDecimal largest = ZERO;
        for (int row = col; row < nRows; row++) {
            final BigDecimal[] luRow = lu[row];
            sum = luRow[col];
            for (int i = 0; i < col; i++) {
                sum = sum.subtract(luRow[i].multiply(lu[i][col]));
            }
            luRow[col] = sum;
            // maintain best permutation choice
            if (sum.abs().compareTo(largest) == 1) {
                largest = sum.abs();
                max = row;
            }
        }
        // Singularity check
        if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {
            lu = null;
            throw new InvalidMatrixException(""matrix is singular"");
        }
        // Pivot if necessary
        if (max != col) {
            BigDecimal tmp = ZERO;
            for (int i = 0; i < nCols; i++) {
                tmp = lu[max][i];
                lu[max][i] = lu[col][i];
                lu[col][i] = tmp;
            }
            int temp = permutation[max];
            permutation[max] = permutation[col];
            permutation[col] = temp;
            parity = -parity;
        }
        // Divide the lower elements by the ""winning"" diagonal elt.
        final BigDecimal luDiag = lu[col][col];
        for (int row = col + 1; row < nRows; row++) {
            final BigDecimal[] luRow = lu[row];
            luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);
        }
    }
}","public void test046103() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(64, 64);
    // Undeclared exception!
    try {
        bigMatrixImpl0.luDecompose();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Computes a new
 * <a href=""http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf"">
 * LU decompostion</a> for this matrix, storing the result for use by other methods.
 * <p>
 * <strong>Implementation Note</strong>:<br>
 * Uses <a href=""http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm"">
 * Crout's algortithm</a>, with partial pivoting.</p>
 * <p>
 * <strong>Usage Note</strong>:<br>
 * This method should rarely be invoked directly. Its only use is
 * to force recomputation of the LU decomposition when changes have been
 * made to the underlying data using direct array references. Changes
 * made using setXxx methods will trigger recomputation when needed
 * automatically.</p>
 *
 * @throws InvalidMatrixException if the matrix is non-square or singular.
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test047104() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.isSquare();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public boolean isSingular() {
    if (lu == null) {
        try {
            luDecompose();
            return false;
        } catch (InvalidMatrixException ex) {
            return true;
        }
    } else {
        // LU decomp must have been successfully performed
        // so the matrix is not singular
        return false;
    }
}","public void test048105() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.isSingular();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Is this a singular matrix?
 * @return true if the matrix is singular
 */"
"public boolean isSingular() {
    if (lu == null) {
        try {
            luDecompose();
            return false;
        } catch (InvalidMatrixException ex) {
            return true;
        }
    } else {
        // LU decomp must have been successfully performed
        // so the matrix is not singular
        return false;
    }
}","public void test049106() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.isSingular();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Is this a singular matrix?
 * @return true if the matrix is singular
 */"
"public int hashCode() {
    int ret = 7;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    ret = ret * 31 + nRows;
    ret = ret * 31 + nCols;
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            ret = ret * 31 + (11 * (row + 1) + 17 * (col + 1)) * dataRow[col].hashCode();
        }
    }
    return ret;
}","public void test050107() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.hashCode();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Computes a hashcode for the matrix.
 *
 * @return hashcode for matrix
 */"
"public int hashCode() {
    int ret = 7;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    ret = ret * 31 + nRows;
    ret = ret * 31 + nCols;
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            ret = ret * 31 + (11 * (row + 1) + 17 * (col + 1)) * dataRow[col].hashCode();
        }
    }
    return ret;
}","public void test051108() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.hashCode();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Computes a hashcode for the matrix.
 *
 * @return hashcode for matrix
 */"
"public BigDecimal getTrace() throws IllegalArgumentException {
    if (!isSquare()) {
        throw new IllegalArgumentException(""matrix is not square"");
    }
    BigDecimal trace = data[0][0];
    for (int i = 1; i < this.getRowDimension(); i++) {
        trace = trace.add(data[i][i]);
    }
    return trace;
}","public void test052109() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getTrace();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MatrixTrace.html"">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).
 *
 * @return trace
 *
 * @throws IllegalArgumentException if this matrix is not square.
 */"
"public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {
    if (selectedRows.length * selectedColumns.length == 0) {
        throw new MatrixIndexException(""selected row and column index arrays must be non-empty"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[selectedRows.length][selectedColumns.length];
    try {
        for (int i = 0; i < selectedRows.length; i++) {
            final BigDecimal[] subI = subMatrixData[i];
            final BigDecimal[] dataSelectedI = data[selectedRows[i]];
            for (int j = 0; j < selectedColumns.length; j++) {
                subI[j] = dataSelectedI[selectedColumns[j]];
            }
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new MatrixIndexException(""matrix dimension mismatch"");
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test053110() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int[] intArray0 = new int[9];
    try {
        bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param selectedRows Array of row indices must be non-empty
 * @param selectedColumns Array of column indices must be non-empty
 * @return The subMatrix containing the data in the
 *     specified rows and columns
 * @exception MatrixIndexException  if supplied row or column index arrays
 *     are not valid
 */"
"public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns) throws MatrixIndexException {
    if (selectedRows.length * selectedColumns.length == 0) {
        throw new MatrixIndexException(""selected row and column index arrays must be non-empty"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[selectedRows.length][selectedColumns.length];
    try {
        for (int i = 0; i < selectedRows.length; i++) {
            final BigDecimal[] subI = subMatrixData[i];
            final BigDecimal[] dataSelectedI = data[selectedRows[i]];
            for (int j = 0; j < selectedColumns.length; j++) {
                subI[j] = dataSelectedI[selectedColumns[j]];
            }
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new MatrixIndexException(""matrix dimension mismatch"");
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test054111() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    int[] intArray0 = new int[9];
    // Undeclared exception!
    try {
        bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param selectedRows Array of row indices must be non-empty
 * @param selectedColumns Array of column indices must be non-empty
 * @return The subMatrix containing the data in the
 *     specified rows and columns
 * @exception MatrixIndexException  if supplied row or column index arrays
 *     are not valid
 */"
"public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {
    if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
    for (int i = startRow; i <= endRow; i++) {
        System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1);
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test055112() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getSubMatrix(1, 1, 0, 4);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param startRow Initial row index
 * @param endRow Final row index
 * @param startColumn Initial column index
 * @param endColumn Final column index
 * @return The subMatrix containing the data of the
 *         specified rows and columns
 * @exception MatrixIndexException if row or column selections are not valid
 */"
"public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[][] out = new BigDecimal[1][ncols];
    System.arraycopy(data[row], 0, out[0], 0, ncols);
    return new BigMatrixImpl(out, false);
}","public void test056113() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getRowMatrix(1960);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in row number <code>row</code>
 * as a row matrix.  Row indices start at 0.
 *
 * @param row the row to be fetched
 * @return row matrix
 * @throws MatrixIndexException if the specified row index is invalid
 */"
"public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[][] out = new BigDecimal[1][ncols];
    System.arraycopy(data[row], 0, out[0], 0, ncols);
    return new BigMatrixImpl(out, false);
}","public void test057114() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getRowMatrix(0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in row number <code>row</code>
 * as a row matrix.  Row indices start at 0.
 *
 * @param row the row to be fetched
 * @return row matrix
 * @throws MatrixIndexException if the specified row index is invalid
 */"
"public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final double[] out = new double[ncols];
    for (int i = 0; i < ncols; i++) {
        out[i] = data[row][i].doubleValue();
    }
    return out;
}","public void test058115() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getRowAsDoubleArray(1916);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in row number <code>row</code> as an array
 * of double values.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public BigDecimal[] getRow(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[ncols];
    System.arraycopy(data[row], 0, out, 0, ncols);
    return out;
}","public void test059116() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getRow(0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in row number <code>row</code> as an array.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public BigDecimal getNorm() {
    BigDecimal maxColSum = ZERO;
    for (int col = 0; col < this.getColumnDimension(); col++) {
        BigDecimal sum = ZERO;
        for (int row = 0; row < this.getRowDimension(); row++) {
            sum = sum.add(data[row][col].abs());
        }
        maxColSum = maxColSum.max(sum);
    }
    return maxColSum;
}","public void test060117() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][9];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, true);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getNorm();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html"">
 * maximum absolute row sum norm</a> of the matrix.
 *
 * @return norm
 */"
"public BigDecimal getNorm() {
    BigDecimal maxColSum = ZERO;
    for (int col = 0; col < this.getColumnDimension(); col++) {
        BigDecimal sum = ZERO;
        for (int row = 0; row < this.getRowDimension(); row++) {
            sum = sum.add(data[row][col].abs());
        }
        maxColSum = maxColSum.max(sum);
    }
    return maxColSum;
}","public void test061118() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getNorm();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html"">
 * maximum absolute row sum norm</a> of the matrix.
 *
 * @return norm
 */"
"//------------------------ Protected methods
/**
 *  Returns the LU decomposition as a BigMatrix.
 *  Returns a fresh copy of the cached LU matrix if this has been computed;
 *  otherwise the composition is computed and cached for use by other methods.
 *  Since a copy is returned in either case, changes to the returned matrix do not
 *  affect the LU decomposition property.
 * <p>
 * The matrix returned is a compact representation of the LU decomposition.
 * Elements below the main diagonal correspond to entries of the ""L"" matrix;
 * elements on and above the main diagonal correspond to entries of the ""U""
 * matrix.</p>
 * <p>
 * Example: <pre>
 *
 *     Returned matrix                L                  U
 *         2  3  1                   1  0  0            2  3  1
 *         5  4  6                   5  1  0            0  4  6
 *         1  7  8                   1  7  1            0  0  8
 * </pre>
 *
 * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>
 *  where permuteRows reorders the rows of the matrix to follow the order determined
 *  by the <a href=#getPermutation()>permutation</a> property.</p>
 *
 * @return LU decomposition matrix
 * @throws InvalidMatrixException if the matrix is non-square or singular.
 */
protected BigMatrix getLUMatrix() throws InvalidMatrixException {
    if (lu == null) {
        luDecompose();
    }
    return new BigMatrixImpl(lu);
}","public void test062119() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[7][2];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getLUMatrix();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // LU decomposition requires that the matrix be square.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}",""
"//------------------------ Protected methods
/**
 *  Returns the LU decomposition as a BigMatrix.
 *  Returns a fresh copy of the cached LU matrix if this has been computed;
 *  otherwise the composition is computed and cached for use by other methods.
 *  Since a copy is returned in either case, changes to the returned matrix do not
 *  affect the LU decomposition property.
 * <p>
 * The matrix returned is a compact representation of the LU decomposition.
 * Elements below the main diagonal correspond to entries of the ""L"" matrix;
 * elements on and above the main diagonal correspond to entries of the ""U""
 * matrix.</p>
 * <p>
 * Example: <pre>
 *
 *     Returned matrix                L                  U
 *         2  3  1                   1  0  0            2  3  1
 *         5  4  6                   5  1  0            0  4  6
 *         1  7  8                   1  7  1            0  0  8
 * </pre>
 *
 * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>
 *  where permuteRows reorders the rows of the matrix to follow the order determined
 *  by the <a href=#getPermutation()>permutation</a> property.</p>
 *
 * @return LU decomposition matrix
 * @throws InvalidMatrixException if the matrix is non-square or singular.
 */
protected BigMatrix getLUMatrix() throws InvalidMatrixException {
    if (lu == null) {
        luDecompose();
    }
    return new BigMatrixImpl(lu);
}","public void test063120() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getLUMatrix();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//------------------------ Protected methods
/**
 *  Returns the LU decomposition as a BigMatrix.
 *  Returns a fresh copy of the cached LU matrix if this has been computed;
 *  otherwise the composition is computed and cached for use by other methods.
 *  Since a copy is returned in either case, changes to the returned matrix do not
 *  affect the LU decomposition property.
 * <p>
 * The matrix returned is a compact representation of the LU decomposition.
 * Elements below the main diagonal correspond to entries of the ""L"" matrix;
 * elements on and above the main diagonal correspond to entries of the ""U""
 * matrix.</p>
 * <p>
 * Example: <pre>
 *
 *     Returned matrix                L                  U
 *         2  3  1                   1  0  0            2  3  1
 *         5  4  6                   5  1  0            0  4  6
 *         1  7  8                   1  7  1            0  0  8
 * </pre>
 *
 * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>
 *  where permuteRows reorders the rows of the matrix to follow the order determined
 *  by the <a href=#getPermutation()>permutation</a> property.</p>
 *
 * @return LU decomposition matrix
 * @throws InvalidMatrixException if the matrix is non-square or singular.
 */
protected BigMatrix getLUMatrix() throws InvalidMatrixException {
    if (lu == null) {
        luDecompose();
    }
    return new BigMatrixImpl(lu);
}","public void test064121() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getLUMatrix();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public double getEntryAsDouble(int row, int column) throws MatrixIndexException {
    return getEntry(row, column).doubleValue();
}","public void test065122() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getEntryAsDouble((-16), (-16));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entry in the specified row and column as a double.
 * <p>
 * Row and column indices start at 0 and must satisfy
 * <ul>
 * <li><code>0 <= row < rowDimension</code></li>
 * <li><code> 0 <= column < columnDimension</code></li>
 * </ul>
 * otherwise a <code>MatrixIndexException</code> is thrown.</p>
 *
 * @param row  row location of entry to be fetched
 * @param column  column location of entry to be fetched
 * @return matrix entry in row,column
 * @throws MatrixIndexException if the row
 * or column index is not valid
 */"
"public BigDecimal getEntry(int row, int column) throws MatrixIndexException {
    try {
        return data[row][column];
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new MatrixIndexException(""matrix entry does not exist"");
    }
}","public void test066123() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getEntry((-2962), 75);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entry in the specified row and column.
 * <p>
 * Row and column indices start at 0 and must satisfy
 * <ul>
 * <li><code>0 <= row < rowDimension</code></li>
 * <li><code> 0 <= column < columnDimension</code></li>
 * </ul>
 * otherwise a <code>MatrixIndexException</code> is thrown.</p>
 *
 * @param row  row location of entry to be fetched
 * @param column  column location of entry to be fetched
 * @return matrix entry in row,column
 * @throws MatrixIndexException if the row or column index is not valid
 */"
"public BigDecimal getDeterminant() throws InvalidMatrixException {
    if (!isSquare()) {
        throw new InvalidMatrixException(""matrix is not square"");
    }
    if (isSingular()) {
        // note: this has side effect of attempting LU decomp if lu == null
        return ZERO;
    } else {
        BigDecimal det = (parity == 1) ? ONE : ONE.negate();
        for (int i = 0; i < this.getRowDimension(); i++) {
            det = det.multiply(lu[i][i]);
        }
        return det;
    }
}","public void test067124() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getDeterminant();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the determinant of this matrix.
 *
 * @return determinant
 * @throws InvalidMatrixException if matrix is not square
 */"
"public double[][] getDataAsDoubleArray() {
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    final double[][] d = new double[nRows][nCols];
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            d[i][j] = data[i][j].doubleValue();
        }
    }
    return d;
}","public void test068125() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getDataAsDoubleArray();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns matrix entries as a two-dimensional array.
 * <p>
 * Makes a fresh copy of the underlying data converted to
 * <code>double</code> values.</p>
 *
 * @return    2-dimensional array of entries
 */"
"public double[][] getDataAsDoubleArray() {
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    final double[][] d = new double[nRows][nCols];
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            d[i][j] = data[i][j].doubleValue();
        }
    }
    return d;
}","public void test069126() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getDataAsDoubleArray();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns matrix entries as a two-dimensional array.
 * <p>
 * Makes a fresh copy of the underlying data converted to
 * <code>double</code> values.</p>
 *
 * @return    2-dimensional array of entries
 */"
"public BigDecimal[][] getData() {
    return copyOut();
}","public void test070127() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getData();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns matrix entries as a two-dimensional array.
 * <p>
 * Makes a fresh copy of the underlying data.</p>
 *
 * @return    2-dimensional array of entries
 */"
"public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
    if (!isValidCoordinate(0, column)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[][] out = new BigDecimal[nRows][1];
    for (int row = 0; row < nRows; row++) {
        out[row][0] = data[row][column];
    }
    return new BigMatrixImpl(out, false);
}","public void test071128() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnMatrix(0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in column number <code>column</code>
 * as a column matrix.  Column indices start at 0.
 *
 * @param column the column to be fetched
 * @return column matrix
 * @throws MatrixIndexException if the specified column index is invalid
 */"
"public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
    if (!isValidCoordinate(0, column)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[][] out = new BigDecimal[nRows][1];
    for (int row = 0; row < nRows; row++) {
        out[row][0] = data[row][column];
    }
    return new BigMatrixImpl(out, false);
}","public void test072129() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnMatrix((-1));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in column number <code>column</code>
 * as a column matrix.  Column indices start at 0.
 *
 * @param column the column to be fetched
 * @return column matrix
 * @throws MatrixIndexException if the specified column index is invalid
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test073130() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnDimension();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nrows = this.getRowDimension();
    final double[] out = new double[nrows];
    for (int i = 0; i < nrows; i++) {
        out[i] = data[i][col].doubleValue();
    }
    return out;
}","public void test074131() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnAsDoubleArray((-1));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array
 * of double values.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nrows = this.getRowDimension();
    final double[] out = new double[nrows];
    for (int i = 0; i < nrows; i++) {
        out[i] = data[i][col].doubleValue();
    }
    return out;
}","public void test075132() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnAsDoubleArray((-403));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array
 * of double values.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public BigDecimal[] getColumn(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int i = 0; i < nRows; i++) {
        out[i] = data[i][col];
    }
    return out;
}","public void test076133() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumn(0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test077134() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.equals(bigMatrixImpl1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public BigMatrix copy() {
    return new BigMatrixImpl(this.copyOut(), false);
}","public void test078135() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.copy();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new BigMatrix which is a copy of this.
 *
 * @return  the cloned matrix
 */"
"public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test079136() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.add((BigMatrixImpl) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
    try {
        return add((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test080137() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
    try {
        return add((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test081138() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.add((BigMatrix) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test082139() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((BigDecimal[][]) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public BigMatrixImpl(BigDecimal[][] d) {
    this.copyIn(d);
    lu = null;
}","public void test083140() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((BigDecimal[][]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>The input array is copied, not referenced. This constructor has
 * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}
 * with the second argument set to <code>true</code>.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(String[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test084141() throws Throwable {
    String[][] stringArray0 = new String[1][4];
    String[] stringArray1 = new String[9];
    stringArray1[0] = ""EOdo$1A>M*I"";
    stringArray0[0] = stringArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(stringArray0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Create a new BigMatrix using the values represented by the strings in
 * <code>d</code> as the underlying data array.
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(double[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test085142() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((double[][]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>Since the underlying array will hold <code>BigDecimal</code>
 * instances, it will be created.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(BigDecimal[] v) {
    final int nRows = v.length;
    data = new BigDecimal[nRows][1];
    for (int row = 0; row < nRows; row++) {
        data[row][0] = v[row];
    }
}","public void test086143() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((BigDecimal[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new (column) BigMatrix using <code>v</code> as the
 * data for the unique column of the <code>v.length x 1</code> matrix
 * created.
 * <p>
 * The input array is copied, not referenced.</p>
 *
 * @param v column vector holding data for new matrix
 */"
"public void luDecompose() throws InvalidMatrixException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (nRows != nCols) {
        throw new InvalidMatrixException(""LU decomposition requires that the matrix be square."");
    }
    lu = this.getData();
    // Initialize permutation array and parity
    permutation = new int[nRows];
    for (int row = 0; row < nRows; row++) {
        permutation[row] = row;
    }
    parity = 1;
    // Loop over columns
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        // upper
        for (int row = 0; row < col; row++) {
            final BigDecimal[] luRow = lu[row];
            sum = luRow[col];
            for (int i = 0; i < row; i++) {
                sum = sum.subtract(luRow[i].multiply(lu[i][col]));
            }
            luRow[col] = sum;
        }
        // lower
        // permutation row
        int max = col;
        BigDecimal largest = ZERO;
        for (int row = col; row < nRows; row++) {
            final BigDecimal[] luRow = lu[row];
            sum = luRow[col];
            for (int i = 0; i < col; i++) {
                sum = sum.subtract(luRow[i].multiply(lu[i][col]));
            }
            luRow[col] = sum;
            // maintain best permutation choice
            if (sum.abs().compareTo(largest) == 1) {
                largest = sum.abs();
                max = row;
            }
        }
        // Singularity check
        if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {
            lu = null;
            throw new InvalidMatrixException(""matrix is singular"");
        }
        // Pivot if necessary
        if (max != col) {
            BigDecimal tmp = ZERO;
            for (int i = 0; i < nCols; i++) {
                tmp = lu[max][i];
                lu[max][i] = lu[col][i];
                lu[col][i] = tmp;
            }
            int temp = permutation[max];
            permutation[max] = permutation[col];
            permutation[col] = temp;
            parity = -parity;
        }
        // Divide the lower elements by the ""winning"" diagonal elt.
        final BigDecimal luDiag = lu[col][col];
        for (int row = col + 1; row < nRows; row++) {
            final BigDecimal[] luRow = lu[row];
            luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);
        }
    }
}","public void test087144() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[7];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.luDecompose();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // LU decomposition requires that the matrix be square.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Computes a new
 * <a href=""http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf"">
 * LU decompostion</a> for this matrix, storing the result for use by other methods.
 * <p>
 * <strong>Implementation Note</strong>:<br>
 * Uses <a href=""http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm"">
 * Crout's algortithm</a>, with partial pivoting.</p>
 * <p>
 * <strong>Usage Note</strong>:<br>
 * This method should rarely be invoked directly. Its only use is
 * to force recomputation of the LU decomposition when changes have been
 * made to the underlying data using direct array references. Changes
 * made using setXxx methods will trigger recomputation when needed
 * automatically.</p>
 *
 * @throws InvalidMatrixException if the matrix is non-square or singular.
 */"
"public int getScale() {
    return scale;
}","public void test088145() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test088146() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test088147() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test088148() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != this.getRowDimension()) {
        throw new IllegalArgumentException(""Incorrect row dimension"");
    }
    if (!this.isSquare()) {
        throw new InvalidMatrixException(""coefficient matrix is not square"");
    }
    if (this.isSingular()) {
        // side effect: compute LU decomp
        throw new InvalidMatrixException(""Matrix is singular."");
    }
    final int nCol = this.getColumnDimension();
    final int nColB = b.getColumnDimension();
    final int nRowB = b.getRowDimension();
    // Apply permutations to b
    final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
    for (int row = 0; row < nRowB; row++) {
        final BigDecimal[] bpRow = bp[row];
        for (int col = 0; col < nColB; col++) {
            bpRow[col] = b.getEntry(permutation[row], col);
        }
    }
    // Solve LY = b
    for (int col = 0; col < nCol; col++) {
        for (int i = col + 1; i < nCol; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    // Solve UX = Y
    for (int col = nCol - 1; col >= 0; col--) {
        final BigDecimal[] bpCol = bp[col];
        final BigDecimal luDiag = lu[col][col];
        for (int j = 0; j < nColB; j++) {
            bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
        }
        for (int i = 0; i < col; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    return new BigMatrixImpl(bp, false);
}","public void test089149() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  matrix of constant vectors forming RHS of linear systems to
 * to solve
 * @return matrix of solution vectors
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
    final int nRows = this.getRowDimension();
    if (b.length != nRows) {
        throw new IllegalArgumentException(""constant vector has wrong length"");
    }
    final BigMatrix bMatrix = new BigMatrixImpl(b);
    final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int row = 0; row < nRows; row++) {
        out[row] = solution[row][0];
    }
    return out;
}","public void test090150() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(777, 1120);
    BigDecimal[] bigDecimalArray0 = new BigDecimal[6];
    try {
        bigMatrixImpl0.solve(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // constant vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  array of constants forming RHS of linear systems to
 * to solve
 * @return solution array
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test091151() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[][] bigDecimalArray0 = bigMatrixImpl0.getDataRef();
    bigMatrixImpl0.lu = bigDecimalArray0;
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test091152() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[][] bigDecimalArray0 = bigMatrixImpl0.getDataRef();
    bigMatrixImpl0.lu = bigDecimalArray0;
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public boolean isSingular() {
    if (lu == null) {
        try {
            luDecompose();
            return false;
        } catch (InvalidMatrixException ex) {
            return true;
        }
    } else {
        // LU decomp must have been successfully performed
        // so the matrix is not singular
        return false;
    }
}","public void test091153() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[][] bigDecimalArray0 = bigMatrixImpl0.getDataRef();
    bigMatrixImpl0.lu = bigDecimalArray0;
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertFalse(boolean0);
}","/**
 * Is this a singular matrix?
 * @return true if the matrix is singular
 */"
"public int getScale() {
    return scale;
}","public void test091154() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[][] bigDecimalArray0 = bigMatrixImpl0.getDataRef();
    bigMatrixImpl0.lu = bigDecimalArray0;
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test092155() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    boolean boolean0 = bigMatrixImpl0.isSquare();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test092156() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    boolean boolean0 = bigMatrixImpl0.isSquare();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test092157() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    boolean boolean0 = bigMatrixImpl0.isSquare();
    assertFalse(boolean0);
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public int getScale() {
    return scale;
}","public void test093158() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.isSquare();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test093159() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.isSquare();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {
    if (this.getColumnDimension() != m.getRowDimension()) {
        throw new IllegalArgumentException(""Matrices are not multiplication compatible."");
    }
    final int nRows = this.getRowDimension();
    final int nCols = m.getColumnDimension();
    final int nSum = this.getColumnDimension();
    final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < nCols; col++) {
            BigDecimal sum = ZERO;
            for (int i = 0; i < nSum; i++) {
                sum = sum.add(dataRow[i].multiply(m.data[i][col]));
            }
            outDataRow[col] = sum;
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test094160() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.multiply(bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrices are not multiplication compatible.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of postmultiplying this by <code>m</code>.
 * @param m    matrix to postmultiply by
 * @return     this*m
 * @throws     IllegalArgumentException
 *             if columnDimension(this) != rowDimension(m)
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test095161() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test095162() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test095163() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test095164() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertFalse(bigMatrixImpl1.equals((Object) bigMatrixImpl0));
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getScale() {
    return scale;
}","public void test095165() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.subtract(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].subtract(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test096166() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.subtract(bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].subtract(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test097167() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(121, 121);
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[7][2];
    BigMatrixImpl bigMatrixImpl1 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl1.subtract(bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public int getScale() {
    return scale;
}","public void test098168() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test098169() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test098170() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test098171() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.add(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test099172() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.add(bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test100173() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getRowMatrix(1);
    try {
        bigMatrixImpl1.add(bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test101174() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test101175() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test102176() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getData();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test102177() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getData();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigDecimal getEntry(int row, int column) throws MatrixIndexException {
    try {
        return data[row][column];
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new MatrixIndexException(""matrix entry does not exist"");
    }
}","public void test103178() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getEntry(121, 0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix entry does not exist
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entry in the specified row and column.
 * <p>
 * Row and column indices start at 0 and must satisfy
 * <ul>
 * <li><code>0 <= row < rowDimension</code></li>
 * <li><code> 0 <= column < columnDimension</code></li>
 * </ul>
 * otherwise a <code>MatrixIndexException</code> is thrown.</p>
 *
 * @param row  row location of entry to be fetched
 * @param column  column location of entry to be fetched
 * @return matrix entry in row,column
 * @throws MatrixIndexException if the row or column index is not valid
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test104179() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getColumnDimension();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test105180() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getRowDimension();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test105181() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.getRowDimension();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test106182() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getLUMatrix();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test106183() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getLUMatrix();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test106184() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getLUMatrix();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test106185() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getLUMatrix();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test107186() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.hashCode();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test107187() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.hashCode();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test108188() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = new BigDecimal(0L);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    boolean boolean0 = bigMatrixImpl1.equals(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test108189() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = new BigDecimal(0L);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    boolean boolean0 = bigMatrixImpl1.equals(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test108190() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = new BigDecimal(0L);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    boolean boolean0 = bigMatrixImpl1.equals(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test108191() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = new BigDecimal(0L);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    boolean boolean0 = bigMatrixImpl1.equals(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test108192() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = new BigDecimal(0L);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarMultiply(bigDecimal0);
    boolean boolean0 = bigMatrixImpl1.equals(bigMatrixImpl0);
    assertTrue(boolean0);
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test109193() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.equals(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test109194() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.equals(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test109195() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.equals(bigMatrixImpl0);
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test109196() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.equals(bigMatrixImpl0);
    assertTrue(boolean0);
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test110197() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    Object object0 = new Object();
    boolean boolean0 = bigMatrixImpl0.equals(object0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test110198() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    Object object0 = new Object();
    boolean boolean0 = bigMatrixImpl0.equals(object0);
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getScale() {
    return scale;
}","public void test110199() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    Object object0 = new Object();
    boolean boolean0 = bigMatrixImpl0.equals(object0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test110200() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    Object object0 = new Object();
    boolean boolean0 = bigMatrixImpl0.equals(object0);
    assertFalse(boolean0);
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public int getScale() {
    return scale;
}","public void test111201() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public String toString() {
    StringBuffer res = new StringBuffer();
    res.append(""BigMatrixImpl{"");
    if (data != null) {
        for (int i = 0; i < data.length; i++) {
            if (i > 0) {
                res.append("","");
            }
            res.append(""{"");
            for (int j = 0; j < data[0].length; j++) {
                if (j > 0) {
                    res.append("","");
                }
                res.append(data[i][j]);
            }
            res.append(""}"");
        }
    }
    res.append(""}"");
    return res.toString();
}","public void test111202() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(""BigMatrixImpl{{0,0,0,0,0}}"", string0);
}","/**
 * Get a string representation for this matrix.
 * @return a string representation for this matrix
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test111203() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public String toString() {
    StringBuffer res = new StringBuffer();
    res.append(""BigMatrixImpl{"");
    if (data != null) {
        for (int i = 0; i < data.length; i++) {
            if (i > 0) {
                res.append("","");
            }
            res.append(""{"");
            for (int j = 0; j < data[0].length; j++) {
                if (j > 0) {
                    res.append("","");
                }
                res.append(data[i][j]);
            }
            res.append(""}"");
        }
    }
    res.append(""}"");
    return res.toString();
}","public void test112204() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(""BigMatrixImpl{{null},{null},{null}}"", string0);
}","/**
 * Get a string representation for this matrix.
 * @return a string representation for this matrix
 */"
"public int getScale() {
    return scale;
}","public void test112205() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test112206() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    String string0 = bigMatrixImpl0.toString();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test113207() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test113208() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.data = null;
    String string0 = bigMatrixImpl0.toString();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public String toString() {
    StringBuffer res = new StringBuffer();
    res.append(""BigMatrixImpl{"");
    if (data != null) {
        for (int i = 0; i < data.length; i++) {
            if (i > 0) {
                res.append("","");
            }
            res.append(""{"");
            for (int j = 0; j < data[0].length; j++) {
                if (j > 0) {
                    res.append("","");
                }
                res.append(data[i][j]);
            }
            res.append(""}"");
        }
    }
    res.append(""}"");
    return res.toString();
}","public void test113209() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.data = null;
    String string0 = bigMatrixImpl0.toString();
    assertEquals(""BigMatrixImpl{}"", string0);
}","/**
 * Get a string representation for this matrix.
 * @return a string representation for this matrix
 */"
"public int getScale() {
    return scale;
}","public void test113210() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.data = null;
    String string0 = bigMatrixImpl0.toString();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSingular() {
    if (lu == null) {
        try {
            luDecompose();
            return false;
        } catch (InvalidMatrixException ex) {
            return true;
        }
    } else {
        // LU decomp must have been successfully performed
        // so the matrix is not singular
        return false;
    }
}","public void test114211() throws Throwable {
    double[][] doubleArray0 = new double[1][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertTrue(boolean0);
}","/**
 * Is this a singular matrix?
 * @return true if the matrix is singular
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test114212() throws Throwable {
    double[][] doubleArray0 = new double[1][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test114213() throws Throwable {
    double[][] doubleArray0 = new double[1][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    boolean boolean0 = bigMatrixImpl0.isSingular();
    assertEquals(8, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public BigMatrix inverse() throws InvalidMatrixException {
    return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));
}","public void test115214() throws Throwable {
    double[][] doubleArray0 = new double[8][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.inverse();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // Matrix is singular.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the inverse matrix if this matrix is invertible.
 *
 * @return inverse matrix
 * @throws InvalidMatrixException if this is not invertible
 */"
"public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != this.getRowDimension()) {
        throw new IllegalArgumentException(""Incorrect row dimension"");
    }
    if (!this.isSquare()) {
        throw new InvalidMatrixException(""coefficient matrix is not square"");
    }
    if (this.isSingular()) {
        // side effect: compute LU decomp
        throw new InvalidMatrixException(""Matrix is singular."");
    }
    final int nCol = this.getColumnDimension();
    final int nColB = b.getColumnDimension();
    final int nRowB = b.getRowDimension();
    // Apply permutations to b
    final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
    for (int row = 0; row < nRowB; row++) {
        final BigDecimal[] bpRow = bp[row];
        for (int col = 0; col < nColB; col++) {
            bpRow[col] = b.getEntry(permutation[row], col);
        }
    }
    // Solve LY = b
    for (int col = 0; col < nCol; col++) {
        for (int i = col + 1; i < nCol; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    // Solve UX = Y
    for (int col = nCol - 1; col >= 0; col--) {
        final BigDecimal[] bpCol = bp[col];
        final BigDecimal luDiag = lu[col][col];
        for (int j = 0; j < nColB; j++) {
            bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
        }
        for (int i = 0; i < col; i++) {
            final BigDecimal[] bpI = bp[i];
            final BigDecimal[] luI = lu[i];
            for (int j = 0; j < nColB; j++) {
                bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
            }
        }
    }
    return new BigMatrixImpl(bp, false);
}","public void test116215() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.solve((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // coefficient matrix is not square
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  matrix of constant vectors forming RHS of linear systems to
 * to solve
 * @return matrix of solution vectors
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;","public void test117216() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    try {
        bigMatrix0.solve((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Incorrect row dimension
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  matrix of constant vectors forming RHS of linear systems to
 * to solve
 * @return matrix of solution vectors
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular
 */"
"public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
    final BigDecimal[] bd = new BigDecimal[b.length];
    for (int i = 0; i < bd.length; i++) {
        bd[i] = new BigDecimal(b[i]);
    }
    return solve(bd);
}","public void test118217() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    double[] doubleArray0 = new double[4];
    try {
        bigMatrixImpl0.solve(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // constant vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns a matrix of (column) solution vectors for linear systems with
 * coefficient matrix = this and constant vectors = columns of
 * <code>b</code>.
 *
 * @param b  array of constants forming RHS of linear systems to
 * to solve
 * @return solution array
 * @throws IllegalArgumentException if this.rowDimension != row dimension
 * @throws InvalidMatrixException if this matrix is not square or is singular
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test119218() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.preMultiply(bigDecimalArray0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    if (v.length != nRows) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nCols];
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nRows; i++) {
            sum = sum.add(data[i][col].multiply(v[i]));
        }
        out[col] = sum;
    }
    return out;
}","public void test119219() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.preMultiply(bigDecimalArray0);
    assertEquals(1, bigDecimalArray1.length);
}","/**
 * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
 *
 * @param v the row vector to premultiply by
 * @return v*this
 * @throws IllegalArgumentException if rowDimension != v.size()
 */"
"public int getScale() {
    return scale;
}","public void test119221() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.preMultiply(bigDecimalArray0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    if (v.length != nRows) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nCols];
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nRows; i++) {
            sum = sum.add(data[i][col].multiply(v[i]));
        }
        out[col] = sum;
    }
    return out;
}","public void test120222() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(130, 130);
    BigDecimal[] bigDecimalArray0 = new BigDecimal[5];
    try {
        bigMatrixImpl0.preMultiply(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
 *
 * @param v the row vector to premultiply by
 * @return v*this
 * @throws IllegalArgumentException if rowDimension != v.size()
 */"
"public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    if (v.length != nRows) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nCols];
    for (int col = 0; col < nCols; col++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nRows; i++) {
            sum = sum.add(data[i][col].multiply(v[i]));
        }
        out[col] = sum;
    }
    return out;
}","public void test121223() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.preMultiply(bigDecimalArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.
 *
 * @param v the row vector to premultiply by
 * @return v*this
 * @throws IllegalArgumentException if rowDimension != v.size()
 */"
"public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
    final BigDecimal[] bd = new BigDecimal[v.length];
    for (int i = 0; i < bd.length; i++) {
        bd[i] = new BigDecimal(v[i]);
    }
    return operate(bd);
}","public void test122224() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.operate(doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // vector has wrong length
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public int getScale() {
    return scale;
}","public void test123225() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.operate(bigDecimalArray0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}","public void test123226() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.operate(bigDecimalArray0);
    assertNotSame(bigDecimalArray1, bigDecimalArray0);
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test123227() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.operate(bigDecimalArray0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}","public void test124228() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.operate(bigDecimalArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */"
"public BigDecimal getTrace() throws IllegalArgumentException {
    if (!isSquare()) {
        throw new IllegalArgumentException(""matrix is not square"");
    }
    BigDecimal trace = data[0][0];
    for (int i = 1; i < this.getRowDimension(); i++) {
        trace = trace.add(data[i][i]);
    }
    return trace;
}","public void test125229() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(297, 297);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getTrace();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MatrixTrace.html"">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).
 *
 * @return trace
 *
 * @throws IllegalArgumentException if this matrix is not square.
 */"
"public BigDecimal getTrace() throws IllegalArgumentException {
    if (!isSquare()) {
        throw new IllegalArgumentException(""matrix is not square"");
    }
    BigDecimal trace = data[0][0];
    for (int i = 1; i < this.getRowDimension(); i++) {
        trace = trace.add(data[i][i]);
    }
    return trace;
}","public void test126230() throws Throwable {
    double[][] doubleArray0 = new double[1][0];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.getTrace();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix is not square
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MatrixTrace.html"">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).
 *
 * @return trace
 *
 * @throws IllegalArgumentException if this matrix is not square.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test127231() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    bigMatrixImpl0.solve(bigDecimalArray0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test127232() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    bigMatrixImpl0.luDecompose();
    bigMatrixImpl0.solve(bigDecimalArray0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test128233() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    assertTrue(bigMatrixImpl0.isSquare());
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test128234() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getDeterminant();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigDecimal getDeterminant() throws InvalidMatrixException {
    if (!isSquare()) {
        throw new InvalidMatrixException(""matrix is not square"");
    }
    if (isSingular()) {
        // note: this has side effect of attempting LU decomp if lu == null
        return ZERO;
    } else {
        BigDecimal det = (parity == 1) ? ONE : ONE.negate();
        for (int i = 0; i < this.getRowDimension(); i++) {
            det = det.multiply(lu[i][i]);
        }
        return det;
    }
}","public void test128235() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getDeterminant();
    assertNotSame(bigDecimal1, bigDecimal0);
}","/**
 * Returns the determinant of this matrix.
 *
 * @return determinant
 * @throws InvalidMatrixException if matrix is not square
 */"
"public int getScale() {
    return scale;
}","public void test128236() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigMatrixImpl.ONE;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal bigDecimal1 = bigMatrixImpl0.getDeterminant();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal getDeterminant() throws InvalidMatrixException {
    if (!isSquare()) {
        throw new InvalidMatrixException(""matrix is not square"");
    }
    if (isSingular()) {
        // note: this has side effect of attempting LU decomp if lu == null
        return ZERO;
    } else {
        BigDecimal det = (parity == 1) ? ONE : ONE.negate();
        for (int i = 0; i < this.getRowDimension(); i++) {
            det = det.multiply(lu[i][i]);
        }
        return det;
    }
}","public void test129238() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.getDeterminant();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix is not square
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the determinant of this matrix.
 *
 * @return determinant
 * @throws InvalidMatrixException if matrix is not square
 */"
"public BigDecimal getDeterminant() throws InvalidMatrixException {
    if (!isSquare()) {
        throw new InvalidMatrixException(""matrix is not square"");
    }
    if (isSingular()) {
        // note: this has side effect of attempting LU decomp if lu == null
        return ZERO;
    } else {
        BigDecimal det = (parity == 1) ? ONE : ONE.negate();
        for (int i = 0; i < this.getRowDimension(); i++) {
            det = det.multiply(lu[i][i]);
        }
        return det;
    }
}","public void test130239() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getDeterminant();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the determinant of this matrix.
 *
 * @return determinant
 * @throws InvalidMatrixException if matrix is not square
 */"
"public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nrows = this.getRowDimension();
    final double[] out = new double[nrows];
    for (int i = 0; i < nrows; i++) {
        out[i] = data[i][col].doubleValue();
    }
    return out;
}","public void test131240() throws Throwable {
    double[][] doubleArray0 = new double[1][4];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.getColumnAsDoubleArray((-2818));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal column argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array
 * of double values.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public int getScale() {
    return scale;
}","public void test132241() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getColumnAsDoubleArray(1);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test132242() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getColumnAsDoubleArray(1);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test132243() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.getColumnAsDoubleArray(1);
    assertEquals(8, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public BigDecimal[] getColumn(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int i = 0; i < nRows; i++) {
        out[i] = data[i][col];
    }
    return out;
}","public void test133244() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getColumn(1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal column argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in column number <code>col</code> as an array.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public BigDecimal[] getColumn(int col) throws MatrixIndexException {
    if (!isValidCoordinate(0, col)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int i = 0; i < nRows; i++) {
        out[i] = data[i][col];
    }
    return out;
}","public void test134245() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigDecimal[] bigDecimalArray0 = bigMatrixImpl0.getColumn(11);
    assertEquals(2912, bigDecimalArray0.length);
}","/**
 * Returns the entries in column number <code>col</code> as an array.
 * <p>
 * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= column < columnDimension.</code></p>
 *
 * @param col the column to be fetched
 * @return array of entries in the column
 * @throws MatrixIndexException if the specified column index is not valid
 */"
"public int getScale() {
    return scale;
}","public void test134246() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigDecimal[] bigDecimalArray0 = bigMatrixImpl0.getColumn(11);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test134247() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigDecimal[] bigDecimalArray0 = bigMatrixImpl0.getColumn(11);
    assertTrue(bigMatrixImpl0.isSquare());
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test134248() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigDecimal[] bigDecimalArray0 = bigMatrixImpl0.getColumn(11);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test135249() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[1] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    double[] doubleArray0 = bigMatrixImpl0.getRowAsDoubleArray(1);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test135250() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[1] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    double[] doubleArray0 = bigMatrixImpl0.getRowAsDoubleArray(1);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final double[] out = new double[ncols];
    for (int i = 0; i < ncols; i++) {
        out[i] = data[row][i].doubleValue();
    }
    return out;
}","public void test135251() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[1] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    double[] doubleArray0 = bigMatrixImpl0.getRowAsDoubleArray(1);
    assertEquals(1, doubleArray0.length);
}","/**
 * Returns the entries in row number <code>row</code> as an array
 * of double values.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final double[] out = new double[ncols];
    for (int i = 0; i < ncols; i++) {
        out[i] = data[row][i].doubleValue();
    }
    return out;
}","public void test136252() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(155, 155);
    try {
        bigMatrixImpl0.getRowAsDoubleArray(155);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal row argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in row number <code>row</code> as an array
 * of double values.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final double[] out = new double[ncols];
    for (int i = 0; i < ncols; i++) {
        out[i] = data[row][i].doubleValue();
    }
    return out;
}","public void test137253() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getRowAsDoubleArray(1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in row number <code>row</code> as an array
 * of double values.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public BigDecimal[] getRow(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[ncols];
    System.arraycopy(data[row], 0, out, 0, ncols);
    return out;
}","public void test138254() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getRow(64);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal row argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in row number <code>row</code> as an array.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public int getScale() {
    return scale;
}","public void test139255() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.getRow(0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal[] getRow(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[ncols];
    System.arraycopy(data[row], 0, out, 0, ncols);
    return out;
}","public void test139256() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.getRow(0);
    assertEquals(1, bigDecimalArray1.length);
}","/**
 * Returns the entries in row number <code>row</code> as an array.
 * <p>
 * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown
 * unless <code>0 <= row < rowDimension.</code></p>
 *
 * @param row the row to be fetched
 * @return array of entries in the row
 * @throws MatrixIndexException if the specified row index is not valid
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test139257() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[] bigDecimalArray1 = bigMatrixImpl0.getRow(0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
    if (!isValidCoordinate(0, column)) {
        throw new MatrixIndexException(""illegal column argument"");
    }
    final int nRows = this.getRowDimension();
    final BigDecimal[][] out = new BigDecimal[nRows][1];
    for (int row = 0; row < nRows; row++) {
        out[row][0] = data[row][column];
    }
    return new BigMatrixImpl(out, false);
}","public void test140258() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[12];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getColumnMatrix((-3914));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal column argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in column number <code>column</code>
 * as a column matrix.  Column indices start at 0.
 *
 * @param column the column to be fetched
 * @return column matrix
 * @throws MatrixIndexException if the specified column index is invalid
 */"
"public int getRowDimension() {
    return data.length;
}","public void test141259() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    assertEquals(1, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public boolean isSquare() {
    return (this.getColumnDimension() == this.getRowDimension());
}","public void test141260() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    assertTrue(bigMatrixImpl1.isSquare());
}","/**
 * Is this a square matrix?
 * @return true if the matrix is square (rowDimension = columnDimension)
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test141261() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    BigDecimal bigDecimal0 = bigMatrixImpl1.getTrace();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test141262() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    BigDecimal bigDecimal0 = bigMatrixImpl1.getTrace();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test141263() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    BigDecimal bigDecimal0 = bigMatrixImpl1.getTrace();
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public BigDecimal getTrace() throws IllegalArgumentException {
    if (!isSquare()) {
        throw new IllegalArgumentException(""matrix is not square"");
    }
    BigDecimal trace = data[0][0];
    for (int i = 1; i < this.getRowDimension(); i++) {
        trace = trace.add(data[i][i]);
    }
    return trace;
}","public void test141264() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    BigDecimal bigDecimal0 = bigMatrixImpl1.getTrace();
    assertNotNull(bigDecimal0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/MatrixTrace.html"">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).
 *
 * @return trace
 *
 * @throws IllegalArgumentException if this matrix is not square.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test141265() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    double[] doubleArray1 = new double[7];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getColumnMatrix(6);
    BigDecimal bigDecimal0 = bigMatrixImpl1.getTrace();
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
    if (!isValidCoordinate(row, 0)) {
        throw new MatrixIndexException(""illegal row argument"");
    }
    final int ncols = this.getColumnDimension();
    final BigDecimal[][] out = new BigDecimal[1][ncols];
    System.arraycopy(data[row], 0, out[0], 0, ncols);
    return new BigMatrixImpl(out, false);
}","public void test142266() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    try {
        bigMatrixImpl0.getRowMatrix((-14));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // illegal row argument
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entries in row number <code>row</code>
 * as a row matrix.  Row indices start at 0.
 *
 * @param row the row to be fetched
 * @return row matrix
 * @throws MatrixIndexException if the specified row index is invalid
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test143267() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[][] bigDecimalArray1 = new BigDecimal[5][3];
    bigDecimalArray1[0] = bigDecimalArray0;
    bigDecimalArray1[1] = bigDecimalArray0;
    bigDecimalArray1[2] = bigDecimalArray0;
    bigDecimalArray1[3] = bigDecimalArray0;
    bigDecimalArray1[4] = bigDecimalArray0;
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray1, 1, 0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test144268() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[1][2];
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray0, 0, 1082);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix must be initialized to perfom this method
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test145269() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][9];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray0, 1396, 1396);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix must be initialized to perfom this method
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test146270() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal[][] bigDecimalArray0 = bigMatrixImpl0.getDataRef();
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray0, 0, 1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test147271() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[][] bigDecimalArray1 = new BigDecimal[5][3];
    bigDecimalArray1[0] = bigDecimalArray0;
    // Undeclared exception!
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray1, 1, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public BigMatrixImpl(BigDecimal[][] d) {
    this.copyIn(d);
    lu = null;
}","public void test148272() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[4][0];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one column.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>The input array is copied, not referenced. This constructor has
 * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}
 * with the second argument set to <code>true</code>.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(BigDecimal[][] d) {
    this.copyIn(d);
    lu = null;
}","public void test149273() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[0][7];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>The input array is copied, not referenced. This constructor has
 * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}
 * with the second argument set to <code>true</code>.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test150274() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigDecimal[][] bigDecimalArray1 = new BigDecimal[5][3];
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray1, 1, (-24));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) throws MatrixIndexException {
    if ((row < 0) || (column < 0)) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final int nRows = subMatrix.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = subMatrix[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int r = 1; r < nRows; r++) {
        if (subMatrix[r].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    if (data == null) {
        if ((row > 0) || (column > 0))
            throw new MatrixIndexException(""matrix must be initialized to perfom this method"");
        data = new BigDecimal[nRows][nCols];
        System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);
    }
    if (((nRows + row) > this.getRowDimension()) || (nCols + column > this.getColumnDimension()))
        throw new MatrixIndexException(""invalid row or column index selection"");
    for (int i = 0; i < nRows; i++) {
        System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
    }
    lu = null;
}","public void test151275() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][9];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, true);
    try {
        bigMatrixImpl0.setSubMatrix(bigDecimalArray0, (-1), 11);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Replace the submatrix starting at <code>row, column</code> using data in
 * the input <code>subMatrix</code> array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p>
 *
 * @param subMatrix  array containing the submatrix replacement data
 * @param row  row coordinate of the top, left element to be replaced
 * @param column  column coordinate of the top, left element to be replaced
 * @throws MatrixIndexException  if subMatrix does not fit into this
 *    matrix from element in (row, column)
 * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>subMatrix</code> is null
 * @since 1.1
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test152276() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test152277() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test152278() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRowDimension() {
    return data.length;
}","public void test152279() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(4, bigMatrixImpl1.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public int getScale() {
    return scale;
}","public void test152280() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRowDimension() {
    return data.length;
}","public void test152281() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    int[] intArray0 = new int[4];
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.getSubMatrix(intArray0, intArray0);
    assertEquals(3, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {
    if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
    for (int i = startRow; i <= endRow; i++) {
        System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1);
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test153282() throws Throwable {
    double[][] doubleArray0 = new double[1][6];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    try {
        bigMatrixImpl0.getSubMatrix(0, 31, 0, 0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param startRow Initial row index
 * @param endRow Final row index
 * @param startColumn Initial column index
 * @param endColumn Final column index
 * @return The subMatrix containing the data of the
 *         specified rows and columns
 * @exception MatrixIndexException if row or column selections are not valid
 */"
"public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {
    if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
    for (int i = startRow; i <= endRow; i++) {
        System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1);
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test154283() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getSubMatrix(0, (-2621), (-269), 31);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param startRow Initial row index
 * @param endRow Final row index
 * @param startColumn Initial column index
 * @param endColumn Final column index
 * @return The subMatrix containing the data of the
 *         specified rows and columns
 * @exception MatrixIndexException if row or column selections are not valid
 */"
"public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {
    if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
    for (int i = startRow; i <= endRow; i++) {
        System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1);
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test155284() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.getSubMatrix(0, 0, 0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param startRow Initial row index
 * @param endRow Final row index
 * @param startColumn Initial column index
 * @param endColumn Final column index
 * @return The subMatrix containing the data of the
 *         specified rows and columns
 * @exception MatrixIndexException if row or column selections are not valid
 */"
"public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn) throws MatrixIndexException {
    if (startRow < 0 || startRow > endRow || endRow > data.length || startColumn < 0 || startColumn > endColumn || endColumn > data[0].length) {
        throw new MatrixIndexException(""invalid row or column index selection"");
    }
    final BigDecimal[][] subMatrixData = new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
    for (int i = startRow; i <= endRow; i++) {
        System.arraycopy(data[i], startColumn, subMatrixData[i - startRow], 0, endColumn - startColumn + 1);
    }
    return new BigMatrixImpl(subMatrixData, false);
}","public void test156285() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    try {
        bigMatrixImpl0.getSubMatrix((-2415), 659, (-4553), 64);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // invalid row or column index selection
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.
 *
 * @param startRow Initial row index
 * @param endRow Final row index
 * @param startColumn Initial column index
 * @param endColumn Final column index
 * @return The subMatrix containing the data of the
 *         specified rows and columns
 * @exception MatrixIndexException if row or column selections are not valid
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test157286() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getNorm();
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getScale() {
    return scale;
}","public void test157287() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getNorm();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test157289() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigDecimal bigDecimal0 = bigMatrixImpl0.getNorm();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test158290() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    double[][] doubleArray1 = bigMatrixImpl0.getDataAsDoubleArray();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public double[][] getDataAsDoubleArray() {
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    final double[][] d = new double[nRows][nCols];
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            d[i][j] = data[i][j].doubleValue();
        }
    }
    return d;
}","public void test158291() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    double[][] doubleArray1 = bigMatrixImpl0.getDataAsDoubleArray();
    assertEquals(1, doubleArray1.length);
}","/**
 * Returns matrix entries as a two-dimensional array.
 * <p>
 * Makes a fresh copy of the underlying data converted to
 * <code>double</code> values.</p>
 *
 * @return    2-dimensional array of entries
 */"
"public int getScale() {
    return scale;
}","public void test158292() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    double[][] doubleArray1 = bigMatrixImpl0.getDataAsDoubleArray();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRowDimension() {
    return data.length;
}","public void test159293() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    assertEquals(1, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public int getScale() {
    return scale;
}","public void test159294() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.multiply(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test159295() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.multiply(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test159296() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.multiply(bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test159297() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    bigDecimalArray0[0] = bigDecimal0;
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = bigMatrixImpl0.multiply(bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
    try {
        return multiply((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        if (this.getColumnDimension() != m.getRowDimension()) {
            throw new IllegalArgumentException(""Matrices are not multiplication compatible."");
        }
        final int nRows = this.getRowDimension();
        final int nCols = m.getColumnDimension();
        final int nSum = this.getColumnDimension();
        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
        for (int row = 0; row < nRows; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < nCols; col++) {
                BigDecimal sum = ZERO;
                for (int i = 0; i < nSum; i++) {
                    sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
                }
                outDataRow[col] = sum;
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test160298() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][9];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, true);
    try {
        bigMatrixImpl0.multiply((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrices are not multiplication compatible.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result of postmultiplying this by <code>m</code>.
 * @param m    matrix to postmultiply by
 * @return     this*m
 * @throws     IllegalArgumentException
 *             if columnDimension(this) != rowDimension(m)
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test161299() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getRowDimension() {
    return data.length;
}","public void test161300() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(3, bigMatrixImpl1.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public int getScale() {
    return scale;
}","public void test161301() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test161302() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test161303() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimalArray0[0];
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.scalarAdd(bigDecimal0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test162304() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getScale() {
    return scale;
}","public void test162305() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test162306() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test162307() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(1, bigMatrixImpl1.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test162308() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigDecimal bigDecimal0 = new BigDecimal(0.0);
    bigDecimalArray0[0] = bigDecimal0;
    bigDecimalArray0[1] = bigDecimal0;
    bigDecimalArray0[2] = bigDecimalArray0[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
    try {
        return subtract((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test163309() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    BigMatrix bigMatrix0 = bigMatrixImpl0.getRowMatrix(1);
    try {
        bigMatrixImpl0.subtract(bigMatrix0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
    try {
        return subtract((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test164310() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(2912, 2912);
    // Undeclared exception!
    try {
        bigMatrixImpl0.subtract((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
    try {
        return add((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test165311() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrix bigMatrix0 = bigMatrixImpl0.getRowMatrix(1);
    try {
        bigMatrixImpl0.add(bigMatrix0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public int getRowDimension() {
    return data.length;
}","public void test166312() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(3, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test166313() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl1.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test166314() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test166315() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test166316() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(64, bigMatrixImpl1.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test166317() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertEquals(8, bigMatrixImpl1.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof BigMatrixImpl == false) {
        return false;
    }
    final BigMatrix m = (BigMatrix) object;
    final int nRows = getRowDimension();
    final int nCols = getColumnDimension();
    if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        final BigDecimal[] dataRow = data[row];
        for (int col = 0; col < nCols; col++) {
            if (!dataRow[col].equals(m.getEntry(row, col))) {
                return false;
            }
        }
    }
    return true;
}","public void test166318() throws Throwable {
    double[][] doubleArray0 = new double[3][8];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.add((BigMatrix) bigMatrixImpl0);
    assertTrue(bigMatrixImpl1.equals((Object) bigMatrixImpl0));
}","/**
 * Returns true iff <code>object</code> is a
 * <code>BigMatrixImpl</code> instance with the same dimensions as this
 * and all corresponding matrix entries are equal.  BigDecimal.equals
 * is used to compare corresponding entries.
 *
 * @param object the object to test equality against.
 * @return true if object equals this
 */"
"public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
    final int rowCount = getRowDimension();
    final int columnCount = getColumnDimension();
    if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
        throw new IllegalArgumentException(""matrix dimension mismatch"");
    }
    final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
    for (int row = 0; row < rowCount; row++) {
        final BigDecimal[] dataRow = data[row];
        final BigDecimal[] mRow = m.data[row];
        final BigDecimal[] outDataRow = outData[row];
        for (int col = 0; col < columnCount; col++) {
            outDataRow[col] = dataRow[col].add(mRow[col]);
        }
    }
    return new BigMatrixImpl(outData, false);
}","public void test167319() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    BigMatrixImpl bigMatrixImpl1 = (BigMatrixImpl) bigMatrixImpl0.transpose();
    try {
        bigMatrixImpl1.add(bigMatrixImpl0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute the sum of this and <code>m</code>.
 *
 * @param m    matrix to be added
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public BigMatrixImpl(String[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test168320() throws Throwable {
    String[][] stringArray0 = new String[6][8];
    String[] stringArray1 = new String[2];
    stringArray0[0] = stringArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the values represented by the strings in
 * <code>d</code> as the underlying data array.
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(String[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test169321() throws Throwable {
    String[][] stringArray0 = new String[6][8];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Create a new BigMatrix using the values represented by the strings in
 * <code>d</code> as the underlying data array.
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(String[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test170322() throws Throwable {
    String[][] stringArray0 = new String[1][3];
    String[] stringArray1 = new String[0];
    stringArray0[0] = stringArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one column.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the values represented by the strings in
 * <code>d</code> as the underlying data array.
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(String[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test171323() throws Throwable {
    String[][] stringArray0 = new String[0][9];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the values represented by the strings in
 * <code>d</code> as the underlying data array.
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(double[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test172324() throws Throwable {
    double[][] doubleArray0 = new double[3][1];
    double[] doubleArray1 = new double[5];
    doubleArray0[0] = doubleArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>Since the underlying array will hold <code>BigDecimal</code>
 * instances, it will be created.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(double[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test173325() throws Throwable {
    double[][] doubleArray0 = new double[5][0];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one column.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>Since the underlying array will hold <code>BigDecimal</code>
 * instances, it will be created.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(double[][] d) {
    final int nRows = d.length;
    if (nRows == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one row."");
    }
    final int nCols = d[0].length;
    if (nCols == 0) {
        throw new IllegalArgumentException(""Matrix must have at least one column."");
    }
    for (int row = 1; row < nRows; row++) {
        if (d[row].length != nCols) {
            throw new IllegalArgumentException(""All input rows must have the same length."");
        }
    }
    this.copyIn(d);
    lu = null;
}","public void test174326() throws Throwable {
    double[][] doubleArray0 = new double[0][0];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using <code>d</code> as the underlying
 * data array.
 * <p>Since the underlying array will hold <code>BigDecimal</code>
 * instances, it will be created.</p>
 *
 * @param d data for new matrix
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test175327() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][4];
    BigDecimal[] bigDecimalArray1 = new BigDecimal[3];
    bigDecimalArray0[0] = bigDecimalArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // All input rows must have the same length.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test176328() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[8][2];
    BigDecimal[] bigDecimalArray1 = new BigDecimal[0];
    bigDecimalArray0[0] = bigDecimalArray1;
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one column.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test177329() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[0][6];
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one row."");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw new IllegalArgumentException(""Matrix must have at least one column."");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw new IllegalArgumentException(""All input rows must have the same length."");
            }
        }
        data = d;
    }
    lu = null;
}","public void test178330() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((BigDecimal[][]) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * BigMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #BigMatrixImpl(BigDecimal[][])
 */"
"public BigMatrixImpl(int rowDimension, int columnDimension) {
    if (rowDimension <= 0 || columnDimension <= 0) {
        throw new IllegalArgumentException(""row and column dimensions must be positive"");
    }
    data = new BigDecimal[rowDimension][columnDimension];
    lu = null;
}","public void test179331() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl(7, (-668));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // row and column dimensions must be positive
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix with the supplied row and column dimensions.
 *
 * @param rowDimension      the number of rows in the new matrix
 * @param columnDimension   the number of columns in the new matrix
 * @throws IllegalArgumentException if row or column dimension is not
 *  positive
 */"
"public BigMatrixImpl(int rowDimension, int columnDimension) {
    if (rowDimension <= 0 || columnDimension <= 0) {
        throw new IllegalArgumentException(""row and column dimensions must be positive"");
    }
    data = new BigDecimal[rowDimension][columnDimension];
    lu = null;
}","public void test180332() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = null;
    try {
        bigMatrixImpl0 = new BigMatrixImpl((-741), (-881));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // row and column dimensions must be positive
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Create a new BigMatrix with the supplied row and column dimensions.
 *
 * @param rowDimension      the number of rows in the new matrix
 * @param columnDimension   the number of columns in the new matrix
 * @throws IllegalArgumentException if row or column dimension is not
 *  positive
 */"
"public BigMatrix inverse() throws InvalidMatrixException {
    return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));
}","public void test181333() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.inverse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the inverse matrix if this matrix is invertible.
 *
 * @return inverse matrix
 * @throws InvalidMatrixException if this is not invertible
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test182334() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getRoundingMode();
    assertEquals(4, int0);
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test182335() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getRoundingMode();
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRowDimension() {
    return data.length;
}","public void test182336() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[3];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getRoundingMode();
    assertEquals(3, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {
    return m.multiply(this);
}","public void test183337() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(121, 121);
    // Undeclared exception!
    try {
        bigMatrixImpl0.preMultiply((BigMatrix) bigMatrixImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the result premultiplying this by <code>m</code>.
 * @param m    matrix to premultiply by
 * @return     m * this
 * @throws     IllegalArgumentException
 *             if rowDimension(this) != columnDimension(m)
 */"
"public int getScale() {
    return scale;
}","public void test184338() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getColumnDimension() {
    return data[0].length;
}","public void test184339() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.setScale(0);
    assertEquals(5, bigMatrixImpl0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public int getScale() {
    return scale;
}","public void test185340() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getScale();
    assertEquals(64, int0);
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"public int getRowDimension() {
    return data.length;
}","public void test185341() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getScale();
    assertEquals(1, bigMatrixImpl0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test185342() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    int int0 = bigMatrixImpl0.getScale();
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
    try {
        return subtract((BigMatrixImpl) m);
    } catch (ClassCastException cce) {
        final int rowCount = getRowDimension();
        final int columnCount = getColumnDimension();
        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
            throw new IllegalArgumentException(""matrix dimension mismatch"");
        }
        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
        for (int row = 0; row < rowCount; row++) {
            final BigDecimal[] dataRow = data[row];
            final BigDecimal[] outDataRow = outData[row];
            for (int col = 0; col < columnCount; col++) {
                outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
            }
        }
        return new BigMatrixImpl(outData, false);
    }
}","public void test186343() throws Throwable {
    BigDecimal[][] bigDecimalArray0 = new BigDecimal[6][9];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0, true);
    BigMatrix bigMatrix0 = bigMatrixImpl0.transpose();
    try {
        bigMatrixImpl0.subtract(bigMatrix0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix dimension mismatch
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Compute  this minus <code>m</code>.
 *
 * @param m    matrix to be subtracted
 * @return     this + m
 * @throws  IllegalArgumentException if m is not the same size as this
 */"
"public int getRoundingMode() {
    return roundingMode;
}","public void test187344() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    assertEquals(4, bigMatrixImpl0.getRoundingMode());
}","/**
 * Gets the rounding mode for division operations
 * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}
 * @see BigDecimal
 * @return the rounding mode.
 */"
"public int getScale() {
    return scale;
}","public void test187345() throws Throwable {
    double[][] doubleArray0 = new double[1][5];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(doubleArray0);
    bigMatrixImpl0.setRoundingMode(0);
    assertEquals(64, bigMatrixImpl0.getScale());
}","/**
 * Sets the scale for division operations.
 * The default is 64
 * @see BigDecimal
 * @return the scale
 */"
"protected int[] getPermutation() {
    final int[] out = new int[permutation.length];
    System.arraycopy(permutation, 0, out, 0, permutation.length);
    return out;
}","public void test188346() throws Throwable {
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl();
    // Undeclared exception!
    try {
        bigMatrixImpl0.getPermutation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the permutation associated with the lu decomposition.
 * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.
 * <p>
 * Example:
 * permutation = [1, 2, 0] means current 2nd row is first, current third row is second
 * and current first row is last.</p>
 * <p>
 * Returns a fresh copy of the array.</p>
 *
 * @return the permutation
 */"
"public double getEntryAsDouble(int row, int column) throws MatrixIndexException {
    return getEntry(row, column).doubleValue();
}","public void test189347() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[1];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    try {
        bigMatrixImpl0.getEntryAsDouble(40, 474);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // matrix entry does not exist
        //
        verifyException(""org.apache.commons.math.linear.BigMatrixImpl"", e);
    }
}","/**
 * Returns the entry in the specified row and column as a double.
 * <p>
 * Row and column indices start at 0 and must satisfy
 * <ul>
 * <li><code>0 <= row < rowDimension</code></li>
 * <li><code> 0 <= column < columnDimension</code></li>
 * </ul>
 * otherwise a <code>MatrixIndexException</code> is thrown.</p>
 *
 * @param row  row location of entry to be fetched
 * @param column  column location of entry to be fetched
 * @return matrix entry in row,column
 * @throws MatrixIndexException if the row
 * or column index is not valid
 */"
"public BigMatrix copy() {
    return new BigMatrixImpl(this.copyOut(), false);
}","public void test190348() throws Throwable {
    BigDecimal[] bigDecimalArray0 = new BigDecimal[0];
    BigMatrixImpl bigMatrixImpl0 = new BigMatrixImpl(bigDecimalArray0);
    // Undeclared exception!
    try {
        bigMatrixImpl0.copy();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new BigMatrix which is a copy of this.
 *
 * @return  the cloned matrix
 */"
