focal_method,test_prefix,docstring
"public double getQ0() {
    return q0;
}","public void test000() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals(0.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test001() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals((-0.7071067811865475), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getY() {
    return y;
}","public void test002() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals(0.7071067811865476, vector3D0.getY(), 0.01);
}","/**
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getX() {
    return x;
}","public void test003() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals(-0.0, vector3D0.getX(), 0.01);
}","/**
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getZ() {
    return z;
}","public void test004() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals(0.7071067811865476, vector3D0.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getQ2() {
    return q2;
}","public void test015() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(0.0, rotation2.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test016() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(0.0, rotation2.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test017() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(-0.0, rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test018() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(0.9958335017214228, rotation3.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test019() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(0.0, rotation3.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0110() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation1 = new Rotation(vector3D0, 1523.489803044979);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    Rotation rotation3 = rotation2.revert();
    assertEquals(0.09119011376925146, rotation3.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0211() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals((-0.5), rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0212() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals((-0.5), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0213() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals((-0.5), rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0214() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.5, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0215() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals((-0.5), rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0216() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    Rotation rotation1 = rotation0.revert();
    assertEquals((-0.5), rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0317() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(519.975675, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0318() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.0, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0319() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.0, rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0320() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0321() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0322() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(519.975675, rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0323() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(-0.0, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0324() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = rotation0.revert();
    assertEquals(0.0, rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0425() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    double double0 = rotation0.getQ3();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0526() throws Throwable {
    Rotation rotation0 = new Rotation(321.383871488, 321.383871488, 321.383871488, 321.383871488, true);
    double double0 = rotation0.getQ3();
    assertEquals(0.5, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0527() throws Throwable {
    Rotation rotation0 = new Rotation(321.383871488, 321.383871488, 321.383871488, 321.383871488, true);
    double double0 = rotation0.getQ3();
    assertEquals(0.5, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0528() throws Throwable {
    Rotation rotation0 = new Rotation(321.383871488, 321.383871488, 321.383871488, 321.383871488, true);
    double double0 = rotation0.getQ3();
    assertEquals(0.5, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0529() throws Throwable {
    Rotation rotation0 = new Rotation(321.383871488, 321.383871488, 321.383871488, 321.383871488, true);
    double double0 = rotation0.getQ3();
    assertEquals(0.5, double0, 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0630() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 0.0, (-54.66491), true);
    double double0 = rotation0.getQ3();
    assertEquals(0.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0631() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 0.0, (-54.66491), true);
    double double0 = rotation0.getQ3();
    assertEquals(0.0, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0632() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 0.0, (-54.66491), true);
    double double0 = rotation0.getQ3();
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0633() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 0.0, (-54.66491), true);
    double double0 = rotation0.getQ3();
    assertEquals((-0.9999999999999999), double0, 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0734() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    double double0 = rotation0.getQ2();
    assertEquals(0.5, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0735() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    double double0 = rotation0.getQ2();
    assertEquals((-2634.3122), rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0736() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    double double0 = rotation0.getQ2();
    assertEquals(15.0, double0, 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0737() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    double double0 = rotation0.getQ2();
    assertEquals((-2634.3122), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0838() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    double double0 = rotation0.getQ2();
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0839() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    double double0 = rotation0.getQ2();
    assertEquals(0.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0840() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    double double0 = rotation0.getQ2();
    assertEquals((-0.7071067811865475), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0841() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-692.60412), (-692.60412), true);
    double double0 = rotation0.getQ2();
    assertEquals((-0.7071067811865475), double0, 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test0942() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 0.0, (-0.19), 0.0);
    double double0 = rotation0.getQ1();
    assertEquals(0.0948571686345573, double0, 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test0943() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 0.0, (-0.19), 0.0);
    double double0 = rotation0.getQ1();
    assertEquals(0.0, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test0944() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 0.0, (-0.19), 0.0);
    double double0 = rotation0.getQ1();
    assertEquals(0.0, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test0945() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 0.0, (-0.19), 0.0);
    double double0 = rotation0.getQ1();
    assertEquals(0.9954908927552453, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test1046() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 1.0, (-1884.34179737), 0.5);
    double double0 = rotation0.getQ1();
    assertEquals((-0.29271082137490767), double0, 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test1047() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 1.0, (-1884.34179737), 0.5);
    double double0 = rotation0.getQ1();
    assertEquals((-0.6497895039397437), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test1048() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 1.0, (-1884.34179737), 0.5);
    double double0 = rotation0.getQ1();
    assertEquals(0.07474134349205648, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test1049() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    Rotation rotation0 = new Rotation(rotationOrder0, 1.0, (-1884.34179737), 0.5);
    double double0 = rotation0.getQ1();
    assertEquals(0.6975010445818495, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test1150() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_I;
    Vector3D vector3D1 = new Vector3D((-1680.1648465), vector3D0, (-1680.1648465), vector3D0, (-1680.1648465), vector3D0);
    Rotation rotation0 = new Rotation(vector3D1, vector3D0);
    double double0 = rotation0.getQ0();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test1151() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_I;
    Vector3D vector3D1 = new Vector3D((-1680.1648465), vector3D0, (-1680.1648465), vector3D0, (-1680.1648465), vector3D0);
    Rotation rotation0 = new Rotation(vector3D1, vector3D0);
    double double0 = rotation0.getQ0();
    assertEquals(1.0, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test1152() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_I;
    Vector3D vector3D1 = new Vector3D((-1680.1648465), vector3D0, (-1680.1648465), vector3D0, (-1680.1648465), vector3D0);
    Rotation rotation0 = new Rotation(vector3D1, vector3D0);
    double double0 = rotation0.getQ0();
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test1253() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    double double0 = rotation0.getQ0();
    assertEquals((-0.49635980445291794), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test1254() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    double double0 = rotation0.getQ0();
    assertEquals((-0.2294572251344263), double0, 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test1255() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    double double0 = rotation0.getQ0();
    assertEquals((-0.49635980445291794), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test1256() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    double double0 = rotation0.getQ0();
    assertEquals(0.6742427388415329, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getX() {
    return x;
}","public void test1357() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals(0.6927255243237516, vector3D0.getX(), 0.01);
}","/**
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getZ() {
    return z;
}","public void test1358() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals((-0.5099663459241128), vector3D0.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getY() {
    return y;
}","public void test1359() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals((-0.5099663459241128), vector3D0.getY(), 0.01);
}","/**
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getQ0() {
    return q0;
}","public void test1360() throws Throwable {
    Rotation rotation0 = new Rotation((-1035.56568471797), 3042.9316100441, (-2240.1263698), (-2240.1263698), true);
    Vector3D vector3D0 = rotation0.getAxis();
    assertEquals((-0.2294572251344263), rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getNormInf() {
    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));
}","public void test1461() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = Vector3D.NEGATIVE_INFINITY;
    Vector3D vector3D1 = rotation0.applyTo(vector3D0);
    assertEquals(Double.NaN, vector3D1.getNormInf(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Vector3D) {
        final Vector3D rhs = (Vector3D) other;
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
    }
    return false;
}","public void test1562() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = new Vector3D(2.0, 2.0, (-246.8));
    Vector3D vector3D1 = rotation0.applyTo(vector3D0);
    assertTrue(vector3D1.equals((Object) vector3D0));
}","/**
 * Test for the equality of two 3D vectors.
 * <p>
 * If all coordinates of two 3D vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to
 * {@link #NaN}.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false if
 *         object is null, not an instance of Vector3D, or
 *         not equal to this Vector3D instance
 */"
"public double getNorm1() {
    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);
}","public void test1663() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation(rotationOrder0, (-823.349531201697), (-823.349531201697), (-3448.3189439421385));
    Rotation rotation1 = rotation0.revert();
    Vector3D vector3D0 = rotation1.getAxis();
    Vector3D vector3D1 = rotation1.IDENTITY.applyTo(vector3D0);
    assertEquals(1.3155065509244066, vector3D1.getNorm1(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getY() {
    return y;
}","public void test1664() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation(rotationOrder0, (-823.349531201697), (-823.349531201697), (-3448.3189439421385));
    Rotation rotation1 = rotation0.revert();
    Vector3D vector3D0 = rotation1.getAxis();
    Vector3D vector3D1 = rotation1.IDENTITY.applyTo(vector3D0);
    assertEquals(0.2995734943314427, vector3D1.getY(), 0.01);
}","/**
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getX() {
    return x;
}","public void test1665() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation(rotationOrder0, (-823.349531201697), (-823.349531201697), (-3448.3189439421385));
    Rotation rotation1 = rotation0.revert();
    Vector3D vector3D0 = rotation1.getAxis();
    Vector3D vector3D1 = rotation1.IDENTITY.applyTo(vector3D0);
    assertEquals((-0.9519235835140378), vector3D1.getX(), 0.01);
}","/**
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getZ() {
    return z;
}","public void test1666() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation(rotationOrder0, (-823.349531201697), (-823.349531201697), (-3448.3189439421385));
    Rotation rotation1 = rotation0.revert();
    Vector3D vector3D0 = rotation1.getAxis();
    Vector3D vector3D1 = rotation1.IDENTITY.applyTo(vector3D0);
    assertEquals(0.06400947307892609, vector3D1.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getQ0() {
    return q0;
}","public void test1667() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation(rotationOrder0, (-823.349531201697), (-823.349531201697), (-3448.3189439421385));
    Rotation rotation1 = rotation0.revert();
    Vector3D vector3D0 = rotation1.getAxis();
    Vector3D vector3D1 = rotation1.IDENTITY.applyTo(vector3D0);
    assertEquals(0.8173648305289856, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test1768() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals((-5460.4), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test1769() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getNormInf() {
    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));
}","public void test1770() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals(0.0, vector3D2.getNormInf(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getY() {
    return y;
}","public void test1771() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals(0.0, vector3D2.getY(), 0.01);
}","/**
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getZ() {
    return z;
}","public void test1772() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals(0.0, vector3D2.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getQ3() {
    return q3;
}","public void test1773() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, (-5460.4), (-1.0), false);
    Vector3D vector3D0 = new Vector3D(0.0, 0.0, (-1.0));
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = rotation0.applyTo(vector3D1);
    assertEquals((-1.0), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test1874() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = Vector3D.PLUS_K;
    Rotation rotation1 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    Rotation rotation2 = rotation1.applyTo(rotation0);
    assertEquals(Double.NaN, rotation2.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test1975() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    Rotation rotation1 = new Rotation(rotationOrder0, 4.0, 4.0, (-1979.694588318826));
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals(0.7599009079542555, rotation2.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test1976() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    Rotation rotation1 = new Rotation(rotationOrder0, 4.0, 4.0, (-1979.694588318826));
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals((-0.45905217497362333), rotation2.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test1977() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    Rotation rotation1 = new Rotation(rotationOrder0, 4.0, 4.0, (-1979.694588318826));
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals((-0.36901978488713144), rotation2.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test1978() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    Rotation rotation1 = new Rotation(rotationOrder0, 4.0, 4.0, (-1979.694588318826));
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals((-0.2750383775114654), rotation2.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test2079() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals(0.0, rotation2.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test2080() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals(0.0, rotation2.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2081() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals(0.0, rotation2.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test2082() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.applyTo(rotation1);
    assertEquals(519.975675, rotation2.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2183() throws Throwable {
    Rotation rotation0 = new Rotation(1.0, 1.0, 1.0, (-1485.899928), false);
    Vector3D vector3D0 = new Vector3D(1.0, (-1485.899928));
    Vector3D vector3D1 = rotation0.IDENTITY.applyInverseTo(vector3D0);
    assertEquals(1.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Vector3D) {
        final Vector3D rhs = (Vector3D) other;
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
    }
    return false;
}","public void test2184() throws Throwable {
    Rotation rotation0 = new Rotation(1.0, 1.0, 1.0, (-1485.899928), false);
    Vector3D vector3D0 = new Vector3D(1.0, (-1485.899928));
    Vector3D vector3D1 = rotation0.IDENTITY.applyInverseTo(vector3D0);
    assertTrue(vector3D1.equals((Object) vector3D0));
}","/**
 * Test for the equality of two 3D vectors.
 * <p>
 * If all coordinates of two 3D vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to
 * {@link #NaN}.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false if
 *         object is null, not an instance of Vector3D, or
 *         not equal to this Vector3D instance
 */"
"public double getNormInf() {
    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));
}","public void test2285() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = Vector3D.MINUS_K;
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Vector3D vector3D2 = new Vector3D((-2138.7303097069434), vector3D1, (-2138.7303097069434), vector3D1, (-2138.7303097069434), vector3D1, (-2138.7303097069434), vector3D1);
    Vector3D vector3D3 = rotation0.IDENTITY.applyInverseTo(vector3D2);
    assertEquals(0.0, vector3D3.getNormInf(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getQ3() {
    return q3;
}","public void test2386() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals(1.9868161777724352E-8, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test2387() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals((-1.9868161777724352E-8), rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2388() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals((-1.9868161777724352E-8), rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test2389() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals((-1.9868161777724352E-8), rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test2390() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals((-1.9868161777724352E-8), rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2391() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals(1.9868161777724352E-8, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test2392() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals(1.9868161777724352E-8, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test2393() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.applyInverseTo(rotation0);
    assertEquals(1.9868161777724352E-8, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test2494() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(0.0, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2495() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals((-1.0), rotation2.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test2496() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test2497() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(0.0, rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public static double distance(Rotation r1, Rotation r2) {
    return r1.applyInverseTo(r2).getAngle();
}","public void test2498() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(3.141592653589793, double0, 0.01);
}","/**
 * Compute the <i>distance</i> between two rotations.
 * <p>The <i>distance</i> is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:</p>
 * <pre>
 *        r<sub>1</sub>(r) = r<sub>2</sub>
 * </pre>
 * <p>This distance is an angle between 0 and &pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r<sub>1</sub>(v)
 * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.</p>
 * <p>Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @return <i>distance</i> between r1 and r2
 */"
"public double getQ3() {
    return q3;
}","public void test2499() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(0.0, rotation2.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test24100() throws Throwable {
    Rotation rotation0 = new Rotation(0.0, 0.0, 519.975675, 0.0, false);
    Rotation rotation1 = new Rotation(0.0, 3904.77, 0.0, 0.0, true);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    double double0 = Rotation.distance(rotation0, rotation2);
    assertEquals(519.975675, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public static double distance(Rotation r1, Rotation r2) {
    return r1.applyInverseTo(r2).getAngle();
}","public void test25101() throws Throwable {
    // Undeclared exception!
    try {
        Rotation.distance((Rotation) null, (Rotation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Compute the <i>distance</i> between two rotations.
 * <p>The <i>distance</i> is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:</p>
 * <pre>
 *        r<sub>1</sub>(r) = r<sub>2</sub>
 * </pre>
 * <p>This distance is an angle between 0 and &pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r<sub>1</sub>(v)
 * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.</p>
 * <p>Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @return <i>distance</i> between r1 and r2
 */"
"public Vector3D applyTo(Vector3D u) {
    double x = u.getX();
    double y = u.getY();
    double z = u.getZ();
    double s = q1 * x + q2 * y + q3 * z;
    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x, 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y, 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);
}","public void test26102() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, (-239.2149974796));
    // Undeclared exception!
    try {
        rotation0.IDENTITY.applyTo((Vector3D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Apply the rotation to a vector.
 * @param u vector to apply the rotation to
 * @return a new vector which is the image of u by the rotation
 */"
"public Rotation applyTo(Rotation r) {
    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3), r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2), r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3), r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1), false);
}","public void test27103() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    // Undeclared exception!
    try {
        rotation0.applyTo((Rotation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).
 * @param r rotation to apply the rotation to
 * @return a new rotation which is the composition of r by the instance
 */"
"public Vector3D applyInverseTo(Vector3D u) {
    double x = u.getX();
    double y = u.getY();
    double z = u.getZ();
    double s = q1 * x + q2 * y + q3 * z;
    double m0 = -q0;
    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x, 2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y, 2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);
}","public void test28104() throws Throwable {
    Rotation rotation0 = new Rotation((-2009.6), 3295.7944100348, 0.0, (-2009.6), false);
    // Undeclared exception!
    try {
        rotation0.IDENTITY.applyInverseTo((Vector3D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Apply the inverse of the rotation to a vector.
 * @param u vector to apply the inverse of the rotation to
 * @return a new vector which such that u is its image by the rotation
 */"
"public Rotation applyInverseTo(Rotation r) {
    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3), -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2), -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3), -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1), false);
}","public void test29105() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    // Undeclared exception!
    try {
        rotation0.applyInverseTo((Rotation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).
 * @param r rotation to apply the rotation to
 * @return a new rotation which is the composition of r by the inverse
 * of the instance
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test30106() throws Throwable {
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation((double[][]) null, 103.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test31107() throws Throwable {
    double[][] doubleArray0 = new double[0][4];
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(doubleArray0, 0.09090909090909091);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);
    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);
        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            ;
            c = k.dotProduct(u2.crossProduct(u3));
            ;
            if (c == 0) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }
    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();
    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}","public void test32108() throws Throwable {
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation((Vector3D) null, (Vector3D) null, (Vector3D) null, (Vector3D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build the rotation that transforms a pair of vector into another pair.
 *
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 *
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p>
 *
 * @param u1 first vector of the origin pair
 * @param u2 second vector of the origin pair
 * @param v1 desired image of u1 by the rotation
 * @param v2 desired image of u2 by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(Vector3D u, Vector3D v) {
    double normProduct = u.getNorm() * v.getNorm();
    if (normProduct == 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    double dot = u.dotProduct(v);
    if (dot < ((2.0e-15 - 1.0) * normProduct)) {
        // special case u = -v: we select a PI angle rotation around
        // an arbitrary vector orthogonal to u
        Vector3D w = u.orthogonal();
        q0 = 0.0;
        q1 = -w.getX();
        q2 = -w.getY();
        q3 = -w.getZ();
    } else {
        // general case: (u, v) defines a plane, we select
        // the shortest possible rotation: axis orthogonal to this plane
        q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));
        double coeff = 1.0 / (2.0 * q0 * normProduct);
        Vector3D q = v.crossProduct(u);
        q1 = coeff * q.getX();
        q2 = coeff * q.getY();
        q3 = coeff * q.getZ();
    }
}","public void test33109() throws Throwable {
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation((Vector3D) null, (Vector3D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build one of the rotations that transform one vector into another one.
 *
 * <p>Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.</p>
 *
 * @param u origin vector
 * @param v desired image of u by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(Vector3D axis, double angle) {
    double norm = axis.getNorm();
    if (norm == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);
    }
    double halfAngle = -0.5 * angle;
    double coeff = FastMath.sin(halfAngle) / norm;
    q0 = FastMath.cos(halfAngle);
    q1 = coeff * axis.getX();
    q2 = coeff * axis.getY();
    q3 = coeff * axis.getZ();
}","public void test34110() throws Throwable {
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation((Vector3D) null, 2657.56);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from an axis and an angle.
 * <p>We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &pi;/2 as the angle to this constructor, and then
 * {@link #applyTo(Vector3D) apply} the instance to +i, we will get
 * +j.</p>
 * <p>Another way to represent our convention is to say that a rotation
 * of angle &theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&theta;/2),
 * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.
 * Note the minus sign on the angle!</p>
 * <p>On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.</p>
 * @param axis axis around which to rotate
 * @param angle rotation angle.
 * @exception ArithmeticException if the axis norm is zero
 */"
"public Rotation(RotationOrder order, double alpha1, double alpha2, double alpha3) {
    Rotation r1 = new Rotation(order.getA1(), alpha1);
    Rotation r2 = new Rotation(order.getA2(), alpha2);
    Rotation r3 = new Rotation(order.getA3(), alpha3);
    Rotation composed = r1.applyTo(r2.applyTo(r3));
    q0 = composed.q0;
    q1 = composed.q1;
    q2 = composed.q2;
    q3 = composed.q3;
}","public void test35111() throws Throwable {
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation((RotationOrder) null, 954.43669182405, (-1757.22622), 0.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from three Cardan or Euler elementary rotations.
 *
 * <p>Cardan rotations are three successive rotations around the
 * canonical axes X, Y and Z, each axis being used once. There are
 * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
 * rotations are three successive rotations around the canonical
 * axes X, Y and Z, the first and last rotations being around the
 * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
 * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>
 * <p>Beware that many people routinely use the term Euler angles even
 * for what really are Cardan angles (this confusion is especially
 * widespread in the aerospace business where Roll, Pitch and Yaw angles
 * are often wrongly tagged as Euler angles).</p>
 *
 * @param order order of rotations to use
 * @param alpha1 angle of the first elementary rotation
 * @param alpha2 angle of the second elementary rotation
 * @param alpha3 angle of the third elementary rotation
 */"
"public double getQ0() {
    return q0;
}","public void test36112() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    double double0 = rotation0.getAngle();
    assertEquals((-0.5), rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test36113() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    double double0 = rotation0.getAngle();
    assertEquals((-0.5), rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test36114() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    double double0 = rotation0.getAngle();
    assertEquals((-0.5), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getAngle() {
    if ((q0 < -0.1) || (q0 > 0.1)) {
        return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
        return 2 * FastMath.acos(-q0);
    }
    return 2 * FastMath.acos(q0);
}","public void test36115() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    double double0 = rotation0.getAngle();
    assertEquals(2.0943951023931953, double0, 0.01);
}","/**
 * Get the angle of the rotation.
 * @return angle of the rotation (between 0 and &pi;)
 * @see #Rotation(Vector3D, double)
 */"
"public double getQ2() {
    return q2;
}","public void test36116() throws Throwable {
    Rotation rotation0 = new Rotation((-877.0), (-877.0), (-877.0), (-877.0), true);
    double double0 = rotation0.getAngle();
    assertEquals((-0.5), rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Vector3D) {
        final Vector3D rhs = (Vector3D) other;
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
    }
    return false;
}","public void test37117() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.25, (-2279.098093399), 5748.6735217073);
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.IDENTITY.applyTo(vector3D0);
    assertTrue(vector3D1.equals((Object) vector3D0));
}","/**
 * Test for the equality of two 3D vectors.
 * <p>
 * If all coordinates of two 3D vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to
 * {@link #NaN}.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false if
 *         object is null, not an instance of Vector3D, or
 *         not equal to this Vector3D instance
 */"
"public double getQ2() {
    return q2;
}","public void test37118() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.25, (-2279.098093399), 5748.6735217073);
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.IDENTITY.applyTo(vector3D0);
    assertEquals(Double.NaN, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getNorm1() {
    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);
}","public void test38119() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.applyInverseTo(vector3D0);
    assertEquals(Double.NaN, vector3D1.getNorm1(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test39120() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    double[][] doubleArray0 = rotation0.getMatrix();
    Rotation rotation1 = null;
    try {
        rotation1 = new Rotation(doubleArray0, 0.0);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // unable to orthogonalize matrix in 10 iterations
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test40121() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.ZYZ;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test41122() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.03492798088037815, 0.03492798088037815);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    try {
        rotation0.IDENTITY.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test42123() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    Rotation rotation0 = new Rotation(0.0, 0.16666666666745392, (-0.4714044926931317), 0.0, false);
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test43124() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.ZYZ;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test44125() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.YZY;
    try {
        rotation0.IDENTITY.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test45126() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZY;
    Vector3D vector3D0 = rotationOrder0.getA1();
    Vector3D vector3D1 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D1, vector3D0, vector3D0, vector3D0);
    Rotation rotation1 = new Rotation(vector3D0, vector3D1);
    Rotation rotation2 = rotation0.IDENTITY.applyInverseTo(rotation1);
    try {
        rotation2.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test46127() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.YZY;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertEquals(3, doubleArray0.length);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test47128() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test48129() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test49130() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertEquals(3, doubleArray0.length);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double getQ0() {
    return q0;
}","public void test50131() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.XZX;
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    assertEquals(Double.NaN, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getZ() {
    return z;
}","public void test50132() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.XZX;
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    rotation1.getAngles(rotationOrder0);
    assertEquals(0.0, vector3D0.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getNorm1() {
    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);
}","public void test50133() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.XZX;
    Rotation rotation0 = Rotation.IDENTITY;
    Vector3D vector3D0 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    rotation1.getAngles(rotationOrder0);
    assertEquals(1.0, vector3D0.getNorm1(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test51134() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.XZX;
    Rotation rotation0 = Rotation.IDENTITY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test52135() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.XYX;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test53136() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    RotationOrder rotationOrder0 = RotationOrder.XYX;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test54137() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_I;
    Rotation rotation0 = new Rotation(vector3D0, (-834.3178));
    RotationOrder rotationOrder0 = RotationOrder.XYX;
    try {
        rotation0.IDENTITY.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Euler angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test55138() throws Throwable {
    Rotation rotation0 = new Rotation(521.84415, (-0.5), 1119.201639707, 0.1, false);
    RotationOrder rotationOrder0 = RotationOrder.ZYX;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test56139() throws Throwable {
    Rotation rotation0 = new Rotation((-1634.076), (-1634.076), 282.659391833, 747.6433037848643, false);
    RotationOrder rotationOrder0 = RotationOrder.ZYX;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test57140() throws Throwable {
    Vector3D vector3D0 = Vector3D.POSITIVE_INFINITY;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.ZYX;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test58141() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Rotation rotation0 = new Rotation((-1.7825557603452563E-4), 0.2298510942896171, 2038.4502715, 0.027521523592243975, false);
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test59142() throws Throwable {
    Rotation rotation0 = new Rotation(0.02244492401198233, 0.02244492401198233, (-0.7820032231927776), 5334.0, false);
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test60143() throws Throwable {
    Vector3D vector3D0 = new Vector3D((-0.1), (-2491.731326436284));
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test61144() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Rotation rotation0 = new Rotation((-1.7825557603452563E-4), 0.2298510942896171, 2038.4502715, 0.027521523592243975, false);
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test62145() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test63146() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { -0.0, 0.0, -0.0 }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test64147() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXZ;
    Rotation rotation0 = new Rotation((-1.7825557603452563E-4), 0.2298510942896171, 2038.4502715, 0.027521523592243975, false);
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test65148() throws Throwable {
    Rotation rotation0 = new Rotation(0.8022124572060929, 0.8022124572060929, (-0.7820032231927776), 5334.0, false);
    RotationOrder rotationOrder0 = RotationOrder.YXZ;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test66149() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_K;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.YXZ;
    double[] doubleArray0 = rotation0.IDENTITY.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { 0.0, -0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double getQ0() {
    return q0;
}","public void test66150() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_K;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.YXZ;
    double[] doubleArray0 = rotation0.IDENTITY.getAngles(rotationOrder0);
    assertEquals(1.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test67151() throws Throwable {
    Rotation rotation0 = new Rotation(0.25, 0.25, 0.25, 1829.5243766, false);
    RotationOrder rotationOrder0 = RotationOrder.XZY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test68152() throws Throwable {
    Rotation rotation0 = new Rotation((-1499.4005), (-1499.4005), 0.0, 0.11764700710773468, false);
    RotationOrder rotationOrder0 = RotationOrder.XZY;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test69153() throws Throwable {
    Vector3D vector3D0 = new Vector3D((-0.1), (-2491.731326436284));
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    RotationOrder rotationOrder0 = RotationOrder.XZY;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test70154() throws Throwable {
    Rotation rotation0 = new Rotation((-2634.3122), 0.5, 15.0, (-2634.3122), false);
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    try {
        rotation0.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test71155() throws Throwable {
    Rotation rotation0 = new Rotation((-1099.4598898379), (-1099.4598898379), (-1099.4598898379), (-1099.4598898379), false);
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    Rotation rotation1 = new Rotation(rotationOrder0, 3155.8, 0.5, 1814.7467);
    Rotation rotation2 = rotation0.applyInverseTo(rotation1);
    try {
        rotation2.getAngles(rotationOrder0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Cardan angles singularity
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double getQ2() {
    return q2;
}","public void test72156() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.3333333134651184, 0.3333333134651184);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertEquals(0.4083655420666395, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test72157() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.3333333134651184, 0.3333333134651184);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    RotationOrder rotationOrder0 = RotationOrder.ZXZ;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { 2.0346162820319744, 0.8413255633379556, (-1.1069763715578187) }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double getAngle() {
    if ((q0 < -0.1) || (q0 > 0.1)) {
        return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
        return 2 * FastMath.acos(-q0);
    }
    return 2 * FastMath.acos(q0);
}","public void test73158() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals(3.0288856122966332, double0, 0.01);
}","/**
 * Get the angle of the rotation.
 * @return angle of the rotation (between 0 and &pi;)
 * @see #Rotation(Vector3D, double)
 */"
"public double getQ2() {
    return q2;
}","public void test73159() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals(0.0, rotation2.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test73160() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals(0.0, rotation3.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test73161() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals(0.0, rotation3.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test73162() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals((-0.056323698221933796), rotation3.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test73163() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals((-0.9984125605272625), rotation3.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test73164() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals((-0.9984125605272625), rotation2.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test73165() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    RotationOrder rotationOrder0 = RotationOrder.YZX;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Rotation rotation1 = new Rotation(vector3D0, 3295.4179865744);
    Rotation rotation2 = rotation1.applyInverseTo(rotation0);
    Rotation rotation3 = rotation2.applyTo(rotation0);
    double double0 = rotation3.getAngle();
    assertEquals(-0.0, rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getAngle() {
    if ((q0 < -0.1) || (q0 > 0.1)) {
        return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
    } else if (q0 < 0) {
        return 2 * FastMath.acos(-q0);
    }
    return 2 * FastMath.acos(q0);
}","public void test74166() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    double double0 = rotation0.IDENTITY.getAngle();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the angle of the rotation.
 * @return angle of the rotation (between 0 and &pi;)
 * @see #Rotation(Vector3D, double)
 */"
"public double getQ3() {
    return q3;
}","public void test74167() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZXY;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    double double0 = rotation0.IDENTITY.getAngle();
    assertEquals(Double.NaN, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getNormInf() {
    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));
}","public void test75168() throws Throwable {
    Vector3D vector3D0 = new Vector3D((-0.1), (-2491.731326436284));
    Rotation rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    assertEquals(Double.NaN, vector3D1.getNormInf(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public Rotation(Vector3D u, Vector3D v) {
    double normProduct = u.getNorm() * v.getNorm();
    if (normProduct == 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    double dot = u.dotProduct(v);
    if (dot < ((2.0e-15 - 1.0) * normProduct)) {
        // special case u = -v: we select a PI angle rotation around
        // an arbitrary vector orthogonal to u
        Vector3D w = u.orthogonal();
        q0 = 0.0;
        q1 = -w.getX();
        q2 = -w.getY();
        q3 = -w.getZ();
    } else {
        // general case: (u, v) defines a plane, we select
        // the shortest possible rotation: axis orthogonal to this plane
        q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));
        double coeff = 1.0 / (2.0 * q0 * normProduct);
        Vector3D q = v.crossProduct(u);
        q1 = coeff * q.getX();
        q2 = coeff * q.getY();
        q3 = coeff * q.getZ();
    }
}","public void test76169() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXZ;
    Vector3D vector3D0 = rotationOrder0.getA2();
    Vector3D vector3D1 = new Vector3D(0.0, vector3D0);
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D1, vector3D0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm for rotation defining vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build one of the rotations that transform one vector into another one.
 *
 * <p>Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.</p>
 *
 * @param u origin vector
 * @param v desired image of u by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public double getQ3() {
    return q3;
}","public void test77170() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.XYX;
    Vector3D vector3D0 = rotationOrder0.getA3();
    Vector3D vector3D1 = vector3D0.orthogonal();
    Rotation rotation0 = new Rotation(vector3D1, vector3D0, vector3D0, vector3D1);
    assertEquals((-0.7071067811865475), rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test78171() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D1);
    assertEquals(0.0, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test78172() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D1);
    assertEquals(1.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test78173() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D1);
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test78174() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D1);
    assertEquals(0.0, rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getNormSq() {
    // there are no cancellation problems here, so we use the straightforward formula
    return x * x + y * y + z * z;
}","public void test78175() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Vector3D vector3D1 = rotation0.getAxis();
    Rotation rotation1 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D1);
    assertEquals(1.0, vector3D1.getNormSq(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);
    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);
        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            ;
            c = k.dotProduct(u2.crossProduct(u3));
            ;
            if (c == 0) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }
    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();
    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}","public void test79176() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.3333333134651184, 0.3333333134651184);
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D0, vector3D0, vector3D0, vector3D1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm for rotation defining vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build the rotation that transforms a pair of vector into another pair.
 *
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 *
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p>
 *
 * @param u1 first vector of the origin pair
 * @param u2 second vector of the origin pair
 * @param v1 desired image of u1 by the rotation
 * @param v2 desired image of u2 by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);
    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);
        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            ;
            c = k.dotProduct(u2.crossProduct(u3));
            ;
            if (c == 0) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }
    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();
    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}","public void test80177() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.ZYX;
    Vector3D vector3D0 = rotationOrder0.getA1();
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D0, vector3D0, vector3D1, vector3D1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm for rotation defining vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build the rotation that transforms a pair of vector into another pair.
 *
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 *
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p>
 *
 * @param u1 first vector of the origin pair
 * @param u2 second vector of the origin pair
 * @param v1 desired image of u1 by the rotation
 * @param v2 desired image of u2 by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);
    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);
        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            ;
            c = k.dotProduct(u2.crossProduct(u3));
            ;
            if (c == 0) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }
    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();
    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}","public void test81178() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_I;
    Vector3D vector3D1 = vector3D0.subtract((Vector<Euclidean3D>) vector3D0);
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D0, vector3D1, vector3D0, vector3D0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm for rotation defining vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build the rotation that transforms a pair of vector into another pair.
 *
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 *
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p>
 *
 * @param u1 first vector of the origin pair
 * @param u2 second vector of the origin pair
 * @param v1 desired image of u1 by the rotation
 * @param v2 desired image of u2 by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
    // norms computation
    double u1u1 = u1.getNormSq();
    double u2u2 = u2.getNormSq();
    double v1v1 = v1.getNormSq();
    double v2v2 = v2.getNormSq();
    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
    }
    // normalize v1 in order to have (v1'|v1') = (u1|u1)
    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
    double u1u2 = u1.dotProduct(u2);
    double v1v2 = v1.dotProduct(v2);
    double coeffU = u1u2 / u1u1;
    double coeffV = v1v2 / u1u1;
    double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
    double alpha = coeffU - beta * coeffV;
    v2 = new Vector3D(alpha, v1, beta, v2);
    // preliminary computation
    Vector3D uRef = u1;
    Vector3D vRef = v1;
    Vector3D v1Su1 = v1.subtract(u1);
    Vector3D v2Su2 = v2.subtract(u2);
    Vector3D k = v1Su1.crossProduct(v2Su2);
    Vector3D u3 = u1.crossProduct(u2);
    double c = k.dotProduct(u3);
    if (c == 0) {
        // the (q1, q2, q3) vector is close to the (u1, u2) plane
        // we try other vectors
        Vector3D v3 = Vector3D.crossProduct(v1, v2);
        Vector3D v3Su3 = v3.subtract(u3);
        k = v1Su1.crossProduct(v3Su3);
        Vector3D u2Prime = u1.crossProduct(u3);
        c = k.dotProduct(u2Prime);
        if (c == 0) {
            // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
            // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
            k = v2Su2.crossProduct(v3Su3);
            ;
            c = k.dotProduct(u2.crossProduct(u3));
            ;
            if (c == 0) {
                // the (q1, q2, q3) vector is aligned with everything
                // this is really the identity rotation
                q0 = 1.0;
                q1 = 0.0;
                q2 = 0.0;
                q3 = 0.0;
                return;
            }
            // we will have to use u2 and v2 to compute the scalar part
            uRef = u2;
            vRef = v2;
        }
    }
    // compute the vectorial part
    c = FastMath.sqrt(c);
    double inv = 1.0 / (c + c);
    q1 = inv * k.getX();
    q2 = inv * k.getY();
    q3 = inv * k.getZ();
    // compute the scalar part
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1);
    q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
}","public void test82179() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Vector3D vector3D1 = Vector3D.crossProduct(vector3D0, vector3D0);
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D1, vector3D1, vector3D0, vector3D0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm for rotation defining vector
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build the rotation that transforms a pair of vector into another pair.
 *
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 *
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p>
 *
 * @param u1 first vector of the origin pair
 * @param u2 second vector of the origin pair
 * @param v1 desired image of u1 by the rotation
 * @param v2 desired image of u2 by the rotation
 * @exception IllegalArgumentException if the norm of one of the vectors is zero
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test83180() throws Throwable {
    double[][] doubleArray0 = new double[3][5];
    double[] doubleArray1 = new double[3];
    doubleArray0[0] = doubleArray1;
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(doubleArray0, (-0.18084726264509002));
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // a 3x3 matrix cannot be a rotation matrix
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test84181() throws Throwable {
    double[][] doubleArray0 = new double[3][4];
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(doubleArray0, (-1091.2336470071473));
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // a 3x4 matrix cannot be a rotation matrix
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public double getQ3() {
    return q3;
}","public void test85182() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.03492798088037815, 0.03492798088037815);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    double[][] doubleArray0 = rotation0.getMatrix();
    Rotation rotation1 = new Rotation(doubleArray0, 0.0);
    assertEquals(0.4083655420666395, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test85183() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.03492798088037815, 0.03492798088037815);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    double[][] doubleArray0 = rotation0.getMatrix();
    Rotation rotation1 = new Rotation(doubleArray0, 0.0);
    assertEquals((-0.40836554206663955), rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test85184() throws Throwable {
    Vector3D vector3D0 = new Vector3D(0.0, 0.03492798088037815, 0.03492798088037815);
    Rotation rotation0 = new Rotation(vector3D0, (-1852.3083));
    double[][] doubleArray0 = rotation0.getMatrix();
    Rotation rotation1 = new Rotation(doubleArray0, 0.0);
    assertEquals(0.4083655420666395, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public Rotation(Vector3D axis, double angle) {
    double norm = axis.getNorm();
    if (norm == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);
    }
    double halfAngle = -0.5 * angle;
    double coeff = FastMath.sin(halfAngle) / norm;
    q0 = FastMath.cos(halfAngle);
    q1 = coeff * axis.getX();
    q2 = coeff * axis.getY();
    q3 = coeff * axis.getZ();
}","public void test86185() throws Throwable {
    Vector3D vector3D0 = Vector3D.ZERO;
    Rotation rotation0 = null;
    try {
        rotation0 = new Rotation(vector3D0, 0.0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm for rotation axis
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Build a rotation from an axis and an angle.
 * <p>We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &pi;/2 as the angle to this constructor, and then
 * {@link #applyTo(Vector3D) apply} the instance to +i, we will get
 * +j.</p>
 * <p>Another way to represent our convention is to say that a rotation
 * of angle &theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&theta;/2),
 * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.
 * Note the minus sign on the angle!</p>
 * <p>On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.</p>
 * @param axis axis around which to rotate
 * @param angle rotation angle.
 * @exception ArithmeticException if the axis norm is zero
 */"
"public double getQ3() {
    return q3;
}","public void test87186() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Rotation rotation1 = rotation0.applyTo(rotation0);
    assertEquals(0.0, rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test87187() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Rotation rotation1 = rotation0.applyTo(rotation0);
    assertEquals(0.0, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test87188() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Rotation rotation1 = rotation0.applyTo(rotation0);
    assertEquals(0.0, rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test87189() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Rotation rotation1 = rotation0.applyTo(rotation0);
    assertEquals(0.0, rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test87190() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    Rotation rotation1 = rotation0.applyTo(rotation0);
    assertEquals(1.0, rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public Rotation(double[][] m, double threshold) throws NotARotationMatrixException {
    // dimension check
    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {
        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);
    }
    // compute a ""close"" orthogonal matrix
    double[][] ort = orthogonalizeMatrix(m, threshold);
    // check the sign of the determinant
    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
    if (det < 0.0) {
        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);
    }
    // There are different ways to compute the quaternions elements
    // from the matrix. They all involve computing one element from
    // the diagonal of the matrix, and computing the three other ones
    // using a formula involving a division by the first element,
    // which unfortunately can be zero. Since the norm of the
    // quaternion is 1, we know at least one element has an absolute
    // value greater or equal to 0.5, so it is always possible to
    // select the right formula and avoid division by zero and even
    // numerical inaccuracy. Checking the elements in turn and using
    // the first one greater than 0.45 is safe (this leads to a simple
    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
    double s = ort[0][0] + ort[1][1] + ort[2][2];
    if (s > -0.19) {
        // compute q0 and deduce q1, q2 and q3
        q0 = 0.5 * FastMath.sqrt(s + 1.0);
        double inv = 0.25 / q0;
        q1 = inv * (ort[1][2] - ort[2][1]);
        q2 = inv * (ort[2][0] - ort[0][2]);
        q3 = inv * (ort[0][1] - ort[1][0]);
    } else {
        s = ort[0][0] - ort[1][1] - ort[2][2];
        if (s > -0.19) {
            // compute q1 and deduce q0, q2 and q3
            q1 = 0.5 * FastMath.sqrt(s + 1.0);
            double inv = 0.25 / q1;
            q0 = inv * (ort[1][2] - ort[2][1]);
            q2 = inv * (ort[0][1] + ort[1][0]);
            q3 = inv * (ort[0][2] + ort[2][0]);
        } else {
            s = ort[1][1] - ort[0][0] - ort[2][2];
            if (s > -0.19) {
                // compute q2 and deduce q0, q1 and q3
                q2 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q2;
                q0 = inv * (ort[2][0] - ort[0][2]);
                q1 = inv * (ort[0][1] + ort[1][0]);
                q3 = inv * (ort[2][1] + ort[1][2]);
            } else {
                // compute q3 and deduce q0, q1 and q2
                s = ort[2][2] - ort[0][0] - ort[1][1];
                q3 = 0.5 * FastMath.sqrt(s + 1.0);
                double inv = 0.25 / q3;
                q0 = inv * (ort[0][1] - ort[1][0]);
                q1 = inv * (ort[0][2] + ort[2][0]);
                q2 = inv * (ort[2][1] + ort[1][2]);
            }
        }
    }
}","public void test88191() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    double[][] doubleArray0 = rotation0.getMatrix();
    Rotation rotation1 = null;
    try {
        rotation1 = new Rotation(doubleArray0, 1.9868161777724352E-8);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // the closest orthogonal matrix has a negative determinant -1
        //
        verifyException(""org.apache.commons.math.geometry.euclidean.threed.Rotation"", e);
    }
}","/**
 * Build a rotation from a 3X3 matrix.
 *
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 *
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p>
 *
 * @param m rotation matrix
 * @param threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)
 *
 * @exception NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative
 */"
"public double[] getAngles(RotationOrder order) throws CardanEulerSingularityException {
    if (order == RotationOrder.XYZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getY()), v1.getZ()), FastMath.asin(v2.getZ()), FastMath.atan2(-(v2.getY()), v2.getX()) };
    } else if (order == RotationOrder.XZY) {
        // r (Vector3D.plusJ) coordinates are :
        // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), -FastMath.asin(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.YXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), -FastMath.asin(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else if (order == RotationOrder.YZX) {
        // r (Vector3D.plusI) coordinates are :
        // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
        // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getZ()), v1.getX()), FastMath.asin(v2.getX()), FastMath.atan2(-(v2.getZ()), v2.getY()) };
    } else if (order == RotationOrder.ZXY) {
        // r (Vector3D.plusJ) coordinates are :
        // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
        // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(-(v1.getX()), v1.getY()), FastMath.asin(v2.getY()), FastMath.atan2(-(v2.getX()), v2.getZ()) };
    } else if (order == RotationOrder.ZYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
        // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(true);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), -FastMath.asin(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XYX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), -v1.getZ()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getY(), v2.getZ()) };
    } else if (order == RotationOrder.XZX) {
        // r (Vector3D.plusI) coordinates are :
        //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
        // (-r) (Vector3D.plusI) coordinates are :
        // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_I);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
        if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), v1.getY()), FastMath.acos(v2.getX()), FastMath.atan2(v2.getZ(), -v2.getY()) };
    } else if (order == RotationOrder.YXY) {
        // r (Vector3D.plusJ) coordinates are :
        //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), v1.getZ()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getX(), -v2.getZ()) };
    } else if (order == RotationOrder.YZY) {
        // r (Vector3D.plusJ) coordinates are :
        //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
        // (-r) (Vector3D.plusJ) coordinates are :
        // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
        // and we can choose to have psi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_J);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
        if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getZ(), -v1.getX()), FastMath.acos(v2.getY()), FastMath.atan2(v2.getZ(), v2.getX()) };
    } else if (order == RotationOrder.ZXZ) {
        // r (Vector3D.plusK) coordinates are :
        //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
        // (-r) (Vector3D.plusK) coordinates are :
        // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
        // and we can choose to have phi in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getX(), -v1.getY()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getX(), v2.getY()) };
    } else {
        // last possibility is ZYZ
        // r (Vector3D.plusK) coordinates are :
        //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
        // (-r) (Vector3D.plusK) coordinates are :
        // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
        // and we can choose to have theta in the interval [0 ; PI]
        Vector3D v1 = applyTo(Vector3D.PLUS_K);
        Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
        if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
            throw new CardanEulerSingularityException(false);
        }
        return new double[] { FastMath.atan2(v1.getY(), v1.getX()), FastMath.acos(v2.getZ()), FastMath.atan2(v2.getY(), -v2.getX()) };
    }
}","public void test89192() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, (-239.2149974796));
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.NaN }, doubleArray0, 0.01);
}","/**
 * Get the Cardan or Euler angles corresponding to the instance.
 *
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 *   <li>for Cardan angles, the chosen set is the one for which the
 *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 *   positive),</li>
 *   <li>for Euler angles, the chosen set is the one for which the
 *   second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 *
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p>
 *
 * @param order rotation order to use
 * @return an array of three angles, in the order specified by the set
 * @exception CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified
 */"
"public double getQ0() {
    return q0;
}","public void test89193() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, (-239.2149974796));
    RotationOrder rotationOrder0 = RotationOrder.XYZ;
    double[] doubleArray0 = rotation0.getAngles(rotationOrder0);
    assertEquals(0.9743509177808812, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test90194() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    Rotation rotation0 = new Rotation(vector3D0, (-239.2149974796));
    double double0 = rotation0.getQ0();
    assertEquals(0.9743509177808812, double0, 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test91195() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ2();
    assertEquals(0.0, rotation0.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test91196() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ2();
    assertEquals(1.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test91197() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ2();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test92198() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ1();
    assertEquals(1.0, rotation0.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test92199() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ1();
    assertEquals(0.0, rotation0.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test92200() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_J;
    Rotation rotation0 = new Rotation(vector3D0, vector3D0);
    double double0 = rotation0.getQ1();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test93201() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.revert();
    assertEquals(0.0, rotation1.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ3() {
    return q3;
}","public void test93202() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.revert();
    assertEquals(1.9868161777724352E-8, rotation0.getQ3(), 0.01);
}","/**
 * Get the third coordinate of the vectorial part of the quaternion.
 * @return third coordinate of the vectorial part of the quaternion
 */"
"public double getQ0() {
    return q0;
}","public void test93203() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.revert();
    assertEquals((-1.0), rotation1.getQ0(), 0.01);
}","/**
 * Get the scalar coordinate of the quaternion.
 * @return scalar coordinate of the quaternion
 */"
"public double getQ1() {
    return q1;
}","public void test93204() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.revert();
    assertEquals(0.0, rotation1.getQ1(), 0.01);
}","/**
 * Get the first coordinate of the vectorial part of the quaternion.
 * @return first coordinate of the vectorial part of the quaternion
 */"
"public double getQ2() {
    return q2;
}","public void test93205() throws Throwable {
    Rotation rotation0 = new Rotation(1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, 1.9868161777724352E-8, false);
    Rotation rotation1 = rotation0.IDENTITY.revert();
    assertEquals(0.0, rotation1.getQ2(), 0.01);
}","/**
 * Get the second coordinate of the vectorial part of the quaternion.
 * @return second coordinate of the vectorial part of the quaternion
 */"
"public static double distance(Rotation r1, Rotation r2) {
    return r1.applyInverseTo(r2).getAngle();
}","public void test94206() throws Throwable {
    Rotation rotation0 = Rotation.IDENTITY;
    Rotation.distance(rotation0, rotation0);
}","/**
 * Compute the <i>distance</i> between two rotations.
 * <p>The <i>distance</i> is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:</p>
 * <pre>
 *        r<sub>1</sub>(r) = r<sub>2</sub>
 * </pre>
 * <p>This distance is an angle between 0 and &pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r<sub>1</sub>(v)
 * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.</p>
 * <p>Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @return <i>distance</i> between r1 and r2
 */"
