focal_method,test_prefix,docstring
"public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) {
    super();
    setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
    setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
}","public void test000() throws Throwable {
    FDistributionImpl fDistributionImpl0 = null;
    try {
        fDistributionImpl0 = new FDistributionImpl(1122.5185115, (-1684.087766816052));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom must be positive.
        //
        verifyException(""org.apache.commons.math.distribution.FDistributionImpl"", e);
    }
}","/**
 * Create a F distribution using the given degrees of freedom.
 * @param numeratorDegreesOfFreedom the numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom the denominator degrees of freedom.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test011() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(2421.0, 2421.0);
    // Undeclared exception!
    try {
        fDistributionImpl0.inverseCumulativeProbability((-1.643181065367639E-4));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // p must be between 0.0 and 1.0, inclusive.
        //
        verifyException(""org.apache.commons.math.distribution.AbstractContinuousDistribution"", e);
    }
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test022() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getInitialDomain((-9.837447530487956E-5));
    assertEquals(1701.2, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"protected double getInitialDomain(double p) {
    double ret;
    double d = getDenominatorDegreesOfFreedom();
    // use mean
    ret = d / (d - 2.0);
    return ret;
}","public void test023() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getInitialDomain((-9.837447530487956E-5));
    assertEquals(1.000633045631028, double0, 0.01);
}","/**
 * Access the initial domain value, based on <code>p</code>, used to
 * bracket a CDF root.  This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return initial domain value
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test034() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(8.441822398385275E-5, 0.9999999999999971);
    double double0 = fDistributionImpl0.getInitialDomain(0.9995456442973051);
    assertEquals(8.441822398385275E-5, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"protected double getInitialDomain(double p) {
    double ret;
    double d = getDenominatorDegreesOfFreedom();
    // use mean
    ret = d / (d - 2.0);
    return ret;
}","public void test035() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(8.441822398385275E-5, 0.9999999999999971);
    double double0 = fDistributionImpl0.getInitialDomain(0.9995456442973051);
    assertEquals((-0.9999999999999942), double0, 0.01);
}","/**
 * Access the initial domain value, based on <code>p</code>, used to
 * bracket a CDF root.  This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return initial domain value
 */"
"protected double getDomainUpperBound(double p) {
    return Double.MAX_VALUE;
}","public void test046() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainUpperBound(417.040445);
    assertEquals(1.7976931348623157E308, double0, 0.01);
}","/**
 * Access the domain value upper bound, based on <code>p</code>, used to
 * bracket a CDF root.  This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.
 *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test047() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainUpperBound(417.040445);
    assertEquals(1701.2, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test048() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainUpperBound(417.040445);
    assertEquals(3161.329915527, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"protected double getDomainLowerBound(double p) {
    return 0.0;
}","public void test059() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainLowerBound(1023.111003045955);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Access the domain value lower bound, based on <code>p</code>, used to
 * bracket a CDF root.  This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.
 *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test0510() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainLowerBound(1023.111003045955);
    assertEquals(3161.329915527, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test0511() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDomainLowerBound(1023.111003045955);
    assertEquals(1701.2, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double cumulativeProbability(double x) throws MathException {
    double ret;
    if (x <= 0.0) {
        ret = 0.0;
    } else {
        double n = getNumeratorDegreesOfFreedom();
        double m = getDenominatorDegreesOfFreedom();
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test0612() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1107.0, 1.0E-14);
    double double0 = fDistributionImpl0.cumulativeProbability(1.0E-14);
    assertEquals((-1.5787371410169726E-13), double0, 0.01);
}","/**
 * For this distribution, X, this method returns P(X &lt; x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 * F-Distribution</a>, equation (4).</li>
 * </ul>
 *
 * @param x the value at which the CDF is evaluated.
 * @return CDF for this distribution.
 * @throws MathException if the cumulative probability can not be
 *            computed due to convergence or other numerical errors.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test0713() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 1701.2);
    fDistributionImpl0.setNumeratorDegreesOfFreedom(1.0E-6);
    // Undeclared exception!
    fDistributionImpl0.inverseCumulativeProbability(0.9999967531099152);
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test0814() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1389.8747, 1389.8747);
    // Undeclared exception!
    try {
        fDistributionImpl0.inverseCumulativeProbability(1.7976931348623157E308);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // p must be between 0.0 and 1.0, inclusive.
        //
        verifyException(""org.apache.commons.math.distribution.AbstractContinuousDistribution"", e);
    }
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test0915() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    fDistributionImpl0.setDenominatorDegreesOfFreedom(1023.111003045955);
    assertEquals(1023.111003045955, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
    if (degreesOfFreedom <= 0.0) {
        throw new IllegalArgumentException(""degrees of freedom must be positive."");
    }
    this.numeratorDegreesOfFreedom = degreesOfFreedom;
}","public void test1016() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(4347.3109934, 4347.3109934);
    // Undeclared exception!
    try {
        fDistributionImpl0.setNumeratorDegreesOfFreedom(0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom must be positive.
        //
        verifyException(""org.apache.commons.math.distribution.FDistributionImpl"", e);
    }
}","/**
 * Modify the numerator degrees of freedom.
 * @param degreesOfFreedom the new numerator degrees of freedom.
 * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
 *         positive.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1117() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1.0, 1.7976931348623157E308);
    double double0 = fDistributionImpl0.cumulativeProbability((-1817.526));
    assertEquals(1.7976931348623157E308, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1118() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1.0, 1.7976931348623157E308);
    double double0 = fDistributionImpl0.cumulativeProbability((-1817.526));
    assertEquals(1.0, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double cumulativeProbability(double x) throws MathException {
    double ret;
    if (x <= 0.0) {
        ret = 0.0;
    } else {
        double n = getNumeratorDegreesOfFreedom();
        double m = getDenominatorDegreesOfFreedom();
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test1119() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1.0, 1.7976931348623157E308);
    double double0 = fDistributionImpl0.cumulativeProbability((-1817.526));
    assertEquals(0.0, double0, 0.01);
}","/**
 * For this distribution, X, this method returns P(X &lt; x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 * F-Distribution</a>, equation (4).</li>
 * </ul>
 *
 * @param x the value at which the CDF is evaluated.
 * @return CDF for this distribution.
 * @throws MathException if the cumulative probability can not be
 *            computed due to convergence or other numerical errors.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1220() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDenominatorDegreesOfFreedom();
    assertEquals(1701.2, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1221() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getDenominatorDegreesOfFreedom();
    assertEquals(3161.329915527, double0, 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1322() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getNumeratorDegreesOfFreedom();
    assertEquals(3161.329915527, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1323() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1701.2, 3161.329915527);
    double double0 = fDistributionImpl0.getNumeratorDegreesOfFreedom();
    assertEquals(1701.2, double0, 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
    if (degreesOfFreedom <= 0.0) {
        throw new IllegalArgumentException(""degrees of freedom must be positive."");
    }
    this.denominatorDegreesOfFreedom = degreesOfFreedom;
}","public void test1424() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(8.441822398385275E-5, 0.9999999999999971);
    // Undeclared exception!
    try {
        fDistributionImpl0.setDenominatorDegreesOfFreedom(0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom must be positive.
        //
        verifyException(""org.apache.commons.math.distribution.FDistributionImpl"", e);
    }
}","/**
 * Modify the denominator degrees of freedom.
 * @param degreesOfFreedom the new denominator degrees of freedom.
 * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
 *         positive.
 */"
"public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) {
    super();
    setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
    setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
}","public void test1525() throws Throwable {
    FDistributionImpl fDistributionImpl0 = null;
    try {
        fDistributionImpl0 = new FDistributionImpl((-2976.553895288), (-2976.553895288));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom must be positive.
        //
        verifyException(""org.apache.commons.math.distribution.FDistributionImpl"", e);
    }
}","/**
 * Create a F distribution using the given degrees of freedom.
 * @param numeratorDegreesOfFreedom the numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom the denominator degrees of freedom.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test1626() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1389.8747, 1389.8747);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(1.0);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1627() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1389.8747, 1389.8747);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(1.0);
    assertEquals(1389.8747, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1628() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1389.8747, 1389.8747);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(1.0);
    assertEquals(1389.8747, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test1729() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(2446.3075409, 2446.3075409);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1730() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(2446.3075409, 2446.3075409);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(0.0);
    assertEquals(2446.3075409, fDistributionImpl0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1731() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(2446.3075409, 2446.3075409);
    double double0 = fDistributionImpl0.inverseCumulativeProbability(0.0);
    assertEquals(2446.3075409, fDistributionImpl0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 * @return the denominator degrees of freedom.
 */"
"public double inverseCumulativeProbability(final double p) throws MathException {
    if (p == 0) {
        return 0d;
    }
    if (p == 1) {
        return Double.POSITIVE_INFINITY;
    }
    return super.inverseCumulativeProbability(p);
}","public void test1832() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(234.30556717516757, 234.30556717516757);
    try {
        fDistributionImpl0.inverseCumulativeProbability(0.9999999999999999);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Number of iterations=2, maximum iterations=2,147,483,647, initial=1.009, lower bound=0, upper bound=179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000, final a value=0, final b value=3.009, f(a)=-1, f(b)=0
        //
        verifyException(""org.apache.commons.math.distribution.AbstractContinuousDistribution"", e);
    }
}","/**
 * For this distribution, X, this method returns the critical point x, such
 * that P(X &lt; x) = <code>p</code>.
 * <p>
 * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
 *
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not be
 *         computed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a valid
 *         probability.
 */"
"public double cumulativeProbability(double x) throws MathException {
    double ret;
    if (x <= 0.0) {
        ret = 0.0;
    } else {
        double n = getNumeratorDegreesOfFreedom();
        double m = getDenominatorDegreesOfFreedom();
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test1933() throws Throwable {
    FDistributionImpl fDistributionImpl0 = new FDistributionImpl(1389.8747, 1389.8747);
    double double0 = fDistributionImpl0.cumulativeProbability(1389.8747);
    assertEquals(1.0, double0, 0.01);
}","/**
 * For this distribution, X, this method returns P(X &lt; x).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 * F-Distribution</a>, equation (4).</li>
 * </ul>
 *
 * @param x the value at which the CDF is evaluated.
 * @return CDF for this distribution.
 * @throws MathException if the cumulative probability can not be
 *            computed due to convergence or other numerical errors.
 */"
