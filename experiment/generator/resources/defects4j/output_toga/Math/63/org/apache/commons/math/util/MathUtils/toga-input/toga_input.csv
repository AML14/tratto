focal_method,test_prefix,docstring
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test0000() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[5] = 1.63E18;
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(1.63E18, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test0013() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[7] = 3.834E-20;
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(3.834E-20, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test0026() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 61;
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.DECREASING;
    MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, false);
    assertArrayEquals(new double[] { 61.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test0038() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = (double) 2821L;
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not strictly decreasing (0 <= 2,821)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test0049() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[1] = 1060.6;
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 1 and 2 are not increasing (1,060.6 > 0)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val) {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test00510() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[1] = (double) 872356L;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 1 and 2 are not strictly increasing (872,356 >= 0)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test00611() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = 14;
    double double0 = MathUtils.distance(intArray0, intArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test00714() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 3628800L;
    double double0 = MathUtils.distance(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test00818() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[0] = (int) (byte) 1;
    int[] intArray1 = new int[5];
    // Undeclared exception!
    try {
        MathUtils.distance1(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test00919() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[0] = (int) (byte) 1;
    int int0 = MathUtils.distance1(intArray0, intArray0);
    assertEquals(0, int0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test01022() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[5] = Double.NEGATIVE_INFINITY;
    double double0 = MathUtils.distance1(doubleArray0, doubleArray0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test01125() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1.0F;
    double double0 = MathUtils.distance1(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test01233() throws Throwable {
    byte[] byteArray0 = new byte[7];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 0L);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test01343() throws Throwable {
    long long0 = MathUtils.pow(0L, 0L);
    assertEquals(1L, long0);
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test01444() throws Throwable {
    float float0 = MathUtils.round(Float.NaN, 0);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test01545() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) (short) (-310);
    double[] doubleArray1 = MathUtils.normalizeArray(doubleArray0, 0.9999997615814209);
    assertNotNull(doubleArray1);
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test01653() throws Throwable {
    double double0 = MathUtils.scalb((-6340.6206967), (-1981));
    assertEquals((-9.357104580839268E23), double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test01754() throws Throwable {
    short short0 = MathUtils.indicator((short) 0);
    assertEquals((short) 1, short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test01855() throws Throwable {
    long long0 = MathUtils.indicator(0L);
    assertEquals(1L, long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test01956() throws Throwable {
    int int0 = MathUtils.indicator(2471);
    assertEquals(1, int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test02057() throws Throwable {
    double double0 = MathUtils.indicator((double) 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test02158() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) 39);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test02259() throws Throwable {
    long long0 = MathUtils.gcd(0L, 2216L);
    assertEquals(2216L, long0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);
}","public void test02360() throws Throwable {
    double double0 = MathUtils.factorialDouble((byte) 110);
    assertEquals(1.588245541522966E178, double0, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test02462() throws Throwable {
    double[] doubleArray0 = new double[6];
    double[] doubleArray1 = new double[8];
    boolean boolean0 = MathUtils.equalsIncludingNaN(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test02572() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[9];
    boolean boolean0 = MathUtils.equals(doubleArray1, doubleArray0);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);
}","public void test02681() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.equalsIncludingNaN(0.0, 752.22, 0);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if both arguments are NaN or if there are less than
 * {@code maxUlps} floating point values between {@code x} and {@code y}.
 */"
"public static boolean equalsIncludingNaN(double x, double y, double eps) {
    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);
}","public void test02782() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(0.4342944622039795, 0.0, 0.4342944622039795);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other,
 * or both are NaN.
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;
}","public void test02883() throws Throwable {
    boolean boolean0 = MathUtils.equals(1.0, (double) 2L, 1.0);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other.
 */"
"public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","public void test02984() throws Throwable {
    boolean boolean0 = MathUtils.equals(10.0, 3087.04427599);
    assertFalse(boolean0);
}","/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test03085() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(61, (-6));
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
    }
    return ret;
}","public void test03186() throws Throwable {
    long long0 = MathUtils.subAndCheck(0L, (long) 9);
    assertEquals((-9L), long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);
}","public void test03287() throws Throwable {
    long long0 = MathUtils.addAndCheck(1800L, 1800L);
    assertEquals(3600L, long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);
    }
    return (int) s;
}","public void test03388() throws Throwable {
    int int0 = MathUtils.addAndCheck(31, 64);
    assertEquals(95, int0);
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
    }
    return ret;
}","public void test03489() throws Throwable {
    long long0 = MathUtils.subAndCheck(471L, (long) 1);
    assertEquals(470L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);
    }
    return (int) s;
}","public void test03590() throws Throwable {
    int int0 = MathUtils.subAndCheck((-639), (-639));
    assertEquals(0, int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);
    }
    return (int) s;
}","public void test03691() throws Throwable {
    int int0 = MathUtils.subAndCheck(0, 2257);
    assertEquals((-2257), int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double sinh(double x) {
    return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;
}","public void test03792() throws Throwable {
    double double0 = MathUtils.sinh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;
}","public void test03893() throws Throwable {
    double double0 = MathUtils.sinh((-3052.3));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) FastMath.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test03994() throws Throwable {
    float float0 = MathUtils.round(0.0F, 9, 0);
    assertEquals(1.0E-9F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) FastMath.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test04095() throws Throwable {
    float float0 = MathUtils.round((-3002.0F), 0, 0);
    assertEquals((-3003.0F), float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test04196() throws Throwable {
    float float0 = MathUtils.round((float) 0, 915);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test04297() throws Throwable {
    float float0 = MathUtils.round((float) 14, 14);
    assertEquals(14.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test04398() throws Throwable {
    float float0 = MathUtils.round((-3241.0F), 30);
    assertEquals((-3241.0F), float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test04499() throws Throwable {
    double double0 = MathUtils.round(0.0, 0, 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test045100() throws Throwable {
    double double0 = MathUtils.round((double) 1, 136, 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test046101() throws Throwable {
    double double0 = MathUtils.round(1062.0, 706);
    assertEquals(1062.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test047102() throws Throwable {
    double double0 = MathUtils.round((-1531.101501175026), 927);
    assertEquals((-1531.101501175026), double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test048108() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 95;
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, bigInteger0);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test049121() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 194L);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test050134() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 85;
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 544L);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    return k.pow(e);
}","public void test051147() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 0);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test052154() throws Throwable {
    long long0 = MathUtils.pow(4635822497680326656L, (long) 1);
    assertEquals(4635822497680326656L, long0);
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test053155() throws Throwable {
    long long0 = MathUtils.pow((-4035746434778044925L), 483L);
    assertEquals((-1661078885208841573L), long0);
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test054156() throws Throwable {
    long long0 = MathUtils.pow((long) (byte) 0, 1);
    assertEquals(0L, long0);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test055157() throws Throwable {
    long long0 = MathUtils.pow((-309L), 0);
    assertEquals(1L, long0);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test056158() throws Throwable {
    int int0 = MathUtils.pow(1880, (long) 1880);
    assertEquals(0, int0);
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test057159() throws Throwable {
    int int0 = MathUtils.pow(143, (long) 143);
    assertEquals((-1907505297), int0);
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test058160() throws Throwable {
    int int0 = MathUtils.pow(1, (int) (byte) 0);
    assertEquals(1, int0);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test059161() throws Throwable {
    int int0 = MathUtils.pow(9, 272);
    assertEquals((-1741412735), int0);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);
}","public void test060162() throws Throwable {
    double double0 = MathUtils.normalizeAngle(0.0, 0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);
}","public void test061163() throws Throwable {
    double double0 = MathUtils.normalizeAngle(2304L, (-2648.155));
    assertEquals((-2647.1500220575135), double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test062164() throws Throwable {
    int int0 = MathUtils.mulAndCheck(0, 40);
    assertEquals(0, int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test063165() throws Throwable {
    int int0 = MathUtils.mulAndCheck((-2703), 3908);
    assertEquals((-10563324), int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double log(double base, double x) {
    return FastMath.log(x) / FastMath.log(base);
}","public void test064166() throws Throwable {
    double double0 = MathUtils.log(0.0, 570.4046387729519);
    assertEquals(-0.0, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double log(double base, double x) {
    return FastMath.log(x) / FastMath.log(base);
}","public void test065167() throws Throwable {
    double double0 = MathUtils.log(4507L, 4507L);
    assertEquals(1.0, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double log(double base, double x) {
    return FastMath.log(x) / FastMath.log(base);
}","public void test066168() throws Throwable {
    double double0 = MathUtils.log((byte) 1, 0.0);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test067169() throws Throwable {
    int int0 = MathUtils.hash((double[]) null);
    assertEquals(0, int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test068170() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = Double.NEGATIVE_INFINITY;
    int int0 = MathUtils.hash(doubleArray0);
    assertEquals((-1985685345), int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test069173() throws Throwable {
    int int0 = MathUtils.hash(1.0);
    assertEquals(1072693248, int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test070174() throws Throwable {
    int int0 = MathUtils.hash(9.219544613762692E-9);
    assertEquals((-1287859880), int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test071175() throws Throwable {
    int int0 = MathUtils.gcd(0, 0);
    assertEquals(0, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test072177() throws Throwable {
    int[] intArray0 = new int[3];
    int[] intArray1 = new int[6];
    intArray1[0] = (-2147483644);
    int int0 = MathUtils.distanceInf(intArray0, intArray1);
    assertNotSame(intArray0, intArray1);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test073187() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = 49.053375057164;
    double double0 = MathUtils.distanceInf(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test074197() throws Throwable {
    int[] intArray0 = new int[6];
    intArray0[2] = 1030;
    int[] intArray1 = new int[6];
    double double0 = MathUtils.distance(intArray0, intArray1);
    assertNotSame(intArray0, intArray1);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test075207() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 114.316110400768;
    double[] doubleArray1 = new double[6];
    double double0 = MathUtils.distance(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);
}","public void test076216() throws Throwable {
    long long0 = MathUtils.addAndCheck(0L, (long) (short) 0);
    assertEquals(0L, long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);
}","public void test077217() throws Throwable {
    long long0 = MathUtils.addAndCheck((long) (byte) 1, (-1694L));
    assertEquals((-1693L), long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test078218() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.safeNorm((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test079219() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round(2921.464137515, (int) (byte) 0, (-2682));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test080220() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round((-1725.28993636968), 710504735, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // BigInteger would overflow supported range
        //
        verifyException(""java.math.BigInteger"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test081221() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, (BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test082222() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 65L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    return k.pow(e);
}","public void test083223() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 883);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    return k.pow(e);
}","public void test084228() throws Throwable {
    MockRandom mockRandom0 = new MockRandom((-37L));
    BigInteger bigInteger0 = new BigInteger(1162067162, mockRandom0);
    // Undeclared exception!
    try {
        MathUtils.pow(bigInteger0, 1162067162);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // BigInteger would overflow supported range
        //
        verifyException(""java.math.BigInteger"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test085229() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.normalizeArray((double[]) null, (-1067.364075367));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static long lcm(long a, long b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Long.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);
    }
    return lcm;
}","public void test086230() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.lcm(4577762542105553359L, 121645100408832000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and
 * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^63, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is
 * <code>0L</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);
    }
    return lcm;
}","public void test087231() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.lcm((-1287859880), (-2376));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return FastMath.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    return logSum;
}","public void test088232() throws Throwable {
    // Undeclared exception!
    MathUtils.factorialLog(2143136515);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test089233() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.distanceInf((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test090235() throws Throwable {
    int[] intArray0 = new int[6];
    int[] intArray1 = new int[1];
    // Undeclared exception!
    try {
        MathUtils.distanceInf(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test091236() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.distanceInf((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test092237() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.distance1((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test093238() throws Throwable {
    double[] doubleArray0 = new double[1];
    // Undeclared exception!
    try {
        MathUtils.distance1(doubleArray0, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test094239() throws Throwable {
    int[] intArray0 = new int[5];
    // Undeclared exception!
    try {
        MathUtils.distance((int[]) null, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test095241() throws Throwable {
    int[] intArray0 = new int[7];
    int[] intArray1 = new int[1];
    // Undeclared exception!
    try {
        MathUtils.distance(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test096242() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.distance((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test097244() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[1];
    // Undeclared exception!
    try {
        MathUtils.distance(doubleArray0, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test098245() throws Throwable {
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder((double[]) null, mathUtils_OrderDirection0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test099246() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, true);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test100247() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-2147483647), 72);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -2,147,483,647, k = 72
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test101248() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-386), 1547);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -386, k = 1,547
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test102249() throws Throwable {
    double[] doubleArray0 = new double[6];
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not strictly increasing (0 >= 0)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test103250() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(287L, 2935890503282001226L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test104251() throws Throwable {
    long long0 = MathUtils.mulAndCheck((long) (short) 1, 336L);
    assertEquals(336L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test105252() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-5034868814120038111L), 1L);
    assertEquals((-5034868814120038111L), long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test106253() throws Throwable {
    long long0 = MathUtils.mulAndCheck(0L, 1800L);
    assertEquals(0L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test107254() throws Throwable {
    int int0 = MathUtils.mulAndCheck((-473), (-1621));
    assertEquals(766733, int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test108255() throws Throwable {
    float float0 = MathUtils.indicator((-1.0F));
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test109256() throws Throwable {
    long long0 = MathUtils.gcd(355687428096000L, 355687428096000L);
    assertEquals(355687428096000L, long0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test110257() throws Throwable {
    int int0 = MathUtils.gcd(9, 1532);
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test111258() throws Throwable {
    long long0 = MathUtils.factorial(13);
    assertEquals(6227020800L, long0);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","public void test112259() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) 1, (double) (-978), 123);
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or less) floating point numbers between them (i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","public void test113260() throws Throwable {
    boolean boolean0 = MathUtils.equals((-1409.0), (-1409.0), 902);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or less) floating point numbers between them (i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","public void test114261() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.equals(0.5000000000042687, 3087.04427599, 1073741824);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or less) floating point numbers between them (i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","public void test115262() throws Throwable {
    boolean boolean0 = MathUtils.equals(545.8799724201457, 545.8799724201457, 1030);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or less) floating point numbers between them (i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","public void test116263() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.equals((-3010.7841332), 1439.9909648456148, (-2144));
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or less) floating point numbers between them (i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;
}","public void test117264() throws Throwable {
    boolean boolean0 = MathUtils.equals((-2259.94506036678), (-2259.94506036678), (-2259.94506036678));
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other.
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;
}","public void test118265() throws Throwable {
    boolean boolean0 = MathUtils.equals(2.2250738585072014E-308, (double) 1, 2.2250738585072014E-308);
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other.
 */"
"public static boolean equalsIncludingNaN(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);
}","public void test119266() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(0.0, 0.0);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(double,double) this method}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal or both are NaN.
 */"
"public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","public void test120267() throws Throwable {
    boolean boolean0 = MathUtils.equals((-3052.3), (-3052.3));
    assertTrue(boolean0);
}","/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test121268() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(2025, 14);
    assertEquals(81.35029006264689, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test122269() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(119764, 927);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test123270() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[2] = Double.NaN;
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test124273() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 2.2250738585072014E-308;
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(2.2250738585072014E-308, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test125276() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[6] = Double.POSITIVE_INFINITY;
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0.0;
    double s2 = 0.0;
    double s3 = 0.0;
    double x1max = 0.0;
    double x3max = 0.0;
    double floatn = (double) v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1.0 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1.0 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0.0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0.0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0.0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1.0 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test126279() throws Throwable {
    double[] doubleArray0 = new double[8];
    double double0 = MathUtils.safeNorm(doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available <a
 * href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v vector of doubles
 * @return the 2-norm of the vector
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test127282() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[1] = 1060.6;
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not decreasing (0 < 1,060.6)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test128283() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 61;
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 1 and 2 are not strictly decreasing (0 <= 0)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val) {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test129284() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 1.0;
    MathUtils.checkOrder(doubleArray0);
    assertArrayEquals(new double[] { 0.0, 1.0 }, doubleArray0, 0.01);
}","/**
 * Checks that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
    double previous = val[0];
    boolean ok = true;
    int max = val.length;
    for (int i = 1; i < max; i++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[i] <= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] < previous) {
                        ok = false;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[i] >= previous) {
                        ok = false;
                    }
                } else {
                    if (val[i] > previous) {
                        ok = false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new IllegalArgumentException();
        }
        if (!ok) {
            throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
        }
        previous = val[i];
    }
}","public void test130286() throws Throwable {
    double[] doubleArray0 = new double[3];
    MathUtils.OrderDirection mathUtils_OrderDirection0 = MathUtils.OrderDirection.INCREASING;
    MathUtils.checkOrder(doubleArray0, mathUtils_OrderDirection0, false);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * Checks that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test131288() throws Throwable {
    int[] intArray0 = new int[4];
    int int0 = MathUtils.distanceInf(intArray0, intArray0);
    assertEquals(0, int0);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test132291() throws Throwable {
    double[] doubleArray0 = new double[4];
    double double0 = MathUtils.distanceInf(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test133297() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, bigInteger0);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test134310() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) (-33);
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    try {
        MathUtils.pow(bigInteger0, bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (-608,742,554,432,415,203,328^-608,742,554,432,415,203,328)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test135314() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, bigInteger0);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test136327() throws Throwable {
    byte[] byteArray0 = new byte[1];
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 544L);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test137340() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    try {
        MathUtils.pow(bigInteger0, (-4607181111125649408L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (10^-4,607,181,111,125,649,408)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    return k.pow(e);
}","public void test138344() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    try {
        MathUtils.pow(bigInteger0, (-997));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1^-997)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    return k.pow(e);
}","public void test139348() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 992);
    assertNotNull(bigInteger1);
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test140356() throws Throwable {
    try {
        MathUtils.pow(0L, (-638L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-638)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test141357() throws Throwable {
    long long0 = MathUtils.pow(0L, 1581L);
    assertEquals(0L, long0);
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test142358() throws Throwable {
    try {
        MathUtils.pow((long) 1, (-1841));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1^-1,841)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test143359() throws Throwable {
    long long0 = MathUtils.pow(4294967295L, 596);
    assertEquals((-2559800508415L), long0);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test144360() throws Throwable {
    int int0 = MathUtils.pow((-2059), 2L);
    assertEquals(4239481, int0);
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test145361() throws Throwable {
    try {
        MathUtils.pow(14, (-1445L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (14^-1,445)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test146362() throws Throwable {
    int int0 = MathUtils.pow(395, (long) 0);
    assertEquals(1, int0);
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test147363() throws Throwable {
    try {
        MathUtils.pow((-3551), (-3551));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (-3,551^-3,551)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test148364() throws Throwable {
    int int0 = MathUtils.pow(0, 2682);
    assertEquals(0, int0);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);
    }
    return (int) s;
}","public void test149365() throws Throwable {
    int int0 = MathUtils.subAndCheck(220, (-967));
    assertEquals(1187, int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);
    }
    return (int) s;
}","public void test150366() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.subAndCheck((-2147483646), (int) (short) 238);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in subtraction: -2,147,483,646 - 238
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test151367() throws Throwable {
    short short0 = MathUtils.sign((short) (-4654));
    assertEquals((short) (-1), short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test152368() throws Throwable {
    short short0 = MathUtils.sign((short) 0);
    assertEquals((short) 0, short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test153369() throws Throwable {
    short short0 = MathUtils.sign((short) 85);
    assertEquals((short) 1, short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test154370() throws Throwable {
    long long0 = MathUtils.sign((long) (-1367));
    assertEquals((-1L), long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test155371() throws Throwable {
    long long0 = MathUtils.sign(0L);
    assertEquals(0L, long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test156372() throws Throwable {
    long long0 = MathUtils.sign((long) 916);
    assertEquals(1L, long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test157373() throws Throwable {
    int int0 = MathUtils.sign((-2355));
    assertEquals((-1), int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test158374() throws Throwable {
    int int0 = MathUtils.sign(0);
    assertEquals(0, int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test159375() throws Throwable {
    int int0 = MathUtils.sign(4239481);
    assertEquals(1, int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test160376() throws Throwable {
    float float0 = MathUtils.sign(1694.555F);
    assertEquals(1.0F, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test161377() throws Throwable {
    float float0 = MathUtils.sign((float) 0);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test162378() throws Throwable {
    float float0 = MathUtils.sign(Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test163379() throws Throwable {
    float float0 = MathUtils.sign((-61.0F));
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test164380() throws Throwable {
    double double0 = MathUtils.sign((-48.01345));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test165381() throws Throwable {
    double double0 = MathUtils.sign(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test166382() throws Throwable {
    double double0 = MathUtils.sign(323.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test167383() throws Throwable {
    byte byte0 = MathUtils.sign((byte) (-31));
    assertEquals((byte) (-1), byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test168384() throws Throwable {
    byte byte0 = MathUtils.sign((byte) 0);
    assertEquals((byte) 0, byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test169385() throws Throwable {
    byte byte0 = MathUtils.sign((byte) 24);
    assertEquals((byte) 1, byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) FastMath.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test170386() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round((float) 0, 0, (-1687));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // invalid rounding method -1,687, valid methods: ROUND_CEILING (2), ROUND_DOWN (1), ROUND_FLOOR (3), ROUND_HALF_DOWN (5), ROUND_HALF_EVEN (6), ROUND_HALF_UP (4), ROUND_UNNECESSARY (7), ROUND_UP (0)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) FastMath.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test171387() throws Throwable {
    float float0 = MathUtils.round((float) 2508, 2508, 1);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) FastMath.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test172388() throws Throwable {
    float float0 = MathUtils.round((float) 0L, 9998, 0);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test173389() throws Throwable {
    double double0 = MathUtils.round(Double.NEGATIVE_INFINITY, 61, 0);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test174390() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) Float.NaN;
    doubleArray0[2] = (double) 402;
    double[] doubleArray1 = MathUtils.normalizeArray(doubleArray0, 2202.8);
    assertNotNull(doubleArray1);
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test175398() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) Float.NaN;
    try {
        MathUtils.normalizeArray(doubleArray0, 2202.8);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // array sums to zero
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test176399() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[4] = Double.POSITIVE_INFINITY;
    try {
        MathUtils.normalizeArray(doubleArray0, (-3551.0));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Array contains an infinite element, \u221E at index 4
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test177400() throws Throwable {
    double[] doubleArray0 = new double[3];
    try {
        MathUtils.normalizeArray(doubleArray0, Double.NaN);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot normalize to NaN
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test178401() throws Throwable {
    double double0 = MathUtils.scalb(Double.POSITIVE_INFINITY, (byte) 9);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test179402() throws Throwable {
    double double0 = MathUtils.scalb(0.0, (-64));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test180403() throws Throwable {
    long long0 = MathUtils.mulAndCheck(2307L, 0L);
    assertEquals(0L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test181404() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((long) (-1981), 2935890503282001226L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test182405() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-904L), 0L);
    assertEquals(0L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test183406() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-934L), (-934L));
    assertEquals(872356L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test184407() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-976L), (-4035746434778044925L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test185408() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(Integer.MIN_VALUE, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test186409() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-2146209931), 6);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static long lcm(long a, long b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Long.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);
    }
    return lcm;
}","public void test187410() throws Throwable {
    long long0 = MathUtils.lcm((-95L), 0L);
    assertEquals(0L, long0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and
 * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^63, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is
 * <code>0L</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static long lcm(long a, long b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Long.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);
    }
    return lcm;
}","public void test188411() throws Throwable {
    long long0 = MathUtils.lcm(0L, (-5241L));
    assertEquals(0L, long0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and
 * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^63, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is
 * <code>0L</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);
    }
    return lcm;
}","public void test189412() throws Throwable {
    int int0 = MathUtils.lcm((-1712), 0);
    assertEquals(0, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);
    }
    return lcm;
}","public void test190413() throws Throwable {
    int int0 = MathUtils.lcm(70, 70);
    assertEquals(70, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);
    }
    return lcm;
}","public void test191414() throws Throwable {
    int int0 = MathUtils.lcm(0, 931);
    assertEquals(0, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test192415() throws Throwable {
    short short0 = MathUtils.indicator((short) 78);
    assertEquals((short) 1, short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test193416() throws Throwable {
    short short0 = MathUtils.indicator((short) (-2116));
    assertEquals((short) (-1), short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test194417() throws Throwable {
    long long0 = MathUtils.indicator((long) 70);
    assertEquals(1L, long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test195418() throws Throwable {
    long long0 = MathUtils.indicator((-2175L));
    assertEquals((-1L), long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test196419() throws Throwable {
    int int0 = MathUtils.indicator(0);
    assertEquals(1, int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test197420() throws Throwable {
    int int0 = MathUtils.indicator((-1400));
    assertEquals((-1), int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test198421() throws Throwable {
    float float0 = MathUtils.indicator(1.0F);
    assertEquals(1.0F, float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test199422() throws Throwable {
    float float0 = MathUtils.indicator(Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test200423() throws Throwable {
    double double0 = MathUtils.indicator(1.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test201424() throws Throwable {
    double double0 = MathUtils.indicator((double) (-681));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test202425() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) 0);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test203426() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) (-31));
    assertEquals((byte) (-1), byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test204427() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.gcd((-9223372036854775808L), (-9223372036854775808L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: gcd(-9,223,372,036,854,775,808, -9,223,372,036,854,775,808) is 2^63
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static long lcm(long a, long b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Long.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);
    }
    return lcm;
}","public void test205428() throws Throwable {
    long long0 = MathUtils.lcm(395L, (-2144L));
    assertEquals(846880L, long0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and
 * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^63, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is
 * <code>0L</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test206429() throws Throwable {
    long long0 = MathUtils.gcd((-1L), (long) (short) 0);
    assertEquals(1L, long0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test207430() throws Throwable {
    long long0 = MathUtils.gcd((-9223372036854775808L), 4648655997399728128L);
    assertEquals(8796093022208L, long0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static long gcd(final long p, final long q) {
    long u = p;
    long v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^63, while positive numbers can only be as large as 2^63-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 63) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    long t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1L << k);
}","public void test208431() throws Throwable {
    long long0 = MathUtils.gcd((long) 0, (long) 0);
    assertEquals(0L, long0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,
 * <code>gcd(Long.MIN_VALUE, 0L)</code> and
 * <code>gcd(0L, Long.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and
 * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns
 * <code>0L</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a nonnegative long
 * value
 * @since 2.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test209432() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: gcd(-2,147,483,648, -2,147,483,648) is 2^31
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test210433() throws Throwable {
    int int0 = MathUtils.gcd((-1172), (-2567));
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test211434() throws Throwable {
    int int0 = MathUtils.gcd((-1), 0);
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
        }
        return FastMath.abs(u) + FastMath.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test212435() throws Throwable {
    int int0 = MathUtils.gcd(0, (-303));
    assertEquals(303, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException if the result cannot be represented as a
 * nonnegative int value
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return FastMath.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    return logSum;
}","public void test213436() throws Throwable {
    double double0 = MathUtils.factorialLog(1300);
    assertEquals(8025.659468892016, double0, 0.01);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return FastMath.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    return logSum;
}","public void test214437() throws Throwable {
    double double0 = MathUtils.factorialLog(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return FastMath.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    return logSum;
}","public void test215438() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorialLog((-1192));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1,192
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);
}","public void test216439() throws Throwable {
    // Undeclared exception!
    MathUtils.factorialDouble(2117237399);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);
}","public void test217440() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-1108));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1,108
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test218441() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorial(83);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // factorial value is too large to fit in a long
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test219442() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorial((-82));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -82
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);
}","public void test220443() throws Throwable {
    double double0 = MathUtils.factorialDouble(0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test221445() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = 49.053375057164;
    boolean boolean0 = MathUtils.equalsIncludingNaN(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test222455() throws Throwable {
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = new double[5];
    boolean boolean0 = MathUtils.equalsIncludingNaN(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test223464() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN((double[]) null, (double[]) null);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test224465() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1.0F;
    doubleArray0[2] = (double) 1.0F;
    double[] doubleArray1 = MathUtils.normalizeArray(doubleArray0, 1.0);
    assertNotNull(doubleArray1);
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 * @since 2.1
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test224473() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1.0F;
    doubleArray0[2] = (double) 1.0F;
    double[] doubleArray1 = MathUtils.normalizeArray(doubleArray0, 1.0);
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test225483() throws Throwable {
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = new double[6];
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray1);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test226492() throws Throwable {
    double[] doubleArray0 = new double[1];
    boolean boolean0 = MathUtils.equals((double[]) null, doubleArray0);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test227495() throws Throwable {
    double[] doubleArray0 = new double[1];
    boolean boolean0 = MathUtils.equals(doubleArray0, (double[]) null);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test228498() throws Throwable {
    boolean boolean0 = MathUtils.equals((double[]) null, (double[]) null);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);
}","public void test229499() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(0.0, (double) 0.0F, 647);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if both arguments are NaN or if there are less than
 * {@code maxUlps} floating point values between {@code x} and {@code y}.
 */"
"public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);
}","public void test230500() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN((double) (short) 1, (double) (short) 19, 22);
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if both arguments are NaN or if there are less than
 * {@code maxUlps} floating point values between {@code x} and {@code y}.
 */"
"public static boolean equalsIncludingNaN(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);
}","public void test231501() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN((double) 0, (-1769.71));
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(double,double) this method}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal or both are NaN.
 */"
"public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);
}","public void test232502() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.equalsIncludingNaN((double) 6L, 2.0, 4194304);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if both arguments are NaN or if there are less than
 * {@code maxUlps} floating point values between {@code x} and {@code y}.
 */"
"public static boolean equalsIncludingNaN(double x, double y, double eps) {
    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);
}","public void test233503() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(11.0, 888.8365771801, 1242.851314);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other,
 * or both are NaN.
 */"
"public static boolean equalsIncludingNaN(double x, double y, double eps) {
    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);
}","public void test234504() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(0.0, 2021.0989655927, (-189.65088836));
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other,
 * or both are NaN.
 */"
"public static boolean equalsIncludingNaN(double x, double y, double eps) {
    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);
}","public void test235505() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(10.0, 10.0, 10.0);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other,
 * or both are NaN.
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;
}","public void test236506() throws Throwable {
    boolean boolean0 = MathUtils.equals(87.0, (double) 916, (double) 1300);
    assertTrue(boolean0);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow.
 * @return {@code true} if the values are equal or within range of each other.
 */"
"public static boolean equalsIncludingNaN(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);
}","public void test237507() throws Throwable {
    boolean boolean0 = MathUtils.equalsIncludingNaN(Double.NaN, 1568.3587501037364);
    assertFalse(boolean0);
}","/**
 * Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(double,double) this method}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal or both are NaN.
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test238508() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = Double.NaN;
    boolean boolean0 = MathUtils.equalsIncludingNaN(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test239511() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = Double.NaN;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static int compareTo(double x, double y, double eps) {
    if (equals(x, y, eps)) {
        return 0;
    } else if (x < y) {
        return -1;
    }
    return 1;
}","public void test240514() throws Throwable {
    int int0 = MathUtils.compareTo(Double.NaN, 0, 1);
    assertEquals(1, int0);
}","/**
 * Compares two numbers given some amount of allowed error.
 *
 * @param x the first number
 * @param y the second number
 * @param eps the amount of error to allow when checking for equality
 * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>
 *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>
 */"
"public static int compareTo(double x, double y, double eps) {
    if (equals(x, y, eps)) {
        return 0;
    } else if (x < y) {
        return -1;
    }
    return 1;
}","public void test241515() throws Throwable {
    int int0 = MathUtils.compareTo(1.304E19, 1.304E19, 0.097);
    assertEquals(0, int0);
}","/**
 * Compares two numbers given some amount of allowed error.
 *
 * @param x the first number
 * @param y the second number
 * @param eps the amount of error to allow when checking for equality
 * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>
 *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>
 */"
"public static int compareTo(double x, double y, double eps) {
    if (equals(x, y, eps)) {
        return 0;
    } else if (x < y) {
        return -1;
    }
    return 1;
}","public void test242516() throws Throwable {
    int int0 = MathUtils.compareTo(647.3, 2294L, 0.0);
    assertEquals((-1), int0);
}","/**
 * Compares two numbers given some amount of allowed error.
 *
 * @param x the first number
 * @param y the second number
 * @param eps the amount of error to allow when checking for equality
 * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>
 *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test243517() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-2595), (-2595));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k), got n = -2,595
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test244518() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1627, 1525);
    assertEquals(378.0249090546729, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test245519() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(524, (-3363));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test246520() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(205, 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test247521() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, (-681));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return FastMath.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return FastMath.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return FastMath.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += FastMath.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= FastMath.log(i);
    }
    return logSum;
}","public void test248522() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(0, 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test249523() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(2471, 13);
    assertEquals(1.9922011497261004E34, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test250524() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(2513, 1);
    assertEquals(2513.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test251525() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(2513, 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test252526() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(4, 4);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test253527() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(1382, (-622));
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test254528() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(66, 2);
    assertEquals(2145.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test255529() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(3239, 1924);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test256530() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(57, 1);
    assertEquals(57L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test257531() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(1030, 0);
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return FastMath.floor(result + 0.5);
}","public void test258532() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(39, 22);
    assertEquals(5.102111781E10, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test259533() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(0, 0);
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
    }
    return ret;
}","public void test260534() throws Throwable {
    long long0 = MathUtils.subAndCheck((-1862L), (-1862L));
    assertEquals(0L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
    }
    return ret;
}","public void test261535() throws Throwable {
    long long0 = MathUtils.subAndCheck((-874L), 1421L);
    assertEquals((-2295L), long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);
    }
    return (int) s;
}","public void test262536() throws Throwable {
    int int0 = MathUtils.addAndCheck((-1), 0);
    assertEquals((-1), int0);
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test263537() throws Throwable {
    double double0 = MathUtils.round(1.4456468917292502E-16, 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double cosh(double x) {
    return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;
}","public void test264538() throws Throwable {
    double double0 = MathUtils.cosh((-442.158));
    assertEquals(5.3180147029954794E191, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"">
 * hyperbolic cosine</a> of x.
 *
 * @param x double value for which to find the hyperbolic cosine
 * @return hyperbolic cosine of x
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);
}","public void test265539() throws Throwable {
    double double0 = MathUtils.normalizeAngle((-1493.0), 0);
    assertEquals(2.398103108741452, double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double sinh(double x) {
    return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;
}","public void test266540() throws Throwable {
    MathUtils.sinh(1.0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test267541() throws Throwable {
    double[] doubleArray0 = new double[0];
    int int0 = MathUtils.hash(doubleArray0);
    assertEquals(1, int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static void checkOrder(double[] val) {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test268542() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.checkOrder((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Checks that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonousSequenceException if the array is not sorted.
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test269543() throws Throwable {
    int int0 = MathUtils.hash((double) 0);
    assertEquals(0, int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
