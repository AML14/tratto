focal_method,test_prefix,docstring
"@Override
public double sample() {
    final double u = random.nextDouble();
    return u * upper + (1 - u) * lower;
}","public void test00() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution((-675.9794592268), 0.0, 0.0);
    double double0 = uniformRealDistribution0.sample();
    assertEquals((-65.82027761917747), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSupportUpperBound() {
    return upper;
}","public void test01() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution((-675.9794592268), 0.0, 0.0);
    double double0 = uniformRealDistribution0.sample();
    assertEquals(0.0, uniformRealDistribution0.getSupportUpperBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The upper bound of the support is equal to the upper bound parameter
 * of the distribution.
 *
 * @return upper bound of the support
 */"
"public boolean isSupportConnected() {
    return true;
}","public void test12() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertTrue(uniformRealDistribution0.isSupportConnected());
}","/**
 * {@inheritDoc}
 *
 * The support of this distribution is connected.
 *
 * @return {@code true}
 */"
"public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
    /*
         * IMPLEMENTATION NOTES
         * --------------------
         * Where applicable, use is made of the one-sided Chebyshev inequality
         * to bracket the root. This inequality states that
         * P(X - mu >= k * sig) <= 1 / (1 + k^2),
         * mu: mean, sig: standard deviation. Equivalently
         * 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),
         * F(mu + k * sig) >= k^2 / (1 + k^2).
         *
         * For k = sqrt(p / (1 - p)), we find
         * F(mu + k * sig) >= p,
         * and (mu + k * sig) is an upper-bound for the root.
         *
         * Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and
         * P(Y >= -mu + k * sig) <= 1 / (1 + k^2),
         * P(-X >= -mu + k * sig) <= 1 / (1 + k^2),
         * P(X <= mu - k * sig) <= 1 / (1 + k^2),
         * F(mu - k * sig) <= 1 / (1 + k^2).
         *
         * For k = sqrt((1 - p) / p), we find
         * F(mu - k * sig) <= p,
         * and (mu - k * sig) is a lower-bound for the root.
         *
         * In cases where the Chebyshev inequality does not apply, geometric
         * progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket
         * the root.
         */
    if (p < 0.0 || p > 1.0) {
        throw new OutOfRangeException(p, 0, 1);
    }
    double lowerBound = getSupportLowerBound();
    if (p == 0.0) {
        return lowerBound;
    }
    double upperBound = getSupportUpperBound();
    if (p == 1.0) {
        return upperBound;
    }
    final double mu = getNumericalMean();
    final double sig = FastMath.sqrt(getNumericalVariance());
    final boolean chebyshevApplies;
    chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sig) || Double.isNaN(sig));
    if (lowerBound == Double.NEGATIVE_INFINITY) {
        if (chebyshevApplies) {
            lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);
        } else {
            lowerBound = -1.0;
            while (cumulativeProbability(lowerBound) >= p) {
                lowerBound *= 2.0;
            }
        }
    }
    if (upperBound == Double.POSITIVE_INFINITY) {
        if (chebyshevApplies) {
            upperBound = mu + sig * FastMath.sqrt(p / (1. - p));
        } else {
            upperBound = 1.0;
            while (cumulativeProbability(upperBound) < p) {
                upperBound *= 2.0;
            }
        }
    }
    final UnivariateFunction toSolve = new UnivariateFunction() {

        public double value(final double x) {
            return cumulativeProbability(x) - p;
        }
    };
    double x = UnivariateSolverUtils.solve(toSolve, lowerBound, upperBound, getSolverAbsoluteAccuracy());
    if (!isSupportConnected()) {
        /* Test for plateau. */
        final double dx = getSolverAbsoluteAccuracy();
        if (x - dx >= getSupportLowerBound()) {
            double px = cumulativeProbability(x);
            if (cumulativeProbability(x - dx) == px) {
                upperBound = x;
                while (upperBound - lowerBound > dx) {
                    final double midPoint = 0.5 * (lowerBound + upperBound);
                    if (cumulativeProbability(midPoint) < px) {
                        lowerBound = midPoint;
                    } else {
                        upperBound = midPoint;
                    }
                }
                return upperBound;
            }
        }
    }
    return x;
}","public void test13() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertEquals(1.0E-6, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The default implementation returns
 * <ul>
 * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>
 * <li>{@link #getSupportUpperBound()} for {@code p = 1}.</li>
 * </ul>
 */"
"public double getNumericalMean() {
    return 0.5 * (lower + upper);
}","public void test14() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertEquals(0.5, uniformRealDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the mean is
 * {@code 0.5 * (lower + upper)}.
 */"
"public double getSupportUpperBound() {
    return upper;
}","public void test15() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertEquals(1.0, uniformRealDistribution0.getSupportUpperBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The upper bound of the support is equal to the upper bound parameter
 * of the distribution.
 *
 * @return upper bound of the support
 */"
"public double getNumericalVariance() {
    double ul = upper - lower;
    return ul * ul / 12;
}","public void test16() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertEquals(0.08333333333333333, uniformRealDistribution0.getNumericalVariance(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the
 * variance is {@code (upper - lower)^2 / 12}.
 */"
"public double getSupportLowerBound() {
    return lower;
}","public void test17() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.inverseCumulativeProbability(1.0E-6);
    assertEquals(0.0, uniformRealDistribution0.getSupportLowerBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is equal to the lower bound parameter
 * of the distribution.
 *
 * @return lower bound of the support
 */"
"public double getSupportLowerBound() {
    return lower;
}","public void test28() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportUpperBoundInclusive();
    assertEquals(0.0, uniformRealDistribution0.getSupportLowerBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is equal to the lower bound parameter
 * of the distribution.
 *
 * @return lower bound of the support
 */"
"public boolean isSupportUpperBoundInclusive() {
    return false;
}","public void test29() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportUpperBoundInclusive();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getNumericalMean() {
    return 0.5 * (lower + upper);
}","public void test210() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportUpperBoundInclusive();
    assertEquals(0.5, uniformRealDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the mean is
 * {@code 0.5 * (lower + upper)}.
 */"
"public double getNumericalVariance() {
    double ul = upper - lower;
    return ul * ul / 12;
}","public void test311() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportLowerBoundInclusive();
    assertEquals(0.08333333333333333, uniformRealDistribution0.getNumericalVariance(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the
 * variance is {@code (upper - lower)^2 / 12}.
 */"
"public boolean isSupportLowerBoundInclusive() {
    return true;
}","public void test312() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportLowerBoundInclusive();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSupportLowerBound() {
    return lower;
}","public void test313() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    boolean boolean0 = uniformRealDistribution0.isSupportLowerBoundInclusive();
    assertEquals(0.0, uniformRealDistribution0.getSupportLowerBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is equal to the lower bound parameter
 * of the distribution.
 *
 * @return lower bound of the support
 */"
"public UniformRealDistribution(double lower, double upper) throws NumberIsTooLargeException {
    this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
}","public void test414() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = null;
    try {
        uniformRealDistribution0 = new UniformRealDistribution(223.0646342768073, 223.0646342768073);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lower bound (223.065) must be strictly less than upper bound (223.065)
        //
        verifyException(""org.apache.commons.math3.distribution.UniformRealDistribution"", e);
    }
}","/**
 * Create a uniform real distribution using the given lower and upper
 * bounds.
 *
 * @param lower Lower bound of this distribution (inclusive).
 * @param upper Upper bound of this distribution (exclusive).
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */"
"public double getNumericalMean() {
    return 0.5 * (lower + upper);
}","public void test515() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.density((-1442.257006783594));
    assertEquals(0.5, uniformRealDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the mean is
 * {@code 0.5 * (lower + upper)}.
 */"
"public double density(double x) {
    if (x < lower || x > upper) {
        return 0.0;
    }
    return 1 / (upper - lower);
}","public void test516() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.density((-1442.257006783594));
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSupportLowerBound() {
    return lower;
}","public void test517() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.density((-1442.257006783594));
    assertEquals(0.0, uniformRealDistribution0.getSupportLowerBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is equal to the lower bound parameter
 * of the distribution.
 *
 * @return lower bound of the support
 */"
"public double density(double x) {
    if (x < lower || x > upper) {
        return 0.0;
    }
    return 1 / (upper - lower);
}","public void test618() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.density(0.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSupportLowerBound() {
    return lower;
}","public void test619() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution();
    double double0 = uniformRealDistribution0.density(0.0);
    assertEquals(0.0, uniformRealDistribution0.getSupportLowerBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is equal to the lower bound parameter
 * of the distribution.
 *
 * @return lower bound of the support
 */"
"public double density(double x) {
    if (x < lower || x > upper) {
        return 0.0;
    }
    return 1 / (upper - lower);
}","public void test720() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution((-1442.257006783594), 0.08333333333333333, 121.928);
    double double0 = uniformRealDistribution0.density(1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNumericalMean() {
    return 0.5 * (lower + upper);
}","public void test721() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution((-1442.257006783594), 0.08333333333333333, 121.928);
    double double0 = uniformRealDistribution0.density(1.0);
    assertEquals((-721.0868367251304), uniformRealDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the mean is
 * {@code 0.5 * (lower + upper)}.
 */"
"public double getNumericalMean() {
    return 0.5 * (lower + upper);
}","public void test822() throws Throwable {
    UniformRealDistribution uniformRealDistribution0 = new UniformRealDistribution((-675.9794592268), 0.0, 0.0);
    uniformRealDistribution0.probability(2687.229247, 2687.229247);
    assertEquals((-337.9897296134), uniformRealDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For lower bound {@code lower} and upper bound {@code upper}, the mean is
 * {@code 0.5 * (lower + upper)}.
 */"
