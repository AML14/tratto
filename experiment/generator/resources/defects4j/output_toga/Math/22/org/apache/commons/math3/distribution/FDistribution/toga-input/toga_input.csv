focal_method,test_prefix,docstring
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test000() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4.0, 4.0, 0.0);
    assertEquals(4.0, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double sample() {
    return inverseCumulativeProbability(random.nextDouble());
}","public void test001() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4.0, 4.0, 0.0);
    double double0 = fDistribution0.sample();
    assertEquals(4.181308446960345, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The default implementation uses the
 * <a href=""http://en.wikipedia.org/wiki/Inverse_transform_sampling"">
 * inversion method.
 * </a>
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test002() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4.0, 4.0, 0.0);
    double double0 = fDistribution0.sample();
    assertEquals(2.0, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test013() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4670.7025729, 4670.7025729, 4670.7025729);
    double double0 = fDistribution0.probability((-1534.45348030732), (-1534.45348030732));
    assertEquals(4670.7025729, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double probability(double x0, double x1) {
    if (x0 > x1) {
        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1, true);
    }
    return cumulativeProbability(x1) - cumulativeProbability(x0);
}","public void test014() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4670.7025729, 4670.7025729, 4670.7025729);
    double double0 = fDistribution0.probability((-1534.45348030732), (-1534.45348030732));
    assertEquals(0.0, double0, 0.01);
}","/**
 * For a random variable {@code X} whose values are distributed according
 * to this distribution, this method returns {@code P(x0 < X <= x1)}.
 *
 * @param x0 Lower bound (excluded).
 * @param x1 Upper bound (included).
 * @return the probability that a random variable with this distribution
 * takes a value between {@code x0} and {@code x1}, excluding the lower
 * and including the upper endpoint.
 * @throws NumberIsTooLargeException if {@code x0 > x1}.
 *
 * The default implementation uses the identity
 * {@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}
 *
 * @since 3.1
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test015() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4670.7025729, 4670.7025729, 4670.7025729);
    double double0 = fDistribution0.probability((-1534.45348030732), (-1534.45348030732));
    assertEquals(1.0004283845391242, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double density(double x) {
    final double nhalf = numeratorDegreesOfFreedom / 2;
    final double mhalf = denominatorDegreesOfFreedom / 2;
    final double logx = FastMath.log(x);
    final double logn = FastMath.log(numeratorDegreesOfFreedom);
    final double logm = FastMath.log(denominatorDegreesOfFreedom);
    final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);
    return FastMath.exp(nhalf * logn + nhalf * logx - logx + mhalf * logm - nhalf * lognxm - mhalf * lognxm - Beta.logBeta(nhalf, mhalf));
}","public void test026() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2163.44333240904, 8.319947089683576E-278);
    double double0 = fDistribution0.density(1.681278956582695E-9);
    assertEquals(2.4742910916531735E-269, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * @since 2.1
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test037() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.7534012237555307E-252, 1136.7353534, 0.0);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(1.7534012237555307E-252, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"@Override
protected double getSolverAbsoluteAccuracy() {
    return solverAbsoluteAccuracy;
}","public void test038() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.7534012237555307E-252, 1136.7353534, 0.0);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test039() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.7534012237555307E-252, 1136.7353534, 0.0);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(1.0017625255034202, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test0410() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(0.5, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test0411() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(0.5, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"@Override
protected double getSolverAbsoluteAccuracy() {
    return solverAbsoluteAccuracy;
}","public void test0412() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test0513() throws Throwable {
    Well512a well512a0 = new Well512a();
    FDistribution fDistribution0 = new FDistribution(well512a0, 1.6455042362213135, 1.6455042362213135, (-1774.0));
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(1.6455042362213135, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test0514() throws Throwable {
    Well512a well512a0 = new Well512a();
    FDistribution fDistribution0 = new FDistribution(well512a0, 1.6455042362213135, 1.6455042362213135, (-1774.0));
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals(1.6455042362213135, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"@Override
protected double getSolverAbsoluteAccuracy() {
    return solverAbsoluteAccuracy;
}","public void test0515() throws Throwable {
    Well512a well512a0 = new Well512a();
    FDistribution fDistribution0 = new FDistribution(well512a0, 1.6455042362213135, 1.6455042362213135, (-1774.0));
    double double0 = fDistribution0.getSolverAbsoluteAccuracy();
    assertEquals((-1774.0), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNumericalVariance() {
    if (!numericalVarianceIsCalculated) {
        numericalVariance = calculateNumericalVariance();
        numericalVarianceIsCalculated = true;
    }
    return numericalVariance;
}","public void test0616() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(3614.0, 3614.0, 3614.0);
    double double0 = fDistribution0.getNumericalVariance();
    assertEquals(0.0011089537042452693, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * For numerator degrees of freedom parameter {@code a} and denominator
 * degrees of freedom parameter {@code b}, the variance is
 * <ul>
 *  <li>
 *    if {@code b > 4} then
 *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},
 *  </li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double density(double x) {
    final double nhalf = numeratorDegreesOfFreedom / 2;
    final double mhalf = denominatorDegreesOfFreedom / 2;
    final double logx = FastMath.log(x);
    final double logn = FastMath.log(numeratorDegreesOfFreedom);
    final double logm = FastMath.log(denominatorDegreesOfFreedom);
    final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);
    return FastMath.exp(nhalf * logn + nhalf * logx - logx + mhalf * logm - nhalf * lognxm - mhalf * lognxm - Beta.logBeta(nhalf, mhalf));
}","public void test0717() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(3614.0, 3614.0, 3614.0);
    double double0 = fDistribution0.density(3614.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * @since 2.1
 */"
"public double cumulativeProbability(double x) {
    double ret;
    if (x <= 0) {
        ret = 0;
    } else {
        double n = numeratorDegreesOfFreedom;
        double m = denominatorDegreesOfFreedom;
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test0818() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2163.44333240904, 8.319947089683576E-278);
    double double0 = fDistribution0.cumulativeProbability(8.319947089683576E-278);
    assertEquals((-7.038813976123492E-14), double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The implementation of this method is based on
 * <ul>
 *  <li>
 *   <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 *   F-Distribution</a>, equation (4).
 *  </li>
 * </ul>
 */"
"protected double calculateNumericalVariance() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 4) {
        final double numeratorDF = getNumeratorDegreesOfFreedom();
        final double denomDFMinusTwo = denominatorDF - 2;
        return (2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2)) / ((numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)));
    }
    return Double.NaN;
}","public void test0919() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.calculateNumericalVariance();
    assertEquals(1.1713341893901908E15, double0, 0.01);
}","/**
 * used by {@link #getNumericalVariance()}
 *
 * @return the variance of this distribution
 */"
"public double cumulativeProbability(double x) {
    double ret;
    if (x <= 0) {
        ret = 0;
    } else {
        double n = numeratorDegreesOfFreedom;
        double m = denominatorDegreesOfFreedom;
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test1020() throws Throwable {
    Well44497a well44497a0 = new Well44497a(0);
    FDistribution fDistribution0 = new FDistribution(well44497a0, 2602.553, 9.994400500679653E270, 0);
    // Undeclared exception!
    try {
        fDistribution0.cumulativeProbability(2602.553);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: Continued fraction diverged to NaN for value 1
        //
        verifyException(""org.apache.commons.math3.util.ContinuedFraction"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * The implementation of this method is based on
 * <ul>
 *  <li>
 *   <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 *   F-Distribution</a>, equation (4).
 *  </li>
 * </ul>
 */"
"public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {
    this(new Well19937c(), numeratorDegreesOfFreedom, denominatorDegreesOfFreedom, inverseCumAccuracy);
}","public void test1121() throws Throwable {
    FDistribution fDistribution0 = null;
    try {
        fDistribution0 = new FDistribution((-368), (-368), (-368));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom (-368)
        //
        verifyException(""org.apache.commons.math3.distribution.FDistribution"", e);
    }
}","/**
 * Creates an F distribution using the given degrees of freedom
 * and inverse cumulative probability accuracy.
 *
 * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
 * @param inverseCumAccuracy the maximum absolute error in inverse
 * cumulative probability estimates.
 * @throws NotStrictlyPositiveException if
 * {@code numeratorDegreesOfFreedom <= 0} or
 * {@code denominatorDegreesOfFreedom <= 0}.
 * @since 2.1
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1222() throws Throwable {
    int[] intArray0 = new int[9];
    Well512a well512a0 = new Well512a(intArray0);
    FDistribution fDistribution0 = new FDistribution(well512a0, 920, 1.0, 880.9);
    double double0 = fDistribution0.getNumericalMean();
    assertEquals(920.0, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1223() throws Throwable {
    int[] intArray0 = new int[9];
    Well512a well512a0 = new Well512a(intArray0);
    FDistribution fDistribution0 = new FDistribution(well512a0, 920, 1.0, 880.9);
    double double0 = fDistribution0.getNumericalMean();
    assertEquals(1.0, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test1224() throws Throwable {
    int[] intArray0 = new int[9];
    Well512a well512a0 = new Well512a(intArray0);
    FDistribution fDistribution0 = new FDistribution(well512a0, 920, 1.0, 880.9);
    double double0 = fDistribution0.getNumericalMean();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test1325() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.getNumericalMean();
    assertEquals(1.001257822830285, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1326() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.getNumericalMean();
    assertEquals(1.71390848833098E-15, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1427() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability((double) 0L);
    assertEquals(1.0E-9, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1428() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability((double) 0L);
    assertEquals(1.0E-9, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double cumulativeProbability(double x) {
    double ret;
    if (x <= 0) {
        ret = 0;
    } else {
        double n = numeratorDegreesOfFreedom;
        double m = denominatorDegreesOfFreedom;
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test1429() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability((double) 0L);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The implementation of this method is based on
 * <ul>
 *  <li>
 *   <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 *   F-Distribution</a>, equation (4).
 *  </li>
 * </ul>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1530() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability(3.8445667684706366E98);
    assertEquals(1.0E-9, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1531() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability(3.8445667684706366E98);
    assertEquals(1.0E-9, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double cumulativeProbability(double x) {
    double ret;
    if (x <= 0) {
        ret = 0;
    } else {
        double n = numeratorDegreesOfFreedom;
        double m = denominatorDegreesOfFreedom;
        ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
    }
    return ret;
}","public void test1532() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.0E-9, 1.0E-9, 3.8445667684706366E98);
    double double0 = fDistribution0.cumulativeProbability(3.8445667684706366E98);
    assertEquals(1.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The implementation of this method is based on
 * <ul>
 *  <li>
 *   <a href=""http://mathworld.wolfram.com/F-Distribution.html"">
 *   F-Distribution</a>, equation (4).
 *  </li>
 * </ul>
 */"
"public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {
    super(rng);
    if (numeratorDegreesOfFreedom <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM, numeratorDegreesOfFreedom);
    }
    if (denominatorDegreesOfFreedom <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM, denominatorDegreesOfFreedom);
    }
    this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;
    this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;
    solverAbsoluteAccuracy = inverseCumAccuracy;
}","public void test1633() throws Throwable {
    Well512a well512a0 = new Well512a(1446L);
    FDistribution fDistribution0 = null;
    try {
        fDistribution0 = new FDistribution(well512a0, 1446L, 0.0, 0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom (0)
        //
        verifyException(""org.apache.commons.math3.distribution.FDistribution"", e);
    }
}","/**
 * Creates an F distribution.
 *
 * @param rng Random number generator.
 * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
 * @param inverseCumAccuracy the maximum absolute error in inverse
 * cumulative probability estimates.
 * @throws NotStrictlyPositiveException if
 * {@code numeratorDegreesOfFreedom <= 0} or
 * {@code denominatorDegreesOfFreedom <= 0}.
 * @since 3.1
 */"
"public FDistribution(RandomGenerator rng, double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom, double inverseCumAccuracy) throws NotStrictlyPositiveException {
    super(rng);
    if (numeratorDegreesOfFreedom <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM, numeratorDegreesOfFreedom);
    }
    if (denominatorDegreesOfFreedom <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM, denominatorDegreesOfFreedom);
    }
    this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;
    this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;
    solverAbsoluteAccuracy = inverseCumAccuracy;
}","public void test1734() throws Throwable {
    Well44497a well44497a0 = new Well44497a(2030L);
    FDistribution fDistribution0 = null;
    try {
        fDistribution0 = new FDistribution(well44497a0, (-692.1503867), 809.6254254765303, 2030L);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom (-692.15)
        //
        verifyException(""org.apache.commons.math3.distribution.FDistribution"", e);
    }
}","/**
 * Creates an F distribution.
 *
 * @param rng Random number generator.
 * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
 * @param inverseCumAccuracy the maximum absolute error in inverse
 * cumulative probability estimates.
 * @throws NotStrictlyPositiveException if
 * {@code numeratorDegreesOfFreedom <= 0} or
 * {@code denominatorDegreesOfFreedom <= 0}.
 * @since 3.1
 */"
"public boolean isSupportConnected() {
    return true;
}","public void test1835() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    boolean boolean0 = fDistribution0.isSupportConnected();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 *
 * The support of this distribution is connected.
 *
 * @return {@code true}
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1836() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    boolean boolean0 = fDistribution0.isSupportConnected();
    assertEquals(0.5, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1837() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.5, 0.5, Double.POSITIVE_INFINITY);
    boolean boolean0 = fDistribution0.isSupportConnected();
    assertEquals(0.5, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test1938() throws Throwable {
    Well19937a well19937a0 = new Well19937a();
    FDistribution fDistribution0 = new FDistribution(well19937a0, 703.131, 0.03360854089260101, 0.0);
    double double0 = fDistribution0.getSupportUpperBound();
    assertEquals(0.03360854089260101, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getSupportUpperBound() {
    return Double.POSITIVE_INFINITY;
}","public void test1939() throws Throwable {
    Well19937a well19937a0 = new Well19937a();
    FDistribution fDistribution0 = new FDistribution(well19937a0, 703.131, 0.03360854089260101, 0.0);
    double double0 = fDistribution0.getSupportUpperBound();
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The upper bound of the support is always positive infinity
 * no matter the parameters.
 *
 * @return upper bound of the support (always Double.POSITIVE_INFINITY)
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test1940() throws Throwable {
    Well19937a well19937a0 = new Well19937a();
    FDistribution fDistribution0 = new FDistribution(well19937a0, 703.131, 0.03360854089260101, 0.0);
    double double0 = fDistribution0.getSupportUpperBound();
    assertEquals(703.131, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2041() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2163.44333240904, 8.319947089683576E-278);
    double double0 = fDistribution0.getDenominatorDegreesOfFreedom();
    assertEquals(2163.44333240904, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test2042() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2163.44333240904, 8.319947089683576E-278);
    double double0 = fDistribution0.getDenominatorDegreesOfFreedom();
    assertEquals(8.319947089683576E-278, double0, 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2143() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.getSupportLowerBound();
    assertEquals(1.71390848833098E-15, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getSupportLowerBound() {
    return 0;
}","public void test2144() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.getSupportLowerBound();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The lower bound of the support is always 0 no matter the parameters.
 *
 * @return lower bound of the support (always 0)
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test2145() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(1.71390848833098E-15, 1592.049052891426, 3158.098);
    double double0 = fDistribution0.getSupportLowerBound();
    assertEquals(1.001257822830285, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getSupportUpperBound() {
    return Double.POSITIVE_INFINITY;
}","public void test2246() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    assertEquals(Double.POSITIVE_INFINITY, fDistribution0.getSupportUpperBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The upper bound of the support is always positive infinity
 * no matter the parameters.
 *
 * @return upper bound of the support (always Double.POSITIVE_INFINITY)
 */"
"public double getNumericalVariance() {
    if (!numericalVarianceIsCalculated) {
        numericalVariance = calculateNumericalVariance();
        numericalVarianceIsCalculated = true;
    }
    return numericalVariance;
}","public void test2247() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * For numerator degrees of freedom parameter {@code a} and denominator
 * degrees of freedom parameter {@code b}, the variance is
 * <ul>
 *  <li>
 *    if {@code b > 4} then
 *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},
 *  </li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test2248() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    double double1 = fDistribution0.inverseCumulativeProbability(0.17516371060289526);
    assertEquals(0.680370569229126, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
    /*
         * IMPLEMENTATION NOTES
         * --------------------
         * Where applicable, use is made of the one-sided Chebyshev inequality
         * to bracket the root. This inequality states that
         * P(X - mu >= k * sig) <= 1 / (1 + k^2),
         * mu: mean, sig: standard deviation. Equivalently
         * 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),
         * F(mu + k * sig) >= k^2 / (1 + k^2).
         *
         * For k = sqrt(p / (1 - p)), we find
         * F(mu + k * sig) >= p,
         * and (mu + k * sig) is an upper-bound for the root.
         *
         * Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and
         * P(Y >= -mu + k * sig) <= 1 / (1 + k^2),
         * P(-X >= -mu + k * sig) <= 1 / (1 + k^2),
         * P(X <= mu - k * sig) <= 1 / (1 + k^2),
         * F(mu - k * sig) <= 1 / (1 + k^2).
         *
         * For k = sqrt((1 - p) / p), we find
         * F(mu - k * sig) <= p,
         * and (mu - k * sig) is a lower-bound for the root.
         *
         * In cases where the Chebyshev inequality does not apply, geometric
         * progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket
         * the root.
         */
    if (p < 0.0 || p > 1.0) {
        throw new OutOfRangeException(p, 0, 1);
    }
    double lowerBound = getSupportLowerBound();
    if (p == 0.0) {
        return lowerBound;
    }
    double upperBound = getSupportUpperBound();
    if (p == 1.0) {
        return upperBound;
    }
    final double mu = getNumericalMean();
    final double sig = FastMath.sqrt(getNumericalVariance());
    final boolean chebyshevApplies;
    chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sig) || Double.isNaN(sig));
    if (lowerBound == Double.NEGATIVE_INFINITY) {
        if (chebyshevApplies) {
            lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);
        } else {
            lowerBound = -1.0;
            while (cumulativeProbability(lowerBound) >= p) {
                lowerBound *= 2.0;
            }
        }
    }
    if (upperBound == Double.POSITIVE_INFINITY) {
        if (chebyshevApplies) {
            upperBound = mu + sig * FastMath.sqrt(p / (1. - p));
        } else {
            upperBound = 1.0;
            while (cumulativeProbability(upperBound) < p) {
                upperBound *= 2.0;
            }
        }
    }
    final UnivariateFunction toSolve = new UnivariateFunction() {

        public double value(final double x) {
            return cumulativeProbability(x) - p;
        }
    };
    double x = UnivariateSolverUtils.solve(toSolve, lowerBound, upperBound, getSolverAbsoluteAccuracy());
    if (!isSupportConnected()) {
        /* Test for plateau. */
        final double dx = getSolverAbsoluteAccuracy();
        if (x - dx >= getSupportLowerBound()) {
            double px = cumulativeProbability(x);
            if (cumulativeProbability(x - dx) == px) {
                upperBound = x;
                while (upperBound - lowerBound > dx) {
                    final double midPoint = 0.5 * (lowerBound + upperBound);
                    if (cumulativeProbability(midPoint) < px) {
                        lowerBound = midPoint;
                    } else {
                        upperBound = midPoint;
                    }
                }
                return upperBound;
            }
        }
    }
    return x;
}","public void test2249() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    double double1 = fDistribution0.inverseCumulativeProbability(0.17516371060289526);
    assertEquals(0.0, double1, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The default implementation returns
 * <ul>
 * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>
 * <li>{@link #getSupportUpperBound()} for {@code p = 1}.</li>
 * </ul>
 */"
"public boolean isSupportConnected() {
    return true;
}","public void test2250() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    double double1 = fDistribution0.inverseCumulativeProbability(0.17516371060289526);
    assertTrue(fDistribution0.isSupportConnected());
}","/**
 * {@inheritDoc}
 *
 * The support of this distribution is connected.
 *
 * @return {@code true}
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test2251() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    double double0 = fDistribution0.getNumericalVariance();
    double double1 = fDistribution0.inverseCumulativeProbability(0.17516371060289526);
    assertEquals(Double.NaN, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public FDistribution(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom) throws NotStrictlyPositiveException {
    this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
}","public void test2352() throws Throwable {
    FDistribution fDistribution0 = null;
    try {
        fDistribution0 = new FDistribution((-138.06673922534), (-138.06673922534));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // degrees of freedom (-138.067)
        //
        verifyException(""org.apache.commons.math3.distribution.FDistribution"", e);
    }
}","/**
 * Creates an F distribution using the given degrees of freedom.
 *
 * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
 * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
 * @throws NotStrictlyPositiveException if
 * {@code numeratorDegreesOfFreedom <= 0} or
 * {@code denominatorDegreesOfFreedom <= 0}.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2453() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4649.4633058815025, 4649.4633058815025, 4649.4633058815025);
    boolean boolean0 = fDistribution0.isSupportLowerBoundInclusive();
    assertEquals(4649.4633058815025, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test2454() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4649.4633058815025, 4649.4633058815025, 4649.4633058815025);
    boolean boolean0 = fDistribution0.isSupportLowerBoundInclusive();
    assertEquals(1.0004303422896248, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public boolean isSupportLowerBoundInclusive() {
    return true;
}","public void test2455() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(4649.4633058815025, 4649.4633058815025, 4649.4633058815025);
    boolean boolean0 = fDistribution0.isSupportLowerBoundInclusive();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test2556() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    boolean boolean0 = fDistribution0.isSupportUpperBoundInclusive();
    assertEquals(0.680370569229126, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2557() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    boolean boolean0 = fDistribution0.isSupportUpperBoundInclusive();
    assertEquals(0.680370569229126, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public boolean isSupportUpperBoundInclusive() {
    return false;
}","public void test2558() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(0.680370569229126, 0.680370569229126, 414.35759550097157);
    boolean boolean0 = fDistribution0.isSupportUpperBoundInclusive();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSupportUpperBound() {
    return Double.POSITIVE_INFINITY;
}","public void test2659() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    assertEquals(Double.POSITIVE_INFINITY, fDistribution0.getSupportUpperBound(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * The upper bound of the support is always positive infinity
 * no matter the parameters.
 *
 * @return upper bound of the support (always Double.POSITIVE_INFINITY)
 */"
"public double sample() {
    return inverseCumulativeProbability(random.nextDouble());
}","public void test2660() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    assertEquals(10.10235431228486, double0, 0.01);
}","/**
 * {@inheritDoc}
 *
 * The default implementation uses the
 * <a href=""http://en.wikipedia.org/wiki/Inverse_transform_sampling"">
 * inversion method.
 * </a>
 */"
"public double getNumericalMean() {
    final double denominatorDF = getDenominatorDegreesOfFreedom();
    if (denominatorDF > 2) {
        return denominatorDF / (denominatorDF - 2);
    }
    return Double.NaN;
}","public void test2661() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    double double1 = fDistribution0.getNumericalVariance();
    assertEquals(Double.NaN, fDistribution0.getNumericalMean(), 0.01);
}","/**
 * {@inheritDoc}
 *
 * For denominator degrees of freedom parameter {@code b}, the mean is
 * <ul>
 *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumericalVariance() {
    if (!numericalVarianceIsCalculated) {
        numericalVariance = calculateNumericalVariance();
        numericalVarianceIsCalculated = true;
    }
    return numericalVariance;
}","public void test2662() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    double double1 = fDistribution0.getNumericalVariance();
    assertEquals(Double.NaN, double1, 0.01);
}","/**
 * {@inheritDoc}
 *
 * For numerator degrees of freedom parameter {@code a} and denominator
 * degrees of freedom parameter {@code b}, the variance is
 * <ul>
 *  <li>
 *    if {@code b > 4} then
 *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},
 *  </li>
 *  <li>else undefined ({@code Double.NaN}).
 * </ul>
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2663() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    double double1 = fDistribution0.getNumericalVariance();
    assertEquals(2.0, fDistribution0.getNumeratorDegreesOfFreedom(), 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test2664() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    double double1 = fDistribution0.getNumericalVariance();
    assertEquals(2.0, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
"public boolean isSupportConnected() {
    return true;
}","public void test2665() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.sample();
    double double1 = fDistribution0.getNumericalVariance();
    assertTrue(fDistribution0.isSupportConnected());
}","/**
 * {@inheritDoc}
 *
 * The support of this distribution is connected.
 *
 * @return {@code true}
 */"
"public double getNumeratorDegreesOfFreedom() {
    return numeratorDegreesOfFreedom;
}","public void test2766() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.getNumeratorDegreesOfFreedom();
    assertEquals(2.0, double0, 0.01);
}","/**
 * Access the numerator degrees of freedom.
 *
 * @return the numerator degrees of freedom.
 */"
"public double getDenominatorDegreesOfFreedom() {
    return denominatorDegreesOfFreedom;
}","public void test2767() throws Throwable {
    FDistribution fDistribution0 = new FDistribution(2.0, 2.0, 2.0);
    double double0 = fDistribution0.getNumeratorDegreesOfFreedom();
    assertEquals(2.0, fDistribution0.getDenominatorDegreesOfFreedom(), 0.01);
}","/**
 * Access the denominator degrees of freedom.
 *
 * @return the denominator degrees of freedom.
 */"
