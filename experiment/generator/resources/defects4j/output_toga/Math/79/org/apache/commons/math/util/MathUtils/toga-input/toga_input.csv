focal_method,test_prefix,docstring
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test0000() throws Throwable {
    int[] intArray0 = new int[3];
    int int0 = 2618;
    intArray0[0] = 2618;
    int int1 = 2178;
    intArray0[1] = 2178;
    intArray0[2] = 14;
    MathUtils.distance(intArray0, intArray0);
    // Undeclared exception!
    try {
        MathUtils.distanceInf(intArray0, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test0011() throws Throwable {
    MathUtils.binomialCoefficient(4191, 4191);
    MathUtils.factorialDouble(4191);
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = Double.POSITIVE_INFINITY;
    try {
        MathUtils.normalizeArray(doubleArray0, 1457.319362);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Array contains an infinite element, \u221E at index 0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
        }
        return Math.abs(u) + Math.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test0022() throws Throwable {
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = (-3904);
    intArray0[2] = (-2771);
    intArray0[3] = 61;
    MathUtils.distance(intArray0, intArray0);
    MathUtils.lcm((-2771), (-2771));
    Random.setNextRandom(1140);
    MathUtils.mulAndCheck(1L, (long) 61);
    MathUtils.equals(454.63004, (double) (-3904), 61);
    MathUtils.indicator((long) (-2771));
    MathUtils.binomialCoefficientDouble(1120, (-2771));
    MathUtils.subAndCheck((long) 0, 4287L);
    MathUtils.pow(61, 2771);
    MathUtils.sign((byte) 52);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 473063909;
    doubleArray0[1] = (double) 4287L;
    doubleArray0[2] = 6.283185307179586;
    doubleArray0[3] = (double) (byte) 1;
    doubleArray0[4] = (double) 1140;
    doubleArray0[5] = (double) (byte) 1;
    doubleArray0[6] = 1420.9131513;
    doubleArray0[7] = (double) (byte) 1;
    doubleArray0[8] = (double) 1120;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.binomialCoefficientLog(61, (-2771));
    MathUtils.gcd((-422), 1);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test0033() throws Throwable {
    int[] intArray0 = new int[0];
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    int int0 = 0;
    MathUtils.round(3892.7F, 0, 0);
    MathUtils.pow((long) 0, 0);
    MathUtils.sinh((-6077.737308));
    MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.factorial(0);
    MathUtils.gcd(1726, 1726);
    MathUtils.sign(0);
    MathUtils.indicator((byte) 14);
    int[] intArray1 = new int[7];
    intArray1[0] = 0;
    intArray1[1] = 1726;
    intArray1[2] = (-3471);
    intArray1[3] = 0;
    intArray1[4] = 1726;
    intArray1[5] = (int) (byte) 1;
    intArray1[6] = 0;
    // Undeclared exception!
    try {
        MathUtils.distanceInf(intArray1, intArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","public void test0044() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 92;
    byteArray0[1] = (byte) 0;
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    Object object0 = new Object();
    bigInteger0.equals(object0);
    bigInteger0.toByteArray();
    bigInteger0.intValue();
    bigInteger0.flipBit(6);
    MathUtils.pow(bigInteger0, bigInteger0);
    MathUtils.indicator(2139287145);
    MathUtils.equals((double) (byte) 92, 2193.168606);
}","/**
 * Returns true iff both arguments are NaN or neither is NaN and they are
 * equal
 *
 * @param x first value
 * @param y second value
 * @return true if the values are equal or both are NaN
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test0055() throws Throwable {
    MathUtils.indicator(2.2250738585072014E-308);
    MathUtils.indicator(1.1102230246251565E-16);
    MathUtils.sign(1770.7891F);
    MathUtils.sign(1030L);
    MathUtils.pow(3, 993L);
    // Undeclared exception!
    try {
        MathUtils.equals(1.1102230246251565E-16, (-2450.7073), 2146779092);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test0066() throws Throwable {
    double[] doubleArray0 = null;
    // Undeclared exception!
    try {
        MathUtils.normalizeArray((double[]) null, (-2308.0));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test0077() throws Throwable {
    MathUtils.round(1.0, 1159);
    MathUtils.cosh(0.0);
    MathUtils.binomialCoefficient(1159, 1);
    MathUtils.round((-1.0F), 1159);
    MathUtils.binomialCoefficient(1159, 5);
    MathUtils.binomialCoefficient(1, 0);
    MathUtils.pow((-517L), (long) 5);
    MathUtils.pow(5, 851);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test0088() throws Throwable {
    int[] intArray0 = new int[0];
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.round(3892.7F, 0, 0);
    MathUtils.pow((long) 0, 0);
    MathUtils.sinh((-6077.737308));
    MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.factorial(0);
    MathUtils.gcd(1726, 1726);
    MathUtils.sign(0);
    MathUtils.indicator((byte) 14);
    MathUtils.lcm(393, (byte) 1);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) (byte) 14;
    doubleArray0[2] = (-6077.737308);
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    doubleArray0[6] = (double) 1L;
    doubleArray0[7] = (-1276.21716603516);
    MathUtils.distance1(doubleArray0, doubleArray0);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(393, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log(i);
    }
    return logSum;
}","public void test0099() throws Throwable {
    MathUtils.mulAndCheck((-423), (-423));
    MathUtils.lcm(4287, 4287);
    MathUtils.subAndCheck((long) 4287, 121645100408832023L);
    MathUtils.indicator((short) 6);
    MathUtils.indicator(3833.72265635);
    int int0 = 2;
    MathUtils.factorialDouble(2);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 178929;
    doubleArray0[1] = (double) 4287;
    MathUtils.normalizeArray(doubleArray0, (-4.9E-324));
    MathUtils.pow((long) (short) 6, 2);
    MathUtils.mulAndCheck(4287, (int) (short) 6);
    MathUtils.sign(178929);
    MathUtils.compareTo(1.0, (-423), (-121645100408827736L));
    MathUtils.pow((-649), 1);
    MathUtils.indicator((double) 4287);
    int int1 = 399;
    MathUtils.gcd((-649), 399);
    // Undeclared exception!
    MathUtils.factorialLog(178929);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test01010() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (-643.544327393);
    doubleArray0[1] = 828.9892002;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals(828.9892002, Double.NEGATIVE_INFINITY);
    MathUtils.gcd(3, 3);
    double[] doubleArray1 = new double[9];
    doubleArray1[0] = Double.NEGATIVE_INFINITY;
    doubleArray1[1] = Double.NEGATIVE_INFINITY;
    doubleArray1[2] = 828.9892002;
    doubleArray1[3] = 828.9892002;
    doubleArray1[4] = Double.NEGATIVE_INFINITY;
    doubleArray1[5] = (-643.544327393);
    doubleArray1[6] = (double) 3;
    doubleArray1[7] = (double) 3;
    doubleArray1[8] = (double) 3;
    MathUtils.distance1(doubleArray0, doubleArray1);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.indicator(0);
    byte byte0 = (byte) 0;
    MathUtils.indicator((byte) 0);
    MathUtils.log(1, 828.9892002);
    int int0 = (-1819);
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-1819));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1,819
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test01111() throws Throwable {
    int int0 = Integer.MIN_VALUE;
    MathUtils.binomialCoefficient(3237, Integer.MIN_VALUE);
    byte byte0 = (byte) 0;
    MathUtils.indicator((byte) 0);
    MathUtils.sign((byte) 1);
    MathUtils.cosh((-1926.605913337));
    // Undeclared exception!
    try {
        MathUtils.round((-1739.42584287), Integer.MIN_VALUE, Integer.MIN_VALUE);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test01212() throws Throwable {
    MathUtils.binomialCoefficient(983, (-6));
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1L;
    doubleArray0[1] = (double) 983;
    doubleArray0[2] = (double) 983;
    doubleArray0[3] = (double) (-6);
    doubleArray0[4] = (double) (-6);
    doubleArray0[5] = (double) (-6);
    doubleArray0[6] = (double) 983;
    doubleArray0[7] = (double) 1L;
    MathUtils.distanceInf(doubleArray0, doubleArray0);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test01313() throws Throwable {
    MathUtils.sign((byte) (-86));
    MathUtils.binomialCoefficientDouble(808, 804);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) (byte) (-86);
    doubleArray0[1] = (double) 808;
    doubleArray0[2] = (double) 808;
    doubleArray0[3] = (double) (byte) (-86);
    doubleArray0[4] = (double) 804;
    doubleArray0[5] = (double) (byte) (-1);
    doubleArray0[6] = (double) 804;
    doubleArray0[7] = (double) 804;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.subAndCheck(808, 804);
    MathUtils.indicator((short) 9);
    MockRandom mockRandom0 = new MockRandom(804);
    mockRandom0.nextDouble();
    BigInteger bigInteger0 = BigInteger.probablePrime((short) 9, mockRandom0);
    bigInteger0.shortValueExact();
    MathUtils.pow(bigInteger0, 808);
    MathUtils.normalizeArray(doubleArray0, 4);
    MathUtils.indicator(790);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test01414() throws Throwable {
    MathUtils.equals((-1451.0276), 2456.0, (-1451.0276));
    MathUtils.subAndCheck(2L, 106L);
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[1];
    doubleArray1[0] = 2456.0;
    MathUtils.equals(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test01515() throws Throwable {
    int int0 = 2147483624;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(2147483624, 3225);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test01616() throws Throwable {
    int int0 = (-2147483646);
    // Undeclared exception!
    try {
        MathUtils.addAndCheck((-2147483646), (-2147483646));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: add
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test01717() throws Throwable {
    MathUtils.indicator(1479);
    MathUtils.indicator(0);
    MathUtils.gcd(1, (-2293));
    BigInteger bigInteger0 = BigInteger.TEN;
    BigInteger bigInteger1 = BigInteger.ZERO;
    bigInteger1.toString();
    BigInteger bigInteger2 = bigInteger1.mod(bigInteger0);
    bigInteger0.gcd(bigInteger1);
    bigInteger0.multiply(bigInteger2);
    bigInteger0.add(bigInteger1);
    bigInteger0.negate();
    bigInteger0.shiftRight(1);
    bigInteger0.byteValueExact();
    bigInteger0.shortValueExact();
    MathUtils.pow(bigInteger0, bigInteger0);
    bigInteger0.isProbablePrime(647);
    MathUtils.binomialCoefficientLog(17, 0);
    MathUtils.nextAfter(0, 0);
    MathUtils.log((short) 10, 4.9E-324);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test01919() throws Throwable {
    MathUtils.subAndCheck((-826L), 2728L);
    MathUtils.equals((-2153.953025617625), (-2153.953025617625), 139);
    int[] intArray0 = new int[9];
    intArray0[0] = 139;
    intArray0[1] = 139;
    intArray0[2] = 139;
    intArray0[3] = 139;
    intArray0[4] = 139;
    intArray0[5] = 139;
    intArray0[6] = 139;
    intArray0[7] = 139;
    intArray0[8] = 139;
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.pow(3025L, (long) 139);
    MathUtils.hash((double) (-3554L));
    try {
        MathUtils.pow(139, (-1639L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (139^-1,639)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test02020() throws Throwable {
    MathUtils.indicator((byte) 63);
    MathUtils.factorial((byte) 1);
    MathUtils.subAndCheck(1L, 1943L);
    MathUtils.nextAfter((byte) 1, (-1778.349425));
    MathUtils.indicator((-1463L));
    MathUtils.gcd((byte) 1, (byte) 63);
    MathUtils.nextAfter((byte) 1, 1);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","public void test02121() throws Throwable {
    MathUtils.indicator((byte) 26);
    MathUtils.mulAndCheck((long) (byte) 1, (long) (byte) 26);
    MathUtils.equals(0.0, (double) (byte) 1, (int) (byte) 26);
    MathUtils.indicator((byte) 0);
    MathUtils.log((byte) 26, (byte) 26);
    MathUtils.mulAndCheck((int) (byte) 1, (int) (byte) 0);
    MathUtils.equals((double) 26L, 0.0);
}","/**
 * Returns true iff both arguments are NaN or neither is NaN and they are
 * equal
 *
 * @param x first value
 * @param y second value
 * @return true if the values are equal or both are NaN
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test02323() throws Throwable {
    MathUtils.round(1.0, 1159);
    MathUtils.cosh(0.0);
    int int0 = 1;
    MathUtils.binomialCoefficient(1159, 1);
    MathUtils.round((-1.0F), (-311));
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-311), 5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -311, k = 5
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test02424() throws Throwable {
    MathUtils.round(Double.NaN, (-2742));
    MathUtils.mulAndCheck((long) (-2742), (-1718L));
    MathUtils.indicator(Double.NaN);
    MathUtils.log(4710756L, 1327.174);
    MathUtils.hash(Double.NaN);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test02525() throws Throwable {
    MathUtils.log((-1.0), (-1.0));
    MathUtils.subAndCheck((-1335L), 1L);
    MathUtils.lcm((-1), (-1));
    MathUtils.sign((short) (-677));
    BigInteger bigInteger0 = BigInteger.TEN;
    bigInteger0.abs();
    Object object0 = new Object();
    bigInteger0.equals(object0);
    bigInteger0.toString(1623);
    bigInteger0.clearBit(1623);
    MathUtils.pow(bigInteger0, 1);
    MathUtils.hash((-1.0));
    MathUtils.indicator((short) (-2030));
    MathUtils.log(3418.296159571848, (-3438.2159));
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test02626() throws Throwable {
    MathUtils.addAndCheck(2640, 2640);
    MathUtils.pow((long) 5280, (long) 5280);
    MathUtils.pow(0L, 2640);
    MathUtils.equals(0.0, 487.37343307056665, (-2621.877438012606));
    int int0 = 31;
    MathUtils.binomialCoefficientLog(2640, 31);
    MathUtils.log(31, 31);
    MathUtils.indicator((short) 1522);
    MathUtils.pow(1236, 5280);
    MathUtils.round(1252.845186, 0);
    MathUtils.indicator((float) 0L);
    // Undeclared exception!
    try {
        MathUtils.round(0.0, (-369), 1420);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test02727() throws Throwable {
    MathUtils.indicator((-1802.0896F));
    MathUtils.compareTo(1250.241414073, 1250.241414073, 1250.241414073);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = 1250.241414073;
    doubleArray0[2] = (double) (-1.0F);
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = 1250.241414073;
    MathUtils.normalizeArray(doubleArray0, 1250.241414073);
    MathUtils.sign(Double.NaN);
    BigInteger bigInteger0 = BigInteger.ZERO;
    BigInteger bigInteger1 = BigInteger.TEN;
    bigInteger0.add(bigInteger1);
    bigInteger0.remainder(bigInteger1);
    bigInteger0.add(bigInteger1);
    bigInteger0.shortValueExact();
    MathUtils.pow(bigInteger0, 0L);
    MathUtils.sign((byte) 0);
    MathUtils.factorialDouble(61);
    MathUtils.addAndCheck((long) (byte) 0, 0L);
    MathUtils.cosh(5.075802138772222E83);
    MathUtils.indicator((float) (byte) 0);
    MathUtils.round(Double.NEGATIVE_INFINITY, 0, 0);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test02828() throws Throwable {
    MathUtils.round((-1.0F), 20);
    MathUtils.normalizeAngle((-1.0F), (-1001.174039789));
    MathUtils.lcm(20, 1);
    MathUtils.gcd(1, 1);
    MathUtils.addAndCheck(0, 0);
    MathUtils.gcd(1, 0);
    MathUtils.indicator((short) 0);
    MathUtils.indicator((byte) 0);
    int[] intArray0 = new int[8];
    intArray0[0] = 0;
    intArray0[1] = 20;
    intArray0[2] = 1;
    intArray0[3] = (-488);
    intArray0[4] = 1;
    intArray0[5] = 1;
    intArray0[6] = (int) (byte) 1;
    intArray0[7] = (-452);
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.pow((int) (byte) 1, (long) 20);
    MathUtils.sign((float) 1);
    MathUtils.pow(343, 0);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test02929() throws Throwable {
    MathUtils.subAndCheck(2207, 2207);
    MathUtils.indicator((-2455.0F));
    BigInteger bigInteger0 = BigInteger.ONE;
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) (-52);
    byteArray0[1] = (byte) (-127);
    byteArray0[2] = (byte) 72;
    byteArray0[3] = (byte) 0;
    BigInteger bigInteger1 = new BigInteger(byteArray0);
    bigInteger1.flipBit((byte) 0);
    bigInteger0.subtract(bigInteger1);
    MathUtils.pow(bigInteger0, 0L);
    MathUtils.pow(0, 1365L);
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test03030() throws Throwable {
    MathUtils.hash((-2018.9627));
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-9223372036854775808L), (long) 244896937);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test03131() throws Throwable {
    MathUtils.normalizeAngle((-1794.233680471964), (-1794.233680471964));
    MathUtils.log(0.0, (-1794.233680471964));
    MathUtils.lcm((-1), 1);
    MathUtils.round(18.724F, (-1), 1);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (-1794.233680471964);
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = (double) (-1);
    doubleArray0[5] = (double) 18.724F;
    doubleArray0[6] = (double) 1;
    doubleArray0[7] = (-1794.233680471964);
    MathUtils.distance1(doubleArray0, doubleArray0);
    int[] intArray0 = new int[7];
    intArray0[0] = 1;
    intArray0[1] = 1;
    intArray0[2] = (-1);
    intArray0[3] = 1;
    intArray0[4] = (-1);
    intArray0[5] = 1;
    intArray0[6] = 1;
    MathUtils.distance(intArray0, intArray0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    try {
        MathUtils.pow(bigInteger0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test03232() throws Throwable {
    MathUtils.sign(Float.NaN);
    MathUtils.equals((double) Float.NaN, 0.0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) Float.NaN;
    doubleArray0[1] = 0.0;
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.scalb(Float.NaN, Integer.MIN_VALUE);
    MathUtils.sign((byte) 1);
    MathUtils.sign(0.0F);
    int int0 = 0;
    MathUtils.indicator(0);
    try {
        MathUtils.normalizeArray(doubleArray0, Double.NaN);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot normalize to NaN
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test03333() throws Throwable {
    MathUtils.scalb(6.283185307179586, 2073432487);
    MathUtils.lcm(2073432487, 2073432487);
    int int0 = 3410;
    int int1 = (-143);
    MathUtils.lcm(3410, (-143));
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 44330);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test03434() throws Throwable {
    int int0 = 934;
    // Undeclared exception!
    try {
        MathUtils.factorial(934);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // factorial value is too large to fit in a long
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test03535() throws Throwable {
    int int0 = (-2503);
    MathUtils.indicator((-2503));
    BigInteger bigInteger0 = BigInteger.TEN;
    BigInteger bigInteger1 = BigInteger.ONE;
    bigInteger1.divide(bigInteger0);
    bigInteger1.floatValue();
    bigInteger0.modInverse(bigInteger1);
    try {
        MathUtils.pow(bigInteger0, (long) (-2503));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (10^-2,503)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y) || (Math.abs(y - x) <= eps);
}","public void test03636() throws Throwable {
    MathUtils.round(2103.4850674, 12, 0);
    MathUtils.indicator(Double.NEGATIVE_INFINITY);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 12;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = Double.NEGATIVE_INFINITY;
    doubleArray0[3] = Double.NEGATIVE_INFINITY;
    doubleArray0[4] = 2152.347714268;
    doubleArray0[5] = (double) 0;
    double[] doubleArray1 = new double[5];
    doubleArray1[0] = (double) 0;
    doubleArray1[1] = 2103.4850674;
    doubleArray1[2] = 2103.4850674;
    doubleArray1[3] = 2103.4850674;
    doubleArray1[4] = 2103.4850674;
    MathUtils.equals(doubleArray0, doubleArray1);
    MathUtils.equals(2152.347714268, (-747.315824), 3483.606487);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * <p>
 * Two NaNs are considered equals, as are two infinities with same sign.
 * </p>
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test03737() throws Throwable {
    MathUtils.nextAfter(2760.41998, 2760.41998);
    MathUtils.indicator(200);
    int int0 = 16;
    int int1 = 1;
    MathUtils.mulAndCheck(16, 1);
    MathUtils.mulAndCheck(16, 0);
    double[] doubleArray0 = new double[0];
    MathUtils.hash(doubleArray0);
    // Undeclared exception!
    try {
        MathUtils.factorial(200);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // factorial value is too large to fit in a long
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test03838() throws Throwable {
    MathUtils.gcd(0, 0);
    MathUtils.sign(0.0F);
    int[] intArray0 = new int[0];
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.pow(0, 0);
    MathUtils.sign(0.0);
    MathUtils.scalb((-57.57499059), 1);
    MathUtils.addAndCheck((long) 0, 0L);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 0L;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = (-115.14998118);
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = 0.0;
    MathUtils.normalizeArray(doubleArray0, 0);
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test03939() throws Throwable {
    double[] doubleArray0 = null;
    MathUtils.hash((double[]) null);
    MathUtils.log(0, 0);
    int int0 = (-2076);
    // Undeclared exception!
    try {
        MathUtils.equals(0.0, 0.0, (-2076));
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test04040() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 815.7295178732;
    doubleArray0[1] = 2073.3644789007762;
    doubleArray0[2] = Double.NEGATIVE_INFINITY;
    doubleArray0[3] = (-237.7317364645);
    doubleArray0[4] = (-1111.5573821302069);
    doubleArray0[5] = 4.9E-324;
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.indicator((byte) 0);
    MathUtils.indicator((byte) (-109));
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test04141() throws Throwable {
    MathUtils.gcd(0, 2178);
    int[] intArray0 = new int[2];
    intArray0[0] = 2178;
    intArray0[1] = 2178;
    int[] intArray1 = new int[7];
    intArray1[0] = (-2314);
    intArray1[1] = 2178;
    intArray1[2] = 2178;
    intArray1[3] = 2178;
    intArray1[4] = (-2717);
    intArray1[5] = 0;
    intArray1[6] = (-44);
    MathUtils.distance1(intArray0, intArray1);
    MathUtils.sign((byte) 0);
    MathUtils.indicator((short) (byte) 0);
    MathUtils.sign((long) 0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04242() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 1.0;
    doubleArray0[1] = 2412.7751;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = (-4.9E-324);
    double[] doubleArray1 = new double[3];
    doubleArray1[0] = (-4.9E-324);
    doubleArray1[1] = 0.0;
    doubleArray1[2] = 1.0;
    // Undeclared exception!
    try {
        MathUtils.distance1(doubleArray0, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 3
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test04343() throws Throwable {
    MathUtils.sign(1234.98F);
    MathUtils.lcm(1260, 1260);
    MathUtils.pow(1260, 0);
    MathUtils.indicator(3015);
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.sign(0.0F);
    MathUtils.indicator(1390);
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.longValueExact();
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, bigInteger0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04444() throws Throwable {
    MathUtils.factorialDouble(0);
    MathUtils.sign((-1697.76));
    MathUtils.factorialDouble(0);
    MathUtils.sign((-3545L));
    MathUtils.sign((-1017));
    MathUtils.round((-22.0F), (-1017));
    int[] intArray0 = new int[7];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1017);
    intArray0[3] = 0;
    intArray0[4] = 15;
    intArray0[5] = (-1017);
    intArray0[6] = 0;
    MathUtils.distance1(intArray0, intArray0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04545() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[0] = 0;
    int int0 = 0;
    intArray0[1] = 0;
    intArray0[2] = 4194304;
    intArray0[3] = (-2008);
    intArray0[4] = 196;
    MathUtils.distanceInf(intArray0, intArray0);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) (-2008);
    doubleArray0[1] = (double) (-2008);
    doubleArray0[2] = (double) 196;
    // Undeclared exception!
    try {
        MathUtils.distance1(doubleArray0, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04646() throws Throwable {
    MathUtils.log(482.341617, 482.341617);
    MathUtils.subAndCheck(2838L, (-3011L));
    int[] intArray0 = new int[5];
    intArray0[0] = (-430);
    intArray0[1] = 0;
    intArray0[2] = (-2170);
    intArray0[3] = 0;
    intArray0[4] = (-2456);
    MathUtils.distance1(intArray0, intArray0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test04747() throws Throwable {
    MathUtils.compareTo(6.283185307179586, 6.283185307179586, 6.283185307179586);
    BigInteger bigInteger0 = BigInteger.ZERO;
    BigInteger bigInteger1 = BigInteger.ONE;
    bigInteger1.setBit(0);
    bigInteger0.andNot(bigInteger1);
    BigInteger bigInteger2 = BigInteger.ZERO;
    bigInteger0.toByteArray();
    bigInteger2.intValueExact();
    bigInteger0.or(bigInteger2);
    MathUtils.pow(bigInteger0, bigInteger0);
    MathUtils.addAndCheck((-4615L), (long) 0);
    MathUtils.subAndCheck(0L, 0L);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y) || (Math.abs(y - x) <= eps);
}","public void test04848() throws Throwable {
    MathUtils.log(1537.936217, 1537.936217);
    MathUtils.indicator(1.0);
    MathUtils.sign((-3476.95F));
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1537.936217;
    MathUtils.normalizeArray(doubleArray0, 0.0);
    MathUtils.addAndCheck(18, 18);
    MathUtils.factorial(18);
    MathUtils.factorialDouble(36);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigInteger bigInteger1 = BigInteger.TEN;
    bigInteger0.andNot(bigInteger1);
    BigInteger bigInteger2 = bigInteger0.andNot(bigInteger1);
    BigInteger bigInteger3 = MathUtils.pow(bigInteger0, 61L);
    MockRandom mockRandom0 = new MockRandom();
    BigInteger bigInteger4 = new BigInteger(18, (-429), mockRandom0);
    bigInteger3.or(bigInteger4);
    bigInteger0.compareTo(bigInteger1);
    bigInteger3.subtract(bigInteger0);
    bigInteger3.xor(bigInteger2);
    MathUtils.pow(bigInteger3, 1143);
    int[] intArray0 = new int[0];
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.pow(0, 1765);
    MathUtils.binomialCoefficient(0, (-790));
    MathUtils.equals(0.0, (double) 61L, 1.0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * <p>
 * Two NaNs are considered equals, as are two infinities with same sign.
 * </p>
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04949() throws Throwable {
    MathUtils.binomialCoefficient(4191, 4191);
    BigInteger bigInteger0 = BigInteger.ONE;
    MathUtils.pow(bigInteger0, (long) 4191);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 4191;
    doubleArray0[1] = (double) 1L;
    MathUtils.distance1(doubleArray0, doubleArray0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test05050() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) (-75);
    byteArray0[1] = (byte) 17;
    byteArray0[2] = (byte) 12;
    byteArray0[3] = (byte) (-83);
    byteArray0[4] = (byte) (-1);
    byteArray0[5] = (byte) (-1);
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    try {
        MathUtils.pow(bigInteger0, bigInteger0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (-82,390,144,909,313^-82,390,144,909,313)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test05151() throws Throwable {
    MathUtils.indicator(0.0F);
    MathUtils.normalizeAngle(1.0F, 0.0);
    MathUtils.round(1.0, 1640);
    MathUtils.log(3369.446044, 1.0);
    MathUtils.factorialDouble(0);
    MathUtils.subAndCheck((long) 1640, (long) 1640);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}","public void test05252() throws Throwable {
    int[] intArray0 = new int[7];
    intArray0[0] = 0;
    intArray0[1] = 4095;
    intArray0[2] = (-94);
    intArray0[3] = 0;
    intArray0[4] = 0;
    intArray0[5] = 1280;
    intArray0[6] = (-1685);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.round((double) 0, 0);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.round((-528.18268876409), (-2957), 0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) (-1685);
    doubleArray0[1] = (double) (-94);
    MathUtils.normalizeArray(doubleArray0, 1280);
    MathUtils.factorialDouble(1280);
    MathUtils.distance(doubleArray0, doubleArray0);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test05353() throws Throwable {
    MathUtils.compareTo(2.0, 2.0, 2.0);
    MathUtils.indicator((short) (-496));
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) (short) (-1);
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = 2.0;
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    MathUtils.distance1(doubleArray0, doubleArray0);
    MathUtils.nextAfter(0, 2.0);
    MathUtils.equals(472.3074991661, 1077.513167, (-1.0));
    // Undeclared exception!
    try {
        MathUtils.equals(2393.71068944, 1.0, 0);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test05454() throws Throwable {
    MathUtils.compareTo(0.0, 0.0, 0.0);
    byte byte0 = (byte) (-90);
    MathUtils.indicator((byte) (-90));
    MathUtils.factorialDouble(1433);
    MathUtils.mulAndCheck((int) (byte) (-90), 15);
    try {
        MathUtils.pow((-1), (-1350));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (-1^-1,350)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test05555() throws Throwable {
    MathUtils.indicator(3535.7);
    try {
        MathUtils.pow(1659, (-2434));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1,659^-2,434)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test05656() throws Throwable {
    MathUtils.equals(281.79584528882276, 281.79584528882276);
    MathUtils.pow(2672, 367);
    MathUtils.sign((short) (-1847));
    int[] intArray0 = new int[1];
    intArray0[0] = 1303;
    int[] intArray1 = new int[4];
    intArray1[0] = 1303;
    intArray1[1] = 0;
    intArray1[2] = 0;
    intArray1[3] = 1303;
    MathUtils.distance1(intArray0, intArray1);
    MathUtils.indicator(Float.NaN);
    MathUtils.equals((double) 1303, (-767.435), 1303);
    MathUtils.sign(653);
    MathUtils.sign((byte) (-95));
    double[] doubleArray0 = new double[0];
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    MathUtils.indicator((byte) (-7));
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log(i);
    }
    return logSum;
}","public void test05757() throws Throwable {
    int int0 = 132;
    MathUtils.lcm(132, 132);
    MathUtils.hash(3541.11136656);
    MathUtils.nextAfter(0.0, 0.0);
    MathUtils.pow(1168244762, (long) 1168244762);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog(0, 132);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = 0, k = 132
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test05858() throws Throwable {
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.pow((long) 0, 4194304);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test05959() throws Throwable {
    int int0 = (-823);
    int int1 = 349;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-823), 349);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -823, k = 349
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test06060() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 10.0;
    MathUtils.equals(doubleArray0, doubleArray0);
    int int0 = 0;
    MathUtils.round(1829.5243766, 0);
    int int1 = 0;
    try {
        MathUtils.pow(0, (-1145L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1,145)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test06161() throws Throwable {
    int int0 = 25;
    MathUtils.pow(25, 9);
    int int1 = 0;
    MathUtils.subAndCheck(0, 766306777);
    MathUtils.equals(776.957302461, (-2857.39), 689.267357643664);
    MathUtils.log((-766306777), 0.0);
    MathUtils.sign(0.0);
    MathUtils.indicator((float) (-766306777));
    try {
        MathUtils.pow((long) 9, (-1L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (9^-1)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test06262() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.distanceInf((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int pow(final int k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test06363() throws Throwable {
    short short0 = (short) 0;
    MathUtils.indicator((short) 0);
    try {
        MathUtils.pow((int) (short) 0, (-1102L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1,102)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise an int to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test06464() throws Throwable {
    int int0 = 1608;
    MathUtils.pow(1608, (long) 1608);
    try {
        MathUtils.pow((long) 1608, (-1L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1,608^-1)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int compareTo(double x, double y, double eps) {
    if (equals(x, y, eps)) {
        return 0;
    } else if (x < y) {
        return -1;
    }
    return 1;
}","public void test06565() throws Throwable {
    MathUtils.sign(9);
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (double) 9;
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.pow(1, 1);
    MathUtils.pow((-1530), (long) 1);
    MathUtils.indicator(2241);
    MathUtils.hash(0.0);
    MathUtils.mulAndCheck((long) 1, (long) (-1530));
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.negate();
    BigInteger.valueOf((-1530L));
    MathUtils.pow(bigInteger0, bigInteger0);
    MathUtils.compareTo((-1530), 1.0, (-1530));
}","/**
 * Compares two numbers given some amount of allowed error.
 *
 * @param x the first number
 * @param y the second number
 * @param eps the amount of error to allow when checking for equality
 * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>
 *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y) || (Math.abs(y - x) <= eps);
}","public void test06666() throws Throwable {
    MathUtils.normalizeAngle((-4782.42893), (-4782.42893));
    MathUtils.indicator((byte) (-1));
    MathUtils.log((byte) (-1), 1.0);
    MathUtils.addAndCheck((int) (byte) (-1), (int) (byte) (-1));
    MathUtils.equals((-4782.42893), 0.0, 0.0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * <p>
 * Two NaNs are considered equals, as are two infinities with same sign.
 * </p>
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test06767() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 1.0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 2410.01633741;
    MathUtils.normalizeArray(doubleArray0, 2410.01633741);
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test06868() throws Throwable {
    int int0 = 6;
    MathUtils.binomialCoefficientDouble(6, 6);
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 157);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test06969() throws Throwable {
    MathUtils.round(0.0F, 0, 0);
    MathUtils.hash((double) 0);
    MathUtils.mulAndCheck((long) 0, 1375L);
    MathUtils.indicator((double) 0);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (-497.4288227);
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 1375L;
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    int[] intArray0 = new int[9];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = 0;
    intArray0[3] = 0;
    intArray0[4] = 0;
    intArray0[5] = 0;
    intArray0[6] = 0;
    intArray0[7] = 0;
    intArray0[8] = 0;
    int[] intArray1 = new int[1];
    intArray1[0] = 0;
    // Undeclared exception!
    try {
        MathUtils.distance1(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test07070() throws Throwable {
    MathUtils.binomialCoefficientDouble(929, 20);
    MathUtils.sign(929);
    MathUtils.pow(1, 1L);
    MathUtils.equals((double) 1L, (double) 1);
    int[] intArray0 = new int[0];
    MathUtils.distance(intArray0, intArray0);
    MathUtils.indicator((float) 929);
    MathUtils.gcd((-998), 61);
    MathUtils.round((-2369.37201), 4194304);
    MathUtils.round(118.566F, 0);
    MathUtils.mulAndCheck(4194304, 1);
    MathUtils.compareTo(1, 4194304, 0.0);
    MathUtils.sign((long) (-998));
    MathUtils.indicator((float) 1);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.factorial(0);
    BigInteger bigInteger0 = BigInteger.ONE;
    MathUtils.pow(bigInteger0, 0);
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test07171() throws Throwable {
    MathUtils.mulAndCheck((-1), 3209);
    MathUtils.sign(2736.48F);
    MathUtils.sign(2026L);
    MathUtils.sign((short) 3565);
    MathUtils.indicator((-1650L));
    MathUtils.subAndCheck(0L, 79L);
    int[] intArray0 = new int[8];
    intArray0[0] = (int) (short) 3565;
    intArray0[1] = 3209;
    intArray0[2] = (int) (short) 1;
    intArray0[3] = 3209;
    intArray0[4] = (int) (short) 3565;
    intArray0[5] = (int) (short) 1;
    intArray0[6] = 3209;
    intArray0[7] = (int) (short) 1;
    MathUtils.distance(intArray0, intArray0);
    MathUtils.addAndCheck(361L, (long) 3209);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log(i);
    }
    return logSum;
}","public void test07272() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    MathUtils.equals(0.0, 0.0);
    MathUtils.cosh((-293.882628828));
    MathUtils.compareTo((-293.882628828), 152.86311, 2.1407898231843912E127);
    int int0 = 0;
    MathUtils.factorialDouble(0);
    MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.sinh(0.0);
    MathUtils.sign(0);
    MathUtils.subAndCheck((long) 0, (long) 0);
    MathUtils.indicator((short) (-1383));
    MathUtils.sign(0.0F);
    MathUtils.equals(doubleArray0, doubleArray0);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-1124), (-1854));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k), got n = -1,124
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double distance(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}","public void test07373() throws Throwable {
    int[] intArray0 = new int[4];
    intArray0[0] = (-1748);
    intArray0[1] = (-1);
    intArray0[2] = 0;
    intArray0[3] = 91;
    MathUtils.distance(intArray0, intArray0);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test07474() throws Throwable {
    MathUtils.subAndCheck(0L, 0L);
    MathUtils.binomialCoefficientDouble(5072, (-2041));
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test07575() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathUtils.hash(doubleArray0);
    MathUtils.cosh(2864.62672122);
    int[] intArray0 = new int[2];
    intArray0[0] = 1;
    intArray0[1] = 1;
    MathUtils.distanceInf(intArray0, intArray0);
    double double0 = (-2236.52487723688);
    int int0 = (-67);
    // Undeclared exception!
    try {
        MathUtils.round((-2236.52487723688), (-67), (-2790));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test07676() throws Throwable {
    int int0 = 0;
    MathUtils.factorialDouble(0);
    int[] intArray0 = null;
    // Undeclared exception!
    try {
        MathUtils.distance1((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test07777() throws Throwable {
    MathUtils.indicator((-1406.7503837666843));
    MathUtils.equals(0.0, 0.0, 3.141592653589793);
    MathUtils.sign(1L);
    MathUtils.sign((short) 14);
    MathUtils.factorialDouble((short) 14);
    MathUtils.gcd(1049, (short) 1);
    MathUtils.sign((short) 47);
    MathUtils.sign((double) (short) 1);
    MathUtils.compareTo(0.0, (short) 1, (-1406.7503837666843));
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) (short) 1;
    doubleArray0[1] = (double) (-1);
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    MathUtils.mulAndCheck((long) (short) 14, (long) 1049);
    MathUtils.equals((double) 14686L, (double) (short) 47);
    MathUtils.distance1(doubleArray0, doubleArray0);
    MathUtils.binomialCoefficientLog((short) 14, (short) 1);
    MathUtils.pow((long) (short) 1, 2224);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test07878() throws Throwable {
    MathUtils.pow((-1483L), 2723L);
    MathUtils.indicator(1.0);
    MathUtils.indicator(0.0F);
    MathUtils.addAndCheck(0L, 2723L);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test07979() throws Throwable {
    MathUtils.lcm((-1), (-1));
    MathUtils.binomialCoefficient(3005, 0);
    MathUtils.indicator(0L);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1;
    doubleArray0[1] = (double) 1L;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 3005;
    doubleArray0[4] = (double) 1L;
    doubleArray0[5] = (double) 1;
    doubleArray0[6] = (double) 0;
    doubleArray0[7] = (double) 1L;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.pow(3005, 1L);
    MathUtils.binomialCoefficientLog(1, (-1));
    // Undeclared exception!
    try {
        MathUtils.round((float) 3005, (-1), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // invalid rounding method -1, valid methods: ROUND_CEILING (2), ROUND_DOWN (1), ROUND_FLOOR (3), ROUND_HALF_DOWN (5), ROUND_HALF_EVEN (6), ROUND_HALF_UP (4), ROUND_UNNECESSARY (7), ROUND_UP (0)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log(i);
    }
    return logSum;
}","public void test08080() throws Throwable {
    MathUtils.lcm(1503, 0);
    MathUtils.indicator((byte) 95);
    MathUtils.binomialCoefficientLog(1503, (-141));
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test08181() throws Throwable {
    MathUtils.round(599.0209968245006, (-1902), 0);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = 599.0209968245006;
    doubleArray0[1] = 599.0209968245006;
    doubleArray0[2] = (double) (-1902);
    doubleArray0[3] = 599.0209968245006;
    doubleArray0[4] = Double.POSITIVE_INFINITY;
    doubleArray0[5] = (double) (-1902);
    doubleArray0[6] = Double.POSITIVE_INFINITY;
    doubleArray0[7] = (double) 0;
    try {
        MathUtils.normalizeArray(doubleArray0, Double.POSITIVE_INFINITY);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot normalize to an infinite value
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test08282() throws Throwable {
    MathUtils.factorialDouble(0);
    MathUtils.sign((float) 0);
    MathUtils.compareTo(1.0, 296.6060610270463, (-313.58685));
    MathUtils.sign((-1));
    MathUtils.factorialLog(0);
    MathUtils.pow(1214, (long) 0);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (-313.58685);
    doubleArray0[1] = 296.6060610270463;
    doubleArray0[2] = (double) (-1);
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) (-1);
    doubleArray0[5] = 0.0;
    doubleArray0[6] = 1.0;
    doubleArray0[7] = (-2840.252126363);
    MathUtils.normalizeArray(doubleArray0, (-1.0));
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test08383() throws Throwable {
    MathUtils.subAndCheck((-908), (-908));
    byte byte0 = (byte) 0;
    MathUtils.sign((byte) 0);
    MathUtils.normalizeAngle((-1.0), (-2013.0));
    MathUtils.sign((int) (byte) 0);
    int int0 = 0;
    MathUtils.round(0.0, 7, 0);
    MathUtils.subAndCheck(0, (-13));
    MathUtils.addAndCheck(0, 5159);
    MathUtils.nextAfter((byte) 0, (-1.0));
    // Undeclared exception!
    try {
        MathUtils.equals((-1.0), (-4.9E-324), (-2531));
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test08484() throws Throwable {
    MathUtils.binomialCoefficientLog(119, 0);
    MathUtils.sign((byte) 0);
    MathUtils.indicator((-1746L));
    MathUtils.equals(0.5, 0.0, 0.0);
    MathUtils.binomialCoefficient(0, 0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test08585() throws Throwable {
    MathUtils.cosh(0.0);
    MathUtils.indicator((byte) (-119));
    MathUtils.sign(0);
    MathUtils.equals((-8.1941), (double) (byte) (-119));
    MathUtils.sign((byte) (-119));
    MathUtils.nextAfter(0.0, (byte) (-119));
    MathUtils.indicator((double) (byte) (-1));
    MathUtils.mulAndCheck((-1L), (long) (byte) (-1));
    MathUtils.mulAndCheck(0L, 0L);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test08686() throws Throwable {
    MathUtils.subAndCheck(1, 1695);
    MathUtils.scalb((-3638.3242832139), (-1694));
    double[] doubleArray0 = new double[4];
    doubleArray0[1] = (-3638.3242832139);
    doubleArray0[2] = (double) (-1694);
    doubleArray0[3] = (double) (-1694);
    MathUtils.hash(doubleArray0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test08787() throws Throwable {
    MathUtils.sign(0.0);
    MathUtils.normalizeAngle(0.0, 0.0);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    doubleArray0[6] = 0.0;
    doubleArray0[7] = 0.0;
    doubleArray0[8] = 0.0;
    MathUtils.distance1(doubleArray0, doubleArray0);
    MathUtils.normalizeAngle(2883.06, 3276.25503479);
    MathUtils.equals(886.93842, 0.0, 20);
    MathUtils.pow(603L, 0);
    // Undeclared exception!
    try {
        MathUtils.equals((-90.127840696958), 0.0, (-1370));
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test08888() throws Throwable {
    MathUtils.sign(0.0);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 2.0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.binomialCoefficient(0, 0);
    MathUtils.log(1.0, 3316.384);
    MathUtils.mulAndCheck(715L, 1L);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test08989() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (-4049.55459018);
    doubleArray0[1] = (-1952.7);
    double[] doubleArray1 = new double[6];
    doubleArray1[0] = 0.0;
    doubleArray1[1] = (-1952.7);
    doubleArray1[2] = (-1952.7);
    doubleArray1[3] = (-1952.7);
    doubleArray1[4] = (-1952.7);
    doubleArray1[5] = (-1952.7);
    MathUtils.distanceInf(doubleArray0, doubleArray1);
    MathUtils.round(0.0F, 0);
    MathUtils.equals(doubleArray1, doubleArray1);
    MathUtils.normalizeAngle((-763.86184399), 0.0);
    MathUtils.indicator((long) 0);
    MathUtils.cosh((-1952.7));
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-955));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -955
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}","public void test09090() throws Throwable {
    MathUtils.mulAndCheck(0, 0);
    float float0 = 1270.0746F;
    MathUtils.indicator(1270.0746F);
    MathUtils.indicator((double) 0);
    short short0 = (short) (-1);
    MathUtils.sign((short) (-1));
    MathUtils.sinh(0);
    double[] doubleArray0 = null;
    // Undeclared exception!
    try {
        MathUtils.distance((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static boolean equals(double x, double y, int maxUlps) {
    // Check that ""maxUlps"" is non-negative and small enough so that the
    // default NAN won't compare as equal to anything.
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    return Math.abs(xInt - yInt) <= maxUlps;
}","public void test09191() throws Throwable {
    int int0 = (-202);
    MathUtils.round(0.0F, (-202));
    MathUtils.round((double) Float.NaN, 480);
    // Undeclared exception!
    try {
        MathUtils.equals((double) 480, (double) (-202), (-202));
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are less than {@code maxUlps} floating
 * point values between {@code x} and {@code y}
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test09292() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    BigInteger bigInteger1 = BigInteger.ONE;
    bigInteger0.xor(bigInteger1);
    MathUtils.pow(bigInteger0, bigInteger0);
    int int0 = (-1);
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log(i);
    }
    return logSum;
}","public void test09393() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorialLog((-1193));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1,193
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test09494() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 771L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test09595() throws Throwable {
    MathUtils.scalb(0.0, 662);
    MathUtils.sign((short) (-1));
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-119);
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    BigInteger bigInteger1 = new BigInteger(byteArray0);
    bigInteger0.and(bigInteger1);
    bigInteger0.toString((int) (byte) 0);
    MathUtils.pow(bigInteger0, (int) (byte) 0);
    // Undeclared exception!
    try {
        MathUtils.factorial((-1391));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -1,391
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test09696() throws Throwable {
    MathUtils.sinh(2012.178);
    int int0 = (-2602);
    // Undeclared exception!
    try {
        MathUtils.round(2012.178, (-2602), (-2602));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test09797() throws Throwable {
    MathUtils.pow(805, 1114L);
    MathUtils.equals(3855.0, (double) 855098873);
    MathUtils.indicator((byte) 20);
    MathUtils.sign((short) (-998));
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test09898() throws Throwable {
    MathUtils.subAndCheck(0, 0);
    MathUtils.mulAndCheck((-1L), (long) 0);
    int[] intArray0 = new int[1];
    intArray0[0] = 0;
    MathUtils.distanceInf(intArray0, intArray0);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) (-1L);
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 0;
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = (double) 0L;
    doubleArray1[1] = (double) 0;
    // Undeclared exception!
    try {
        MathUtils.distanceInf(doubleArray0, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test09999() throws Throwable {
    MathUtils.subAndCheck(1, 1);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test100100() throws Throwable {
    MathUtils.mulAndCheck(0, 0);
    MathUtils.mulAndCheck(0, 0);
    MathUtils.mulAndCheck((long) 0, (-923L));
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (double) 0L;
    MathUtils.distanceInf(doubleArray0, doubleArray0);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test101101() throws Throwable {
    MathUtils.mulAndCheck((-1094L), 228L);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test102102() throws Throwable {
    int int0 = 0;
    MathUtils.pow(0, 0);
    try {
        MathUtils.pow((long) 0, (-1823));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1,823)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test103103() throws Throwable {
    MathUtils.sign(0L);
    MathUtils.nextAfter(2.2250738585072014E-308, 0L);
    MathUtils.log(1866.718406, 1866.718406);
    MathUtils.gcd((-1049), 0);
    MathUtils.binomialCoefficientDouble(1049, 0);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble(0, 1654);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = 0, k = 1,654
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
        }
        return Math.abs(u) + Math.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test104104() throws Throwable {
    MathUtils.gcd((-94), 0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int pow(final int k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    int result = 1;
    int k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test105105() throws Throwable {
    MathUtils.sign(Float.NaN);
    MathUtils.pow(17, 0);
}","/**
 * Raise an int to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test106106() throws Throwable {
    long long0 = (-1L);
    MathUtils.sign((-1L));
    double[] doubleArray0 = new double[0];
    try {
        MathUtils.normalizeArray(doubleArray0, (-1L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Array sums to zero
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static double distance(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}","public void test107107() throws Throwable {
    MathUtils.sign(3579L);
    short short0 = (short) 1;
    MathUtils.indicator((short) 1);
    MathUtils.sinh(0.0);
    double double0 = 0.0;
    MathUtils.equals(0.0, 0.0, 1.0);
    MathUtils.subAndCheck(1L, (long) (short) 1);
    MathUtils.sinh(1557.348148513444);
    MathUtils.nextAfter(0.0, 0L);
    MathUtils.pow((long) (short) 1, 3579L);
    int[] intArray0 = null;
    // Undeclared exception!
    try {
        MathUtils.distance((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw new ArithmeticException(""overflow: lcm is 2^31"");
    }
    return lcm;
}","public void test108108() throws Throwable {
    MathUtils.factorialDouble(2021);
    int int0 = (-189);
    int int1 = Integer.MIN_VALUE;
    // Undeclared exception!
    try {
        MathUtils.lcm((-189), Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test109109() throws Throwable {
    MathUtils.indicator((short) 2125);
    MathUtils.equals((double) (short) 2125, (double) (short) 2125, 0.0);
    short short0 = (short) 0;
    MathUtils.sign((short) 0);
    int int0 = Integer.MIN_VALUE;
    try {
        MathUtils.pow((long) (short) 1, Integer.MIN_VALUE);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1^-2,147,483,648)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static boolean equals(double x, double y, double eps) {
    return equals(x, y) || (Math.abs(y - x) <= eps);
}","public void test110110() throws Throwable {
    MathUtils.sign((short) 0);
    BigInteger bigInteger0 = BigInteger.TEN;
    MathUtils.pow(bigInteger0, (int) (short) 0);
    MathUtils.mulAndCheck((long) (short) 0, 0L);
    MathUtils.equals((double) (short) 0, (double) (short) 0, (-3193.0));
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 * <p>
 * Two NaNs are considered equals, as are two infinities with same sign.
 * </p>
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log(i);
    }
    return logSum;
}","public void test111111() throws Throwable {
    MathUtils.nextAfter(2655.65282576038, 72.0);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 2655.65282576038;
    doubleArray0[1] = 2655.65282576038;
    doubleArray0[2] = 72.0;
    doubleArray0[3] = 2655.65282576038;
    MathUtils.equals(doubleArray0, (double[]) null);
    MathUtils.factorialLog(0);
    MathUtils.sign((byte) 89);
    MathUtils.sinh(2655.65282576038);
    MathUtils.sign(2335);
    BigInteger bigInteger0 = BigInteger.ZERO;
    bigInteger0.floatValue();
    bigInteger0.toByteArray();
    BigInteger bigInteger1 = BigInteger.TEN;
    bigInteger0.subtract(bigInteger1);
    bigInteger0.longValue();
    bigInteger0.add(bigInteger1);
    Object object0 = new Object();
    bigInteger0.equals(object0);
    Object object1 = new Object();
    bigInteger0.equals(object1);
    MathUtils.pow(bigInteger0, bigInteger0);
    MathUtils.sign((short) 3);
    MathUtils.cosh(2655.65282576038);
    MathUtils.indicator((byte) 1);
    MathUtils.factorialLog(2335);
    MathUtils.lcm(2335, 1863);
    MathUtils.factorialLog(0);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
    if (Double.isInfinite(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to an infinite value"");
    }
    if (Double.isNaN(normalizedSum)) {
        throw MathRuntimeException.createIllegalArgumentException(""Cannot normalize to NaN"");
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw MathRuntimeException.createArithmeticException(""Array contains an infinite element, {0} at index {1}"", values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw MathRuntimeException.createArithmeticException(""Array sums to zero"");
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test112112() throws Throwable {
    MathUtils.factorialLog(5);
    MathUtils.round((float) 5, 0, 5);
    MathUtils.equals((double) 0, 49.05);
    MathUtils.gcd(0, 1);
    double[] doubleArray0 = new double[0];
    try {
        MathUtils.normalizeArray(doubleArray0, 1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Array sums to zero
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values input array to be normalized
 * @param normalizedSum target sum for the normalized array
 * @return normalized array
 * @throws ArithmeticException if the input array contains infinite elements or sums to zero
 * @throws IllegalArgumentException if the target sum is infinite or NaN
 */"
"public static long pow(final long k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test113113() throws Throwable {
    MathUtils.pow(0L, 1930L);
}","/**
 * Raise a long to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test114114() throws Throwable {
    MathUtils.nextAfter(0.0, 0.0);
    int int0 = 0;
    int int1 = 2;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(0, 2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = 0, k = 2
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test115115() throws Throwable {
    MathUtils.hash((-1180.46));
    int int0 = 0;
    MathUtils.scalb(0.0, 0);
    int int1 = 0;
    MathUtils.pow(0, 1027L);
    MathUtils.sinh(0);
    MathUtils.pow((-2479L), 0);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(Integer.MIN_VALUE, (-894500493));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test116116() throws Throwable {
    MathUtils.normalizeAngle(Double.NEGATIVE_INFINITY, (-3133.1239464));
    long long0 = 5040L;
    int int0 = (-254);
    try {
        MathUtils.pow(5040L, (-254));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (5,040^-254)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test117117() throws Throwable {
    MathUtils.sign(Double.POSITIVE_INFINITY);
    MathUtils.factorialLog(471);
    MathUtils.indicator(684L);
    MathUtils.indicator((short) (-2005));
    MathUtils.equals(1.0, 0.0, (double) 1L);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 1L;
    doubleArray0[1] = (double) (short) (-1);
    doubleArray0[2] = (double) 1L;
    doubleArray0[3] = 1.0;
    doubleArray0[4] = (double) (short) (-1);
    doubleArray0[5] = 1757.5571;
    doubleArray0[6] = 1.0;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign((long) 471);
    BigInteger bigInteger0 = BigInteger.ZERO;
    BigInteger bigInteger1 = MathUtils.pow(bigInteger0, 1L);
    MathUtils.distance1(doubleArray0, doubleArray0);
    try {
        MathUtils.pow(bigInteger1, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test118118() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    try {
        MathUtils.pow(bigInteger0, (-1189));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (0^-1,189)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test119119() throws Throwable {
    MathUtils.binomialCoefficientLog(162, 0);
    MathUtils.equals((-2146.7753742034997), 1.0, 1.0);
    MathUtils.indicator((long) 0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test120120() throws Throwable {
    MathUtils.log((-456.9455000594), (-4014.5344788835));
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (-4014.5344788835);
    doubleArray0[1] = (-4014.5344788835);
    doubleArray0[2] = (-456.9455000594);
    MathUtils.equals(doubleArray0, doubleArray0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test121121() throws Throwable {
    int int0 = 1;
    MathUtils.pow(1, 646L);
    MathUtils.factorialDouble(1);
    MathUtils.compareTo((-1666.062), (-2577.90655932433), 646L);
    MathUtils.indicator((-262.2159F));
    // Undeclared exception!
    try {
        MathUtils.round(0.0F, 1, (-1346));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // invalid rounding method -1,346, valid methods: ROUND_CEILING (2), ROUND_DOWN (1), ROUND_FLOOR (3), ROUND_HALF_DOWN (5), ROUND_HALF_EVEN (6), ROUND_HALF_UP (4), ROUND_UNNECESSARY (7), ROUND_UP (0)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test122122() throws Throwable {
    MathUtils.factorialDouble(0);
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 2115;
    intArray0[2] = 0;
    intArray0[3] = 0;
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.compareTo(603.2648814542638, 1909.016823, (-3213.8));
    MathUtils.scalb((-1533.94840061867), 1769);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static int compareTo(double x, double y, double eps) {
    if (equals(x, y, eps)) {
        return 0;
    } else if (x < y) {
        return -1;
    }
    return 1;
}","public void test123123() throws Throwable {
    MathUtils.factorial(0);
    MathUtils.compareTo(0.0, 0.0, 1138.50341);
}","/**
 * Compares two numbers given some amount of allowed error.
 *
 * @param x the first number
 * @param y the second number
 * @param eps the amount of error to allow when checking for equality
 * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>
 *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test124124() throws Throwable {
    MathUtils.indicator((short) 3394);
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.sign((short) 1);
    MathUtils.sign(0.0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test125125() throws Throwable {
    MathUtils.lcm(796, 796);
    MathUtils.lcm(796, 14);
    MathUtils.pow((-2569), (long) 796);
    MathUtils.addAndCheck(0, 796);
    MathUtils.equals((-512.7529803), (-4316.366337), 796);
    MathUtils.round((-409.2051665), 0);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw new ArithmeticException(""overflow: lcm is 2^31"");
    }
    return lcm;
}","public void test126126() throws Throwable {
    MathUtils.lcm(0, 640);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test127127() throws Throwable {
    MathUtils.log((-1599.64321), 4.9E-324);
    MathUtils.factorialDouble(1094);
    int[] intArray0 = new int[2];
    intArray0[0] = 1094;
    intArray0[1] = (-893);
    MathUtils.distance1(intArray0, intArray0);
    MathUtils.sign((long) 0);
    MathUtils.binomialCoefficientDouble(1094, 1094);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 0L;
    doubleArray0[1] = (double) 1094;
    doubleArray0[2] = 4.9E-324;
    doubleArray0[3] = 1.0;
    MathUtils.hash(doubleArray0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test128128() throws Throwable {
    MathUtils.factorialLog(0);
    MathUtils.factorialDouble(0);
    MathUtils.binomialCoefficientDouble(1324, 0);
    MathUtils.indicator((-87.34692652));
    MathUtils.indicator(0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test129129() throws Throwable {
    MathUtils.equals((double[]) null, (double[]) null);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test130130() throws Throwable {
    MathUtils.cosh(Double.NEGATIVE_INFINITY);
    MathUtils.indicator(1783.7365F);
    MathUtils.hash(Double.POSITIVE_INFINITY);
    MathUtils.addAndCheck((long) 2146435072, 2343L);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-1297), 2146435072);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -1,297, k = 2,146,435,072
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test131131() throws Throwable {
    MathUtils.nextAfter((-1.0), (-1.0));
    byte byte0 = (byte) 39;
    MathUtils.indicator((byte) 39);
    // Undeclared exception!
    try {
        MathUtils.pow((BigInteger) null, 1L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    return k.pow(e);
}","public void test132132() throws Throwable {
    int[] intArray0 = new int[6];
    intArray0[0] = (-770);
    intArray0[1] = 66;
    intArray0[2] = (-2571);
    intArray0[3] = (-1452);
    intArray0[4] = 1;
    intArray0[5] = 2146932120;
    MathUtils.distance(intArray0, intArray0);
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 16;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 33;
    byteArray0[3] = (byte) 116;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 101;
    byteArray0[6] = (byte) (-13);
    byteArray0[7] = (byte) 1;
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    try {
        MathUtils.pow(bigInteger0, (-770));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot raise an integral value to a negative power (1,153,239,761,690,161,921^-770)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Raise a BigInteger to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
    if (e.compareTo(BigInteger.ZERO) < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (!BigInteger.ZERO.equals(e)) {
        if (e.testBit(0)) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e.shiftRight(1);
    }
    return result;
}","public void test133133() throws Throwable {
    MathUtils.sign(1L);
    BigInteger bigInteger0 = BigInteger.TEN;
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-1);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) (-104);
    byteArray0[5] = (byte) 1;
    byteArray0[6] = (byte) 0;
    byteArray0[7] = (byte) 3;
    BigInteger bigInteger1 = new BigInteger(byteArray0);
    bigInteger0.compareTo(bigInteger1);
    MathUtils.pow(bigInteger0, bigInteger0);
}","/**
 * Raise a BigInteger to a BigInteger power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double cosh(double x) {
    return (Math.exp(x) + Math.exp(-x)) / 2.0;
}","public void test134134() throws Throwable {
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = (-3904);
    intArray0[2] = (-2771);
    intArray0[3] = 61;
    MathUtils.distance(intArray0, intArray0);
    MathUtils.lcm((-2771), (-2771));
    Random.setNextRandom(1140);
    MathUtils.mulAndCheck(1L, (long) 61);
    MathUtils.equals(454.63004, (double) (-3904), 61);
    MathUtils.indicator((long) (-2771));
    MathUtils.binomialCoefficientDouble(1120, (-2771));
    MathUtils.subAndCheck((long) 0, 4287L);
    MathUtils.pow(61, 2771);
    MathUtils.sign((byte) 52);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 473063909;
    doubleArray0[1] = (double) 4287L;
    doubleArray0[2] = 6.283185307179586;
    doubleArray0[3] = (double) (byte) 1;
    doubleArray0[4] = (double) 1140;
    doubleArray0[5] = (double) (byte) 1;
    doubleArray0[6] = 1420.9131513;
    doubleArray0[7] = (double) (byte) 1;
    doubleArray0[8] = (double) 1120;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign((double) (-4287L));
    MathUtils.cosh((-1.0));
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"">
 * hyperbolic cosine</a> of x.
 *
 * @param x double value for which to find the hyperbolic cosine
 * @return hyperbolic cosine of x
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test135135() throws Throwable {
    MathUtils.normalizeAngle(2.2250738585072014E-308, 2.2250738585072014E-308);
    MathUtils.sign((-1972.041F));
    int int0 = (-2220);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-2220), (-2220));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k), got n = -2,220
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""must have n >= 0 for n!, got n = {0}"", n);
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return FACTORIALS[n];
}","public void test137137() throws Throwable {
    float float0 = 0.0F;
    MathUtils.indicator(0.0F);
    MathUtils.sign((double) 1.0F);
    double double0 = 0.0;
    MathUtils.equals(1.0, 0.0);
    byte byte0 = (byte) 1;
    MathUtils.sign((byte) 1);
    long long0 = (-2296L);
    MathUtils.mulAndCheck((-2296L), (-2296L));
    int[] intArray0 = new int[5];
    intArray0[0] = (int) (byte) 1;
    intArray0[1] = (int) (byte) 1;
    intArray0[2] = (int) (byte) 1;
    intArray0[3] = (int) (byte) 1;
    intArray0[4] = (int) (byte) 1;
    MathUtils.distance(intArray0, intArray0);
    int int0 = 0;
    MathUtils.pow(0, (long) 1);
    MathUtils.sign((-1.0F));
    MathUtils.nextAfter(1059.34032908715, 4.9E-324);
    // Undeclared exception!
    try {
        MathUtils.factorial((-447));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!, got n = -447
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test140140() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    assertEquals(Float.NEGATIVE_INFINITY, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test140141() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    assertEquals((-1), int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = Math.max(max, Math.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test140142() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    assertEquals(0, int1);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test140143() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    BigInteger result = BigInteger.ONE;
    BigInteger k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result = result.multiply(k2p);
        }
        k2p = k2p.multiply(k2p);
        e = e >> 1;
    }
    return result;
}","public void test140144() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    assertNotNull(bigInteger0);
}","/**
 * Raise a BigInteger to a long power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test140145() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    assertTrue(byte1 == byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test140146() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    int int2 = MathUtils.sign(2);
    double double1 = MathUtils.indicator(0.0);
    assertEquals(1.0, double1, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
        }
        return Math.abs(u) + Math.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test140147() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    int int2 = MathUtils.sign(2);
    double double1 = MathUtils.indicator(0.0);
    MathUtils.indicator((long) 0);
    int int3 = MathUtils.gcd((-1), 1);
    assertTrue(int3 == int2);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test140148() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    int int2 = MathUtils.sign(2);
    double double1 = MathUtils.indicator(0.0);
    MathUtils.indicator((long) 0);
    int int3 = MathUtils.gcd((-1), 1);
    double double2 = MathUtils.scalb((-362.4093135705), 2147483646);
    assertEquals((-90.602328392625), double2, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test140149() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    int int2 = MathUtils.sign(2);
    double double1 = MathUtils.indicator(0.0);
    MathUtils.indicator((long) 0);
    int int3 = MathUtils.gcd((-1), 1);
    double double2 = MathUtils.scalb((-362.4093135705), 2147483646);
    long long0 = MathUtils.pow((long) (-1), 2);
    assertEquals(1L, long0);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log(i);
    }
    return logSum;
}","public void test140150() throws Throwable {
    MathUtils.indicator((-2757.917F));
    float float0 = MathUtils.round((-2757.917F), (-551), 0);
    int int0 = MathUtils.sign((-551));
    int[] intArray0 = new int[4];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1);
    int int1 = MathUtils.distanceInf(intArray0, intArray0);
    double double0 = MathUtils.log(2443.8207085413, (-608.6319869));
    byte byte0 = MathUtils.indicator((byte) (-93));
    BigInteger bigInteger0 = MathUtils.pow((BigInteger) null, (long) 0);
    MathUtils.mulAndCheck(0L, 87178291200L);
    byte byte1 = MathUtils.sign((byte) (-93));
    int int2 = MathUtils.sign(2);
    double double1 = MathUtils.indicator(0.0);
    MathUtils.indicator((long) 0);
    int int3 = MathUtils.gcd((-1), 1);
    double double2 = MathUtils.scalb((-362.4093135705), 2147483646);
    long long0 = MathUtils.pow((long) (-1), 2);
    double double3 = MathUtils.binomialCoefficientLog(2, (-1));
    assertEquals(0.0, double3, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test141151() throws Throwable {
    MathUtils.indicator((byte) (-114));
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) (byte) (-1);
    doubleArray0[1] = (double) (byte) (-114);
    doubleArray0[2] = (double) (byte) (-114);
    doubleArray0[3] = (double) (byte) (-1);
    double[] doubleArray1 = MathUtils.normalizeArray(doubleArray0, (-744.58655));
    MathUtils.distanceInf(doubleArray1, doubleArray0);
    MathUtils.sinh(2123.0);
    MathUtils.gcd(0, 0);
    MathUtils.indicator(2455.788F);
    // Undeclared exception!
    try {
        MathUtils.round((double) (byte) (-114), 0, (int) (byte) (-114));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += Math.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test142152() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    assertEquals(0, int0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test142153() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    assertEquals(3893.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long pow(final long k, int e) throws IllegalArgumentException {
    if (e < 0) {
        throw MathRuntimeException.createIllegalArgumentException(""cannot raise an integral value to a negative power ({0}^{1})"", k, e);
    }
    long result = 1l;
    long k2p = k;
    while (e != 0) {
        if ((e & 0x1) != 0) {
            result *= k2p;
        }
        k2p *= k2p;
        e = e >> 1;
    }
    return result;
}","public void test142154() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    long long0 = MathUtils.pow((long) 0, 0);
    assertEquals(1L, long0);
}","/**
 * Raise a long to an int power.
 * @param k number to raise
 * @param e exponent (must be positive or null)
 * @return k<sup>e</sup>
 * @exception IllegalArgumentException if e is negative
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test142155() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    long long0 = MathUtils.pow((long) 0, 0);
    double double0 = MathUtils.sinh((-6077.737308));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log(n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log(i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log(i);
    }
    return logSum;
}","public void test142156() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    long long0 = MathUtils.pow((long) 0, 0);
    double double0 = MathUtils.sinh((-6077.737308));
    double double1 = MathUtils.binomialCoefficientLog(0, 0);
    assertEquals(0.0, double1, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
        }
        return Math.abs(u) + Math.abs(v);
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", p, q);
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test142157() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    long long0 = MathUtils.pow((long) 0, 0);
    double double0 = MathUtils.sinh((-6077.737308));
    double double1 = MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.factorial(0);
    int int1 = MathUtils.gcd(1726, 1726);
    assertEquals(1726, int1);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param p any number
 * @param q any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test142158() throws Throwable {
    int[] intArray0 = new int[0];
    int int0 = MathUtils.distance1(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    float float0 = MathUtils.round(3892.7F, 0, 0);
    long long0 = MathUtils.pow((long) 0, 0);
    double double0 = MathUtils.sinh((-6077.737308));
    double double1 = MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.distance(intArray0, intArray0);
    MathUtils.distanceInf(intArray0, intArray0);
    MathUtils.factorial(0);
    int int1 = MathUtils.gcd(1726, 1726);
    MathUtils.sign(0);
    byte byte0 = MathUtils.indicator((byte) 14);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static long binomialCoefficient(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            result = result * i / j;
            i++;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            final long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
            i++;
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        int i = n - k + 1;
        for (int j = 1; j <= k; j++) {
            final long d = gcd(i, j);
            result = mulAndCheck(result / (j / d), i / d);
            i++;
        }
    }
    return result;
}","public void test143159() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(4191, 3092);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    checkBinomial(n, k);
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test144160() throws Throwable {
    int int0 = 0;
    int int1 = (-603);
    MathUtils.binomialCoefficientDouble(0, (-603));
    MathUtils.sinh(1.0);
    MathUtils.log(3670.43953, 0);
    MathUtils.indicator((byte) 52);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) (-603);
    doubleArray0[1] = 1.1752011936438016;
    doubleArray0[2] = (double) (-603);
    doubleArray0[3] = 3670.43953;
    doubleArray0[4] = (double) (-603);
    MathUtils.distance1(doubleArray0, doubleArray0);
    MathUtils.distance(doubleArray0, doubleArray0);
    MathUtils.distanceInf(doubleArray0, doubleArray0);
    MathUtils.equals((-1566.3), 1.0);
    MathUtils.indicator(0);
    int int2 = 1633;
    MathUtils.addAndCheck(20, 1633);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-603), 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k), got n = -603, k = 1
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
