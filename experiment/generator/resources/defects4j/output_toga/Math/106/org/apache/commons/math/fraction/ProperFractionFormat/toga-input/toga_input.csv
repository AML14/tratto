focal_method,test_prefix,docstring
"public StringBuffer format(Fraction fraction, StringBuffer toAppendTo, FieldPosition pos) {
    pos.setBeginIndex(0);
    pos.setEndIndex(0);
    int num = fraction.getNumerator();
    int den = fraction.getDenominator();
    int whole = num / den;
    num = num % den;
    if (whole != 0) {
        getWholeFormat().format(whole, toAppendTo, pos);
        toAppendTo.append(' ');
        num = Math.abs(num);
    }
    getNumeratorFormat().format(num, toAppendTo, pos);
    toAppendTo.append("" / "");
    getDenominatorFormat().format(den, toAppendTo, pos);
    return toAppendTo;
}","public void test024() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance(locale0);
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0, numberFormat0, numberFormat0);
    Fraction fraction0 = new Fraction((-4438.5648678));
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 1902);
    // Undeclared exception!
    try {
        properFractionFormat0.format(fraction0, (StringBuffer) null, fieldPosition0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Formats a {@link Fraction} object to produce a string.  The fraction
 * is output in proper format.
 *
 * @param fraction the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test035() throws Throwable {
    DecimalFormat decimalFormat0 = new DecimalFormat();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(decimalFormat0);
    ParsePosition parsePosition0 = new ParsePosition(0);
    Fraction fraction0 = properFractionFormat0.parse(""-2"", parsePosition0);
    assertEquals((-2.0F), fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public long longValue() {
    return (long) doubleValue();
}","public void test046() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getInstance();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0);
    ParsePosition parsePosition0 = new ParsePosition(1);
    Fraction fraction0 = properFractionFormat0.parse(""-686"", parsePosition0);
    assertEquals(686L, fraction0.longValue());
}","/**
 * Gets the fraction as a <tt>long</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public NumberFormat getWholeFormat() {
    return wholeFormat;
}","public void test068() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getCurrencyInstance();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0);
    NumberFormat numberFormat1 = properFractionFormat0.getWholeFormat();
    assertSame(numberFormat1, numberFormat0);
}","/**
 * Access the whole format.
 * @return the whole format.
 */"
"public Fraction parse(String source, ParsePosition pos) {
    // try to parse improper fraction
    Fraction ret = super.parse(source, pos);
    if (ret != null) {
        return ret;
    }
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse whole
    Number whole = getWholeFormat().parse(source, pos);
    if (whole == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse numerator
    Number num = getNumeratorFormat().parse(source, pos);
    if (num == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // minus signs should be leading, invalid expression
    // parse '/'
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    switch(c) {
        case 0:
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/':
            // found '/', continue parsing denominator
            break;
        default:
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse denominator
    Number den = getDenominatorFormat().parse(source, pos);
    if (den == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // minus signs must be leading, invalid
    int w = whole.intValue();
    int n = num.intValue();
    int d = den.intValue();
    return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
}","public void test079() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0);
    ParsePosition parsePosition0 = new ParsePosition(Integer.MIN_VALUE);
    // Undeclared exception!
    try {
        properFractionFormat0.parse(""]p~+@BV1@"", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parses a string to produce a {@link Fraction} object.  This method
 * expects the string to be formatted as a proper fraction.
 * <p>
 * Minus signs are only allowed in the whole number part - i.e.,
 * ""-3 1/2"" is legitimate and denotes -7/2, but ""-3 -1/2"" is invalid and
 * will result in a <code>ParseException</code>.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Fraction} object.
 */"
"public Fraction parse(String source, ParsePosition pos) {
    // try to parse improper fraction
    Fraction ret = super.parse(source, pos);
    if (ret != null) {
        return ret;
    }
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse whole
    Number whole = getWholeFormat().parse(source, pos);
    if (whole == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse numerator
    Number num = getNumeratorFormat().parse(source, pos);
    if (num == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // minus signs should be leading, invalid expression
    // parse '/'
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    switch(c) {
        case 0:
            // no '/'
            // return num as a fraction
            return new Fraction(num.intValue(), 1);
        case '/':
            // found '/', continue parsing denominator
            break;
        default:
            // invalid '/'
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse denominator
    Number den = getDenominatorFormat().parse(source, pos);
    if (den == null) {
        // invalid integer number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // minus signs must be leading, invalid
    int w = whole.intValue();
    int n = num.intValue();
    int d = den.intValue();
    return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
}","public void test0810() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    NumberFormat numberFormat0 = NumberFormat.getNumberInstance(locale0);
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0, numberFormat0, numberFormat0);
    ParsePosition parsePosition0 = new ParsePosition(0);
    // Undeclared exception!
    try {
        properFractionFormat0.parse((String) null, parsePosition0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.fraction.FractionFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Fraction} object.  This method
 * expects the string to be formatted as a proper fraction.
 * <p>
 * Minus signs are only allowed in the whole number part - i.e.,
 * ""-3 1/2"" is legitimate and denotes -7/2, but ""-3 -1/2"" is invalid and
 * will result in a <code>ParseException</code>.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Fraction} object.
 */"
"public ProperFractionFormat(NumberFormat wholeFormat, NumberFormat numeratorFormat, NumberFormat denominatorFormat) {
    super(numeratorFormat, denominatorFormat);
    setWholeFormat(wholeFormat);
}","public void test0911() throws Throwable {
    ProperFractionFormat properFractionFormat0 = null;
    try {
        properFractionFormat0 = new ProperFractionFormat((NumberFormat) null, (NumberFormat) null, (NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // whole format can not be null.
        //
        verifyException(""org.apache.commons.math.fraction.ProperFractionFormat"", e);
    }
}","/**
 * Create a proper formatting instance with a custom number format for each
 * of the whole, numerator, and denominator.
 * @param wholeFormat the custom format for the whole.
 * @param numeratorFormat the custom format for the numerator.
 * @param denominatorFormat the custom format for the denominator.
 */"
"public ProperFractionFormat(NumberFormat format) {
    this(format, (NumberFormat) format.clone(), (NumberFormat) format.clone());
}","public void test1012() throws Throwable {
    ProperFractionFormat properFractionFormat0 = null;
    try {
        properFractionFormat0 = new ProperFractionFormat((NumberFormat) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.fraction.ProperFractionFormat"", e);
    }
}","/**
 * Create a proper formatting instance with a custom number format for the
 * whole, numerator, and denominator.
 * @param format the custom format for the whole, numerator, and
 *        denominator.
 */"
"public NumberFormat getWholeFormat() {
    return wholeFormat;
}","public void test1113() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0);
    NumberFormat numberFormat1 = properFractionFormat0.getWholeFormat();
    assertSame(numberFormat1, numberFormat0);
}","/**
 * Access the whole format.
 * @return the whole format.
 */"
"public void setWholeFormat(NumberFormat format) {
    if (format == null) {
        throw new IllegalArgumentException(""whole format can not be null."");
    }
    this.wholeFormat = format;
}","public void test1214() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getNumberInstance();
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(numberFormat0, numberFormat0, numberFormat0);
    // Undeclared exception!
    try {
        properFractionFormat0.setWholeFormat((NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // whole format can not be null.
        //
        verifyException(""org.apache.commons.math.fraction.ProperFractionFormat"", e);
    }
}","/**
 * Modify the whole format.
 * @param format The new whole format value.
 * @throws IllegalArgumentException if <code>format</code> is
 *         <code>null</code>.
 */"
"public StringBuffer format(Fraction fraction, StringBuffer toAppendTo, FieldPosition pos) {
    pos.setBeginIndex(0);
    pos.setEndIndex(0);
    int num = fraction.getNumerator();
    int den = fraction.getDenominator();
    int whole = num / den;
    num = num % den;
    if (whole != 0) {
        getWholeFormat().format(whole, toAppendTo, pos);
        toAppendTo.append(' ');
        num = Math.abs(num);
    }
    getNumeratorFormat().format(num, toAppendTo, pos);
    toAppendTo.append("" / "");
    getDenominatorFormat().format(den, toAppendTo, pos);
    return toAppendTo;
}","public void test1519() throws Throwable {
    ChoiceFormat choiceFormat0 = new ChoiceFormat("""");
    ProperFractionFormat properFractionFormat0 = new ProperFractionFormat(choiceFormat0, choiceFormat0, choiceFormat0);
    ParsePosition parsePosition0 = new ParsePosition(3023);
    Fraction fraction0 = properFractionFormat0.parse(""R"", parsePosition0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 3023);
    // Undeclared exception!
    try {
        properFractionFormat0.format(fraction0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""java.text.ChoiceFormat"", e);
    }
}","/**
 * Formats a {@link Fraction} object to produce a string.  The fraction
 * is output in proper format.
 *
 * @param fraction the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 */"
