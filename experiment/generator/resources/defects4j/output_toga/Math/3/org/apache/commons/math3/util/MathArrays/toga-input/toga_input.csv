focal_method,test_prefix,docstring
"public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
    MathUtils.checkNotNull(x);
    MathUtils.checkNotNull(h);
    final int xLen = x.length;
    final int hLen = h.length;
    if (xLen == 0 || hLen == 0) {
        throw new NoDataException();
    }
    // initialize the output array
    final int totalLength = xLen + hLen - 1;
    final double[] y = new double[totalLength];
    // straightforward implementation of the convolution sum
    for (int n = 0; n < totalLength; n++) {
        double yn = 0;
        int k = FastMath.max(0, n + 1 - xLen);
        int j = n - k;
        while (k < hLen && j >= 0) {
            yn += x[j--] * h[k++];
        }
        y[n] = yn;
    }
    return y;
}","public void test0000() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (-2480.05522);
    double[] doubleArray1 = MathArrays.convolve(doubleArray0, doubleArray0);
    assertEquals(15, doubleArray1.length);
}","/**
 * Calculates the <a href=""http://en.wikipedia.org/wiki/Convolution"">
 * convolution</a> between two sequences.
 * The solution is obtained via straightforward computation of the
 * convolution sum (and not via FFT).
 * Whenever the computation needs an element that would be located
 * at an index outside the input arrays, the value is assumed to be
 * zero.
 *
 * @param x First sequence.
 * Typically, this sequence will represent an input signal to a system.
 * @param h Second sequence.
 * Typically, this sequence will represent the impulse response of the
 * system.
 * @return the convolution of {@code x} and {@code h}.
 * This array's length will be {@code x.length + h.length - 1}.
 * @throws NullArgumentException if either {@code x} or {@code h} is
 * {@code null}.
 * @throws NoDataException if either {@code x} or {@code h} is empty.
 *
 * @since 3.3
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
    if (Double.isInfinite(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test0011() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (-821.0);
    double[] doubleArray1 = MathArrays.normalizeArray(doubleArray0, (-821.0));
    assertArrayEquals(new double[] { (-821.0) }, doubleArray1, 0.01);
}","/**
 * Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values Input array to be normalized
 * @param normalizedSum Target sum for the normalized array
 * @return the normalized array.
 * @throws MathArithmeticException if the input array contains infinite
 * elements or sums to zero.
 * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
 * @since 2.1
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test0022() throws Throwable {
    double[] doubleArray0 = new double[6];
    double[] doubleArray1 = new double[0];
    boolean boolean0 = MathArrays.equalsIncludingNaN(doubleArray0, doubleArray1);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test0033() throws Throwable {
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = new double[7];
    boolean boolean0 = MathArrays.equals(doubleArray0, doubleArray1);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test0044() throws Throwable {
    float[] floatArray0 = new float[2];
    float[] floatArray1 = new float[1];
    boolean boolean0 = MathArrays.equalsIncludingNaN(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test0055() throws Throwable {
    float[] floatArray0 = new float[23];
    float[] floatArray1 = new float[0];
    boolean boolean0 = MathArrays.equals(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variable naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // final rounding, s12 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s12High + (prod1Low + prod2Low + s12Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2;
    }
    return result;
}","public void test0066() throws Throwable {
    double double0 = MathArrays.linearCombination((double) 2231, 1762.01, 0.0, 0.0);
    assertEquals(3931044.31, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub>
 * @see #linearCombination(double, double, double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test0077() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = 1.304E19;
    doubleArray0[2] = Double.POSITIVE_INFINITY;
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test0088() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[3] = 3.26E18;
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(3.26E18, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test0099() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[3] = 3.834E-20;
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(3.834E-20, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static void checkNonNegative(final long[][] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        for (int j = 0; j < in[i].length; j++) {
            if (in[i][j] < 0) {
                throw new NotPositiveException(in[i][j]);
            }
        }
    }
}","public void test01010() throws Throwable {
    long[][] longArray0 = new long[2][0];
    long[] longArray1 = new long[8];
    longArray1[0] = 2937L;
    longArray0[0] = longArray1;
    MathArrays.checkNonNegative(longArray0);
    assertEquals(2, longArray0.length);
}","/**
 * Check all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"public static void checkNonNegative(final long[] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] < 0) {
            throw new NotPositiveException(in[i]);
        }
    }
}","public void test01111() throws Throwable {
    long[] longArray0 = new long[2];
    longArray0[0] = 100L;
    MathArrays.checkNonNegative(longArray0);
    assertEquals(2, longArray0.length);
}","/**
 * Check that all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] <= 0) {
            throw new NotStrictlyPositiveException(in[i]);
        }
    }
}","public void test01212() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = Double.NaN;
    doubleArray0[1] = (-3239.4);
    try {
        MathArrays.checkPositive(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -3,239.4 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that all entries of the input array are strictly positive.
 *
 * @param in Array to be tested
 * @throws NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.
 * @since 3.1
 */"
"public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
    MathUtils.checkNotNull(in);
    for (int i = 1; i < in.length; i++) {
        if (in[i].length != in[0].length) {
            throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
        }
    }
}","public void test01313() throws Throwable {
    long[][] longArray0 = new long[3][5];
    long[] longArray1 = new long[2];
    longArray0[0] = longArray1;
    try {
        MathArrays.checkRectangular(longArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // some rows have length 5 while others have length 2
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Throws DimensionMismatchException if the input array is not rectangular.
 *
 * @param in array to be tested
 * @throws NullArgumentException if input array is null
 * @throws DimensionMismatchException if input array is not rectangular
 * @since 3.1
 */"
"public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
    MathUtils.checkNotNull(in);
    for (int i = 1; i < in.length; i++) {
        if (in[i].length != in[0].length) {
            throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
        }
    }
}","public void test01414() throws Throwable {
    long[][] longArray0 = new long[0][7];
    MathArrays.checkRectangular(longArray0);
    assertEquals(0, longArray0.length);
}","/**
 * Throws DimensionMismatchException if the input array is not rectangular.
 *
 * @param in array to be tested
 * @throws NullArgumentException if input array is null
 * @throws DimensionMismatchException if input array is not rectangular
 * @since 3.1
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
    checkOrder(val, dir, strict, true);
}","public void test01515() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[1] = 3995.29744;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    try {
        MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not strictly decreasing (0 <= 3,995.297)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test01616() throws Throwable {
    String[] stringArray0 = new String[8];
    stringArray0[0] = """";
    stringArray0[1] = """";
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.isMonotonic(stringArray0, mathArrays_OrderDirection0, true);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test01717() throws Throwable {
    Double[] doubleArray0 = new Double[2];
    Double double0 = new Double((-58.37));
    doubleArray0[0] = double0;
    doubleArray0[1] = doubleArray0[0];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    boolean boolean0 = MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, true);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test01818() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 1066;
    int int0 = MathArrays.distanceInf(intArray0, intArray0);
    assertEquals(0, int0);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test01919() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 6623593.361970729;
    double double0 = MathArrays.distance(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test02020() throws Throwable {
    int[] intArray0 = new int[6];
    intArray0[2] = 142;
    int int0 = MathArrays.distance1(intArray0, intArray0);
    assertEquals(0, int0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test02121() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[1] = (-2.6919816358913188E22);
    double double0 = MathArrays.distance1(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] /= b[i];
    }
    return result;
}","public void test02222() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (-1.0);
    double[] doubleArray1 = MathArrays.ebeDivide(doubleArray0, doubleArray0);
    assertArrayEquals(new double[] { 1.0, Double.NaN }, doubleArray1, 0.01);
}","/**
 * Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.
 *
 * @param a Numerator of the division.
 * @param b Denominator of the division.
 * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] /= b[i];
    }
    return result;
}","public void test02323() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = new double[5];
    try {
        MathArrays.ebeDivide(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != 5
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.
 *
 * @param a Numerator of the division.
 * @param b Denominator of the division.
 * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] *= b[i];
    }
    return result;
}","public void test02424() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[6];
    try {
        MathArrays.ebeMultiply(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 5 != 6
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.
 *
 * @param a First factor of the multiplication.
 * @param b Second factor of the multiplication.
 * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] -= b[i];
    }
    return result;
}","public void test02525() throws Throwable {
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = new double[8];
    try {
        MathArrays.ebeSubtract(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 7 != 8
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.
 *
 * @param a First term.
 * @param b Element to be subtracted.
 * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] += b[i];
    }
    return result;
}","public void test02626() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (-1.0);
    double[] doubleArray1 = MathArrays.ebeAdd(doubleArray0, doubleArray0);
    assertArrayEquals(new double[] { (-2.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * Creates an array whose contents will be the element-by-element
 * addition of the arguments.
 *
 * @param a First term of the addition.
 * @param b Second term of the addition.
 * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] += b[i];
    }
    return result;
}","public void test02727() throws Throwable {
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = new double[2];
    try {
        MathArrays.ebeAdd(doubleArray1, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != 7
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * addition of the arguments.
 *
 * @param a First term of the addition.
 * @param b Second term of the addition.
 * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static void scaleInPlace(double val, final double[] arr) {
    for (int i = 0; i < arr.length; i++) {
        arr[i] *= val;
    }
}","public void test02828() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (-550.682);
    MathArrays.scaleInPlace((-2110.891841), doubleArray0);
    assertArrayEquals(new double[] { 1162430.140785562, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0 }, doubleArray0, 0.01);
}","/**
 * <p>Multiply each element of an array by a value.</p>
 *
 * <p>The array is modified in place (no copy is created).</p>
 *
 * @param arr Array to scale
 * @param val Scalar
 * @since 3.2
 */"
"public static double[] scale(double val, final double[] arr) {
    double[] newArr = new double[arr.length];
    for (int i = 0; i < arr.length; i++) {
        newArr[i] = arr[i] * val;
    }
    return newArr;
}","public void test02929() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = MathArrays.scale(Double.NaN, doubleArray0);
    assertArrayEquals(new double[] { Double.NaN, Double.NaN }, doubleArray1, 0.01);
}","/**
 * Create a copy of an array scaled by a value.
 *
 * @param arr Array to scale.
 * @param val Scalar.
 * @return scaled copy of array with each entry multiplied by val.
 * @since 3.2
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
    checkOrder(val, dir, strict, true);
}","public void test03030() throws Throwable {
    double[] doubleArray0 = new double[1];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false);
    assertEquals(1, doubleArray0.length);
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test03131() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[4] = (-2551.8);
    double[] doubleArray1 = MathArrays.ebeMultiply(doubleArray0, doubleArray0);
    double double0 = MathArrays.linearCombination(doubleArray0, doubleArray1);
    assertEquals((-1.6616513291832005E10), double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // split a4 and b4 as two 26 bits numbers
    final double ca4 = SPLIT_FACTOR * a4;
    final double a4High = ca4 - (ca4 - a4);
    final double a4Low = a4 - a4High;
    final double cb4 = SPLIT_FACTOR * b4;
    final double b4High = cb4 - (cb4 - b4);
    final double b4Low = b4 - b4High;
    // accurate multiplication a4 * b4
    final double prod4High = a4 * b4;
    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4
    final double s1234High = s123High + prod4High;
    final double s1234Prime = s1234High - prod4High;
    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);
    // final rounding, s1234 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;
    }
    return result;
}","public void test03232() throws Throwable {
    double double0 = MathArrays.linearCombination((-1819.8342), 0.0, (-1819.8342), (-1819.8342), (-1819.8342), (-1819.8342), 0.0, 3.32);
    assertEquals(6623593.03097928, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // split a4 and b4 as two 26 bits numbers
    final double ca4 = SPLIT_FACTOR * a4;
    final double a4High = ca4 - (ca4 - a4);
    final double a4Low = a4 - a4High;
    final double cb4 = SPLIT_FACTOR * b4;
    final double b4High = cb4 - (cb4 - b4);
    final double b4Low = b4 - b4High;
    // accurate multiplication a4 * b4
    final double prod4High = a4 * b4;
    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4
    final double s1234High = s123High + prod4High;
    final double s1234Prime = s1234High - prod4High;
    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);
    // final rounding, s1234 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;
    }
    return result;
}","public void test03333() throws Throwable {
    double double0 = MathArrays.linearCombination(1234.5736213204275, 100.0, (-1.0), (-2006.80231954626), 0.0, 2670.4115015352363, (-1052.0847), 1234.5736213204275);
    assertEquals((-1173411.8535632268), double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // final rounding, s123 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3;
    }
    return result;
}","public void test03434() throws Throwable {
    double double0 = MathArrays.linearCombination(0.0, 0.0, 0.0, 0.0, 0.0, 1234.5736213204275);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // final rounding, s123 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3;
    }
    return result;
}","public void test03535() throws Throwable {
    double double0 = MathArrays.linearCombination((-20.0), (-20.0), 3488.314585954745, (-20.0), 3488.314585954745, 3995.29744);
    assertEquals(1.3867488043460557E7, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variable naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // final rounding, s12 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s12High + (prod1Low + prod2Low + s12Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2;
    }
    return result;
}","public void test03636() throws Throwable {
    double double0 = MathArrays.linearCombination(0.0, 0.0, 1.0E-5, 1.304E19);
    assertEquals(1.3040000000000002E14, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub>
 * @see #linearCombination(double, double, double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variable naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // final rounding, s12 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s12High + (prod1Low + prod2Low + s12Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2;
    }
    return result;
}","public void test03737() throws Throwable {
    double double0 = MathArrays.linearCombination(546.13186165, (-740.699253979), 1242.7670124, 0.0);
    assertEquals((-404519.4624983175), double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub>
 * @see #linearCombination(double, double, double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
    return checkOrder(val, dir, strict, false);
}","public void test03838() throws Throwable {
    double[] doubleArray0 = new double[1];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, false);
    assertTrue(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] -= b[i];
    }
    return result;
}","public void test03939() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.ebeSubtract(doubleArray0, doubleArray0);
    assertNotSame(doubleArray1, doubleArray0);
}","/**
 * Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.
 *
 * @param a First term.
 * @param b Element to be subtracted.
 * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] *= b[i];
    }
    return result;
}","public void test04040() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.ebeMultiply(doubleArray0, doubleArray0);
    assertNotSame(doubleArray1, doubleArray0);
}","/**
 * Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.
 *
 * @param a First factor of the multiplication.
 * @param b Second factor of the multiplication.
 * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] += b[i];
    }
    return result;
}","public void test04141() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.ebeAdd(doubleArray0, doubleArray0);
    assertNotSame(doubleArray1, doubleArray0);
}","/**
 * Creates an array whose contents will be the element-by-element
 * addition of the arguments.
 *
 * @param a First term of the addition.
 * @param b Second term of the addition.
 * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test04242() throws Throwable {
    int[] intArray0 = new int[4];
    intArray0[0] = 1364;
    int[] intArray1 = new int[8];
    int int0 = MathArrays.distanceInf(intArray0, intArray1);
    assertEquals(1364, int0);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test04343() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[2] = 64.448060412;
    double[] doubleArray1 = MathArrays.normalizeArray(doubleArray0, (-464.6));
    double double0 = MathArrays.distanceInf(doubleArray0, doubleArray1);
    assertEquals(529.048060412, double0, 0.01);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04445() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 783;
    int[] intArray1 = new int[9];
    int int0 = MathArrays.distance1(intArray0, intArray1);
    assertEquals(783, int0);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test04546() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (-1.0);
    double[] doubleArray1 = new double[5];
    double double0 = MathArrays.distance1(doubleArray0, doubleArray1);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test04647() throws Throwable {
    int[] intArray0 = new int[1];
    int[] intArray1 = new int[3];
    intArray1[0] = 9;
    double double0 = MathArrays.distance(intArray0, intArray1);
    assertEquals(9.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test04748() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (-2446.0);
    double[] doubleArray1 = MathArrays.ebeSubtract(doubleArray0, doubleArray0);
    double double0 = MathArrays.distance(doubleArray0, doubleArray1);
    assertEquals(2446.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static int[] copyOf(int[] source, int len) {
    final int[] output = new int[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test04850() throws Throwable {
    int[] intArray0 = new int[6];
    int[] intArray1 = MathArrays.copyOf(intArray0, 119);
    assertEquals(119, intArray1.length);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static int[] copyOf(int[] source, int len) {
    final int[] output = new int[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test04951() throws Throwable {
    int[] intArray0 = new int[7];
    int[] intArray1 = MathArrays.copyOf(intArray0, 0);
    assertEquals(0, intArray1.length);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static int[] copyOf(int[] source) {
    return copyOf(source, source.length);
}","public void test05052() throws Throwable {
    int[] intArray0 = new int[0];
    int[] intArray1 = MathArrays.copyOf(intArray0);
    assertEquals(0, intArray1.length);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"public static double[] copyOf(double[] source, int len) {
    final double[] output = new double[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test05154() throws Throwable {
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0, 0);
    assertEquals(0, doubleArray1.length);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static double[] copyOf(double[] source) {
    return copyOf(source, source.length);
}","public void test05255() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0);
    assertEquals(0, doubleArray1.length);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"public static void sortInPlace(double[] x, double[]... yList) throws DimensionMismatchException, NullArgumentException {
    sortInPlace(x, OrderDirection.INCREASING, yList);
}","public void test05357() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.scale((-107.611519), doubleArray0);
    // Undeclared exception!
    try {
        MathArrays.sortInPlace(doubleArray1, (double[][]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if
 * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then
 * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},
 * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null.
 * @since 3.0
 */"
"public static void sortInPlace(double[] x, final OrderDirection dir, double[]... yList) throws NullArgumentException, DimensionMismatchException {
    // Consistency checks.
    if (x == null) {
        throw new NullArgumentException();
    }
    final int yListLen = yList.length;
    final int len = x.length;
    for (int j = 0; j < yListLen; j++) {
        final double[] y = yList[j];
        if (y == null) {
            throw new NullArgumentException();
        }
        if (y.length != len) {
            throw new DimensionMismatchException(y.length, len);
        }
    }
    // Associate each abscissa ""x[i]"" with its index ""i"".
    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);
    for (int i = 0; i < len; i++) {
        list.add(new Pair<Double, Integer>(x[i], i));
    }
    // Create comparators for increasing and decreasing orders.
    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    } : new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o2.getKey().compareTo(o1.getKey());
        }
    };
    // Sort.
    Collections.sort(list, comp);
    // Modify the original array so that its elements are in
    // the prescribed order.
    // Retrieve indices of original locations.
    final int[] indices = new int[len];
    for (int i = 0; i < len; i++) {
        final Pair<Double, Integer> e = list.get(i);
        x[i] = e.getKey();
        indices[i] = e.getValue();
    }
    // In each of the associated arrays, move the
    // elements to their new location.
    for (int j = 0; j < yListLen; j++) {
        // Input array will be modified in place.
        final double[] yInPlace = yList[j];
        final double[] yOrig = yInPlace.clone();
        for (int i = 0; i < len; i++) {
            yInPlace[i] = yOrig[indices[i]];
        }
    }
}","public void test05458() throws Throwable {
    double[] doubleArray0 = new double[3];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.sortInPlace(doubleArray0, mathArrays_OrderDirection0, (double[][]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other
 * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}
 * parameter.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param dir Order direction.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null
 * @since 3.0
 */"
"public static void scaleInPlace(double val, final double[] arr) {
    for (int i = 0; i < arr.length; i++) {
        arr[i] *= val;
    }
}","public void test05559() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.scaleInPlace(0.25, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * <p>Multiply each element of an array by a value.</p>
 *
 * <p>The array is modified in place (no copy is created).</p>
 *
 * @param arr Array to scale
 * @param val Scalar
 * @since 3.2
 */"
"public static double[] scale(double val, final double[] arr) {
    double[] newArr = new double[arr.length];
    for (int i = 0; i < arr.length; i++) {
        newArr[i] = arr[i] * val;
    }
    return newArr;
}","public void test05660() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.scale(0.0, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Create a copy of an array scaled by a value.
 *
 * @param arr Array to scale.
 * @param val Scalar.
 * @return scaled copy of array with each entry multiplied by val.
 * @since 3.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test05761() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.safeNorm((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
    if (Double.isInfinite(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test05862() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.normalizeArray((double[]) null, 392.948);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values Input array to be normalized
 * @param normalizedSum Target sum for the normalized array
 * @return the normalized array.
 * @throws MathArithmeticException if the input array contains infinite
 * elements or sums to zero.
 * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
 * @since 2.1
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test05963() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.linearCombination((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test06064() throws Throwable {
    double[] doubleArray0 = new double[0];
    // Undeclared exception!
    try {
        MathArrays.linearCombination(doubleArray0, doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test06165() throws Throwable {
    Double[] doubleArray0 = new Double[0];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
    return checkOrder(val, dir, strict, false);
}","public void test06266() throws Throwable {
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.isMonotonic((double[]) null, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
    return checkOrder(val, dir, strict, false);
}","public void test06367() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] -= b[i];
    }
    return result;
}","public void test06468() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.ebeSubtract((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.
 *
 * @param a First term.
 * @param b Element to be subtracted.
 * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] *= b[i];
    }
    return result;
}","public void test06569() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.ebeMultiply((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.
 *
 * @param a First factor of the multiplication.
 * @param b Second factor of the multiplication.
 * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] /= b[i];
    }
    return result;
}","public void test06670() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.ebeDivide((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.
 *
 * @param a Numerator of the division.
 * @param b Denominator of the division.
 * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] += b[i];
    }
    return result;
}","public void test06771() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.ebeAdd((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * addition of the arguments.
 *
 * @param a First term of the addition.
 * @param b Second term of the addition.
 * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test06872() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distanceInf((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int distanceInf(int[] p1, int[] p2) {
    int max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test06973() throws Throwable {
    int[] intArray0 = new int[8];
    int[] intArray1 = new int[0];
    // Undeclared exception!
    try {
        MathArrays.distanceInf(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test07074() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distanceInf((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test07175() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = new double[4];
    // Undeclared exception!
    try {
        MathArrays.distanceInf(doubleArray1, doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test07276() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distance1((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static int distance1(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test07377() throws Throwable {
    int[] intArray0 = new int[7];
    int[] intArray1 = new int[5];
    // Undeclared exception!
    try {
        MathArrays.distance1(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test07478() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distance1((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance1(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        sum += FastMath.abs(p1[i] - p2[i]);
    }
    return sum;
}","public void test07579() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = new double[1];
    // Undeclared exception!
    try {
        MathArrays.distance1(doubleArray0, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>1</sub> (sum of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>1</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test07680() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distance((int[]) null, (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test07781() throws Throwable {
    int[] intArray0 = new int[6];
    int[] intArray1 = new int[1];
    // Undeclared exception!
    try {
        MathArrays.distance(intArray0, intArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test07882() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.distance((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double distance(double[] p1, double[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test07983() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = new double[7];
    // Undeclared exception!
    try {
        MathArrays.distance(doubleArray0, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 7
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static int[] copyOf(int[] source, int len) {
    final int[] output = new int[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test08084() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.copyOf((int[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static int[] copyOf(int[] source) {
    return copyOf(source, source.length);
}","public void test08185() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.copyOf((int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"public static double[] copyOf(double[] source, int len) {
    final double[] output = new double[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test08286() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.copyOf((double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static double[] copyOf(double[] source, int len) {
    final double[] output = new double[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test08387() throws Throwable {
    double[] doubleArray0 = new double[9];
    // Undeclared exception!
    try {
        MathArrays.copyOf(doubleArray0, (-977));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static double[] copyOf(double[] source) {
    return copyOf(source, source.length);
}","public void test08488() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.copyOf((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
    MathUtils.checkNotNull(x);
    MathUtils.checkNotNull(h);
    final int xLen = x.length;
    final int hLen = h.length;
    if (xLen == 0 || hLen == 0) {
        throw new NoDataException();
    }
    // initialize the output array
    final int totalLength = xLen + hLen - 1;
    final double[] y = new double[totalLength];
    // straightforward implementation of the convolution sum
    for (int n = 0; n < totalLength; n++) {
        double yn = 0;
        int k = FastMath.max(0, n + 1 - xLen);
        int j = n - k;
        while (k < hLen && j >= 0) {
            yn += x[j--] * h[k++];
        }
        y[n] = yn;
    }
    return y;
}","public void test08589() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0, 1325);
    // Undeclared exception!
    MathArrays.convolve(doubleArray1, doubleArray1);
}","/**
 * Calculates the <a href=""http://en.wikipedia.org/wiki/Convolution"">
 * convolution</a> between two sequences.
 * The solution is obtained via straightforward computation of the
 * convolution sum (and not via FFT).
 * Whenever the computation needs an element that would be located
 * at an index outside the input arrays, the value is assumed to be
 * zero.
 *
 * @param x First sequence.
 * Typically, this sequence will represent an input signal to a system.
 * @param h Second sequence.
 * Typically, this sequence will represent the impulse response of the
 * system.
 * @return the convolution of {@code x} and {@code h}.
 * This array's length will be {@code x.length + h.length - 1}.
 * @throws NullArgumentException if either {@code x} or {@code h} is
 * {@code null}.
 * @throws NoDataException if either {@code x} or {@code h} is empty.
 *
 * @since 3.3
 */"
"public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
    MathUtils.checkNotNull(in);
    for (int i = 1; i < in.length; i++) {
        if (in[i].length != in[0].length) {
            throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
        }
    }
}","public void test08690() throws Throwable {
    try {
        MathArrays.checkRectangular((long[][]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Throws DimensionMismatchException if the input array is not rectangular.
 *
 * @param in array to be tested
 * @throws NullArgumentException if input array is null
 * @throws DimensionMismatchException if input array is not rectangular
 * @since 3.1
 */"
"public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] <= 0) {
            throw new NotStrictlyPositiveException(in[i]);
        }
    }
}","public void test08791() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.checkPositive((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that all entries of the input array are strictly positive.
 *
 * @param in Array to be tested
 * @throws NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.
 * @since 3.1
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test08892() throws Throwable {
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.checkOrder((double[]) null, mathArrays_OrderDirection0, false, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test08993() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false, false);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
    checkOrder(val, dir, strict, true);
}","public void test09094() throws Throwable {
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    // Undeclared exception!
    try {
        MathArrays.checkOrder((double[]) null, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test09195() throws Throwable {
    double[] doubleArray0 = new double[9];
    try {
        MathArrays.checkOrder(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not strictly increasing (0 >= 0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test09296() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.checkOrder((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test09397() throws Throwable {
    double[] doubleArray0 = new double[0];
    // Undeclared exception!
    try {
        MathArrays.checkOrder(doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static void checkNonNegative(final long[][] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        for (int j = 0; j < in[i].length; j++) {
            if (in[i][j] < 0) {
                throw new NotPositiveException(in[i][j]);
            }
        }
    }
}","public void test09498() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.checkNonNegative((long[][]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"public static void checkNonNegative(final long[] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] < 0) {
            throw new NotPositiveException(in[i]);
        }
    }
}","public void test09599() throws Throwable {
    // Undeclared exception!
    try {
        MathArrays.checkNonNegative((long[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"@SuppressWarnings(""unchecked"")
public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
    final T[][] array;
    if (columns < 0) {
        T[] dummyRow = buildArray(field, 0);
        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
    } else {
        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });
        for (int i = 0; i < rows; ++i) {
            Arrays.fill(array[i], field.getZero());
        }
    }
    return array;
}","public void test096100() throws Throwable {
    Field<Integer> field0 = (Field<Integer>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn((Class) null).when(field0).getRuntimeClass();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, 0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.reflect.Array"", e);
    }
}","/**
 * Build a double dimension  array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param rows number of rows in the array
 * @param columns number of columns (may be negative to build partial
 * arrays in the same way <code>new Field[rows][]</code> works)
 * @return a new array
 * @since 3.2
 */"
"public static <T> T[] buildArray(final Field<T> field, final int length) {
    // OK because field must be correct class
    @SuppressWarnings(""unchecked"")
    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
    Arrays.fill(array, field.getZero());
    return array;
}","public void test097101() throws Throwable {
    Field<Object> field0 = (Field<Object>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn((Class) null).when(field0).getRuntimeClass();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, 2608);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.reflect.Array"", e);
    }
}","/**
 * Build an array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param length of the array
 * @return a new array
 * @since 3.2
 */"
"public static <T> T[] buildArray(final Field<T> field, final int length) {
    // OK because field must be correct class
    @SuppressWarnings(""unchecked"")
    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
    Arrays.fill(array, field.getZero());
    return array;
}","public void test098102() throws Throwable {
    Class<FieldElement> class0 = FieldElement.class;
    Field<Object> field0 = (Field<Object>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, (-969));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.reflect.Array"", e);
    }
}","/**
 * Build an array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param length of the array
 * @return a new array
 * @since 3.2
 */"
"public static <T> T[] buildArray(final Field<T> field, final int length) {
    // OK because field must be correct class
    @SuppressWarnings(""unchecked"")
    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
    Arrays.fill(array, field.getZero());
    return array;
}","public void test099103() throws Throwable {
    Class<FieldElement> class0 = FieldElement.class;
    Double double0 = new Double(3.834E-20);
    FieldElement<Integer> fieldElement0 = (FieldElement<Integer>) mock(FieldElement.class, new ViolatedAssumptionAnswer());
    Pair<Double, FieldElement<Integer>> pair0 = new Pair<Double, FieldElement<Integer>>(double0, fieldElement0);
    Field<Pair<Double, FieldElement<Integer>>> field0 = (Field<Pair<Double, FieldElement<Integer>>>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    doReturn(pair0).when(field0).getZero();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, 3786);
        fail(""Expecting exception: ArrayStoreException"");
    } catch (ArrayStoreException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Build an array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param length of the array
 * @return a new array
 * @since 3.2
 */"
"public static void sortInPlace(double[] x, final OrderDirection dir, double[]... yList) throws NullArgumentException, DimensionMismatchException {
    // Consistency checks.
    if (x == null) {
        throw new NullArgumentException();
    }
    final int yListLen = yList.length;
    final int len = x.length;
    for (int j = 0; j < yListLen; j++) {
        final double[] y = yList[j];
        if (y == null) {
            throw new NullArgumentException();
        }
        if (y.length != len) {
            throw new DimensionMismatchException(y.length, len);
        }
    }
    // Associate each abscissa ""x[i]"" with its index ""i"".
    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);
    for (int i = 0; i < len; i++) {
        list.add(new Pair<Double, Integer>(x[i], i));
    }
    // Create comparators for increasing and decreasing orders.
    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    } : new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o2.getKey().compareTo(o1.getKey());
        }
    };
    // Sort.
    Collections.sort(list, comp);
    // Modify the original array so that its elements are in
    // the prescribed order.
    // Retrieve indices of original locations.
    final int[] indices = new int[len];
    for (int i = 0; i < len; i++) {
        final Pair<Double, Integer> e = list.get(i);
        x[i] = e.getKey();
        indices[i] = e.getValue();
    }
    // In each of the associated arrays, move the
    // elements to their new location.
    for (int j = 0; j < yListLen; j++) {
        // Input array will be modified in place.
        final double[] yInPlace = yList[j];
        final double[] yOrig = yInPlace.clone();
        for (int i = 0; i < len; i++) {
            yInPlace[i] = yOrig[indices[i]];
        }
    }
}","public void test100104() throws Throwable {
    double[] doubleArray0 = new double[1];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    double[][] doubleArray1 = new double[4][4];
    try {
        MathArrays.sortInPlace(doubleArray0, mathArrays_OrderDirection0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4 != 1
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other
 * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}
 * parameter.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param dir Order direction.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null
 * @since 3.0
 */"
"public static void sortInPlace(double[] x, final OrderDirection dir, double[]... yList) throws NullArgumentException, DimensionMismatchException {
    // Consistency checks.
    if (x == null) {
        throw new NullArgumentException();
    }
    final int yListLen = yList.length;
    final int len = x.length;
    for (int j = 0; j < yListLen; j++) {
        final double[] y = yList[j];
        if (y == null) {
            throw new NullArgumentException();
        }
        if (y.length != len) {
            throw new DimensionMismatchException(y.length, len);
        }
    }
    // Associate each abscissa ""x[i]"" with its index ""i"".
    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);
    for (int i = 0; i < len; i++) {
        list.add(new Pair<Double, Integer>(x[i], i));
    }
    // Create comparators for increasing and decreasing orders.
    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    } : new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o2.getKey().compareTo(o1.getKey());
        }
    };
    // Sort.
    Collections.sort(list, comp);
    // Modify the original array so that its elements are in
    // the prescribed order.
    // Retrieve indices of original locations.
    final int[] indices = new int[len];
    for (int i = 0; i < len; i++) {
        final Pair<Double, Integer> e = list.get(i);
        x[i] = e.getKey();
        indices[i] = e.getValue();
    }
    // In each of the associated arrays, move the
    // elements to their new location.
    for (int j = 0; j < yListLen; j++) {
        // Input array will be modified in place.
        final double[] yInPlace = yList[j];
        final double[] yOrig = yInPlace.clone();
        for (int i = 0; i < len; i++) {
            yInPlace[i] = yOrig[indices[i]];
        }
    }
}","public void test101105() throws Throwable {
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    double[][] doubleArray0 = new double[1][5];
    try {
        MathArrays.sortInPlace((double[]) null, mathArrays_OrderDirection0, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other
 * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}
 * parameter.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param dir Order direction.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null
 * @since 3.0
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test102106() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[1] = 599.7;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    try {
        MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 1 and 2 are not increasing (599.7 > 0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
    checkOrder(val, dir, strict, true);
}","public void test103107() throws Throwable {
    double[] doubleArray0 = new double[8];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    try {
        MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 0 and 1 are not strictly decreasing (0 <= 0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
"public static int[] copyOf(int[] source, int len) {
    final int[] output = new int[len];
    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));
    return output;
}","public void test104108() throws Throwable {
    int[] intArray0 = new int[6];
    // Undeclared exception!
    try {
        MathArrays.copyOf(intArray0, (-3361));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @param len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.
 * @return the copied array.
 */"
"public static <T> T[] buildArray(final Field<T> field, final int length) {
    // OK because field must be correct class
    @SuppressWarnings(""unchecked"")
    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
    Arrays.fill(array, field.getZero());
    return array;
}","public void test105109() throws Throwable {
    Class<FieldElement> class0 = FieldElement.class;
    Field<Object> field0 = (Field<Object>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    doReturn((Object) null).when(field0).getZero();
    Object[] objectArray0 = MathArrays.buildArray(field0, 2608);
    assertEquals(2608, objectArray0.length);
}","/**
 * Build an array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param length of the array
 * @return a new array
 * @since 3.2
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test106110() throws Throwable {
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = MathArrays.convolve(doubleArray0, doubleArray0);
    try {
        MathArrays.linearCombination(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4 != 7
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
    MathUtils.checkNotNull(x);
    MathUtils.checkNotNull(h);
    final int xLen = x.length;
    final int hLen = h.length;
    if (xLen == 0 || hLen == 0) {
        throw new NoDataException();
    }
    // initialize the output array
    final int totalLength = xLen + hLen - 1;
    final double[] y = new double[totalLength];
    // straightforward implementation of the convolution sum
    for (int n = 0; n < totalLength; n++) {
        double yn = 0;
        int k = FastMath.max(0, n + 1 - xLen);
        int j = n - k;
        while (k < hLen && j >= 0) {
            yn += x[j--] * h[k++];
        }
        y[n] = yn;
    }
    return y;
}","public void test107111() throws Throwable {
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = new double[0];
    try {
        MathArrays.convolve(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no data
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the <a href=""http://en.wikipedia.org/wiki/Convolution"">
 * convolution</a> between two sequences.
 * The solution is obtained via straightforward computation of the
 * convolution sum (and not via FFT).
 * Whenever the computation needs an element that would be located
 * at an index outside the input arrays, the value is assumed to be
 * zero.
 *
 * @param x First sequence.
 * Typically, this sequence will represent an input signal to a system.
 * @param h Second sequence.
 * Typically, this sequence will represent the impulse response of the
 * system.
 * @return the convolution of {@code x} and {@code h}.
 * This array's length will be {@code x.length + h.length - 1}.
 * @throws NullArgumentException if either {@code x} or {@code h} is
 * {@code null}.
 * @throws NoDataException if either {@code x} or {@code h} is empty.
 *
 * @since 3.3
 */"
"public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
    MathUtils.checkNotNull(x);
    MathUtils.checkNotNull(h);
    final int xLen = x.length;
    final int hLen = h.length;
    if (xLen == 0 || hLen == 0) {
        throw new NoDataException();
    }
    // initialize the output array
    final int totalLength = xLen + hLen - 1;
    final double[] y = new double[totalLength];
    // straightforward implementation of the convolution sum
    for (int n = 0; n < totalLength; n++) {
        double yn = 0;
        int k = FastMath.max(0, n + 1 - xLen);
        int j = n - k;
        while (k < hLen && j >= 0) {
            yn += x[j--] * h[k++];
        }
        y[n] = yn;
    }
    return y;
}","public void test108112() throws Throwable {
    double[] doubleArray0 = new double[0];
    try {
        MathArrays.convolve(doubleArray0, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no data
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Calculates the <a href=""http://en.wikipedia.org/wiki/Convolution"">
 * convolution</a> between two sequences.
 * The solution is obtained via straightforward computation of the
 * convolution sum (and not via FFT).
 * Whenever the computation needs an element that would be located
 * at an index outside the input arrays, the value is assumed to be
 * zero.
 *
 * @param x First sequence.
 * Typically, this sequence will represent an input signal to a system.
 * @param h Second sequence.
 * Typically, this sequence will represent the impulse response of the
 * system.
 * @return the convolution of {@code x} and {@code h}.
 * This array's length will be {@code x.length + h.length - 1}.
 * @throws NullArgumentException if either {@code x} or {@code h} is
 * {@code null}.
 * @throws NoDataException if either {@code x} or {@code h} is empty.
 *
 * @since 3.3
 */"
"@SuppressWarnings(""unchecked"")
public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
    final T[][] array;
    if (columns < 0) {
        T[] dummyRow = buildArray(field, 0);
        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
    } else {
        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });
        for (int i = 0; i < rows; ++i) {
            Arrays.fill(array[i], field.getZero());
        }
    }
    return array;
}","public void test109113() throws Throwable {
    Class<FieldElement> class0 = FieldElement.class;
    Field<Object> field0 = (Field<Object>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    doReturn((Object) null, (Object) null, (Object) null, (Object) null, (Object) null).when(field0).getZero();
    Object[][] objectArray0 = MathArrays.buildArray(field0, 109, 1914);
    assertEquals(109, objectArray0.length);
}","/**
 * Build a double dimension  array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param rows number of rows in the array
 * @param columns number of columns (may be negative to build partial
 * arrays in the same way <code>new Field[rows][]</code> works)
 * @return a new array
 * @since 3.2
 */"
"@SuppressWarnings(""unchecked"")
public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
    final T[][] array;
    if (columns < 0) {
        T[] dummyRow = buildArray(field, 0);
        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
    } else {
        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });
        for (int i = 0; i < rows; ++i) {
            Arrays.fill(array[i], field.getZero());
        }
    }
    return array;
}","public void test110114() throws Throwable {
    double[] doubleArray0 = new double[3];
    Class<FieldElement> class0 = FieldElement.class;
    Field<Double> field0 = (Field<Double>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    doReturn(doubleArray0[0]).when(field0).getZero();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, 241, 241);
        fail(""Expecting exception: ArrayStoreException"");
    } catch (ArrayStoreException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Build a double dimension  array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param rows number of rows in the array
 * @param columns number of columns (may be negative to build partial
 * arrays in the same way <code>new Field[rows][]</code> works)
 * @return a new array
 * @since 3.2
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
    if (Double.isInfinite(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test111115() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = Double.NaN;
    doubleArray0[1] = 468546.3197148148;
    double[] doubleArray1 = MathArrays.normalizeArray(doubleArray0, 3.834E-20);
    assertArrayEquals(new double[] { Double.NaN, 3.834E-20 }, doubleArray1, 0.01);
}","/**
 * Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values Input array to be normalized
 * @param normalizedSum Target sum for the normalized array
 * @return the normalized array.
 * @throws MathArithmeticException if the input array contains infinite
 * elements or sums to zero.
 * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
 * @since 2.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
    if (Double.isInfinite(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test112116() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = Double.NaN;
    try {
        MathArrays.normalizeArray(doubleArray0, 3.834E-20);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // array sums to zero
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values Input array to be normalized
 * @param normalizedSum Target sum for the normalized array
 * @return the normalized array.
 * @throws MathArithmeticException if the input array contains infinite
 * elements or sums to zero.
 * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
 * @since 2.1
 */"
"public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
    if (Double.isInfinite(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
    }
    if (Double.isNaN(normalizedSum)) {
        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
    }
    double sum = 0d;
    final int len = values.length;
    double[] out = new double[len];
    for (int i = 0; i < len; i++) {
        if (Double.isInfinite(values[i])) {
            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
        }
        if (!Double.isNaN(values[i])) {
            sum += values[i];
        }
    }
    if (sum == 0) {
        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
    }
    for (int i = 0; i < len; i++) {
        if (Double.isNaN(values[i])) {
            out[i] = Double.NaN;
        } else {
            out[i] = values[i] * normalizedSum / sum;
        }
    }
    return out;
}","public void test113117() throws Throwable {
    double[] doubleArray0 = new double[4];
    try {
        MathArrays.normalizeArray(doubleArray0, Double.NaN);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot normalize to NaN
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 *    x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 *
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 *
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>
 *
 * @param values Input array to be normalized
 * @param normalizedSum Target sum for the normalized array
 * @return the normalized array.
 * @throws MathArithmeticException if the input array contains infinite
 * elements or sums to zero.
 * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
 * @since 2.1
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test114118() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[1] = 716.96956;
    double[] doubleArray1 = MathArrays.ebeSubtract(doubleArray0, doubleArray0);
    boolean boolean0 = MathArrays.equalsIncludingNaN(doubleArray1, doubleArray0);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test115120() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0, 1325);
    boolean boolean0 = MathArrays.equalsIncludingNaN(doubleArray0, doubleArray1);
    assertEquals(1325, doubleArray1.length);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test116122() throws Throwable {
    double[] doubleArray0 = new double[7];
    boolean boolean0 = MathArrays.equalsIncludingNaN((double[]) null, doubleArray0);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test117123() throws Throwable {
    double[] doubleArray0 = new double[1];
    boolean boolean0 = MathArrays.equalsIncludingNaN(doubleArray0, (double[]) null);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test118124() throws Throwable {
    double[] doubleArray0 = new double[1];
    boolean boolean0 = MathArrays.equalsIncludingNaN(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test119125() throws Throwable {
    boolean boolean0 = MathArrays.equalsIncludingNaN((double[]) null, (double[]) null);
    assertTrue(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 * @since 2.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test120126() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 150;
    double[] doubleArray1 = MathArrays.ebeSubtract(doubleArray0, doubleArray0);
    boolean boolean0 = MathArrays.equals(doubleArray1, doubleArray0);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test121128() throws Throwable {
    double[] doubleArray0 = new double[3];
    boolean boolean0 = MathArrays.equals(doubleArray0, (double[]) null);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test122129() throws Throwable {
    double[] doubleArray0 = new double[4];
    boolean boolean0 = MathArrays.equals(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test123130() throws Throwable {
    boolean boolean0 = MathArrays.equals((double[]) null, (double[]) null);
    assertTrue(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test124131() throws Throwable {
    float[] floatArray0 = new float[8];
    floatArray0[1] = 1762.97F;
    float[] floatArray1 = new float[8];
    boolean boolean0 = MathArrays.equalsIncludingNaN(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test125132() throws Throwable {
    float[] floatArray0 = new float[8];
    boolean boolean0 = MathArrays.equalsIncludingNaN(floatArray0, floatArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test126133() throws Throwable {
    float[] floatArray0 = new float[4];
    float[] floatArray1 = new float[8];
    boolean boolean0 = MathArrays.equalsIncludingNaN(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test127134() throws Throwable {
    boolean boolean0 = MathArrays.equalsIncludingNaN((float[]) null, (float[]) null);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test128135() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = MathArrays.equalsIncludingNaN(floatArray0, (float[]) null);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equalsIncludingNaN(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equalsIncludingNaN(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test129136() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = MathArrays.equalsIncludingNaN((float[]) null, floatArray0);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equalsIncludingNaN(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension and
 * equal elements
 * @since 2.2
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test130137() throws Throwable {
    float[] floatArray0 = new float[7];
    floatArray0[0] = (float) 147;
    float[] floatArray1 = new float[7];
    boolean boolean0 = MathArrays.equals(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test131138() throws Throwable {
    float[] floatArray0 = new float[0];
    float[] floatArray1 = new float[5];
    boolean boolean0 = MathArrays.equals(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test132139() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = MathArrays.equals((float[]) null, floatArray0);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test133140() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = MathArrays.equals(floatArray0, (float[]) null);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test134141() throws Throwable {
    float[] floatArray0 = new float[2];
    boolean boolean0 = MathArrays.equals(floatArray0, floatArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static boolean equals(float[] x, float[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test135142() throws Throwable {
    boolean boolean0 = MathArrays.equals((float[]) null, (float[]) null);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link Precision#equals(float,float)}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // split a4 and b4 as two 26 bits numbers
    final double ca4 = SPLIT_FACTOR * a4;
    final double a4High = ca4 - (ca4 - a4);
    final double a4Low = a4 - a4High;
    final double cb4 = SPLIT_FACTOR * b4;
    final double b4High = cb4 - (cb4 - b4);
    final double b4Low = b4 - b4High;
    // accurate multiplication a4 * b4
    final double prod4High = a4 * b4;
    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4
    final double s1234High = s123High + prod4High;
    final double s1234Prime = s1234High - prod4High;
    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);
    // final rounding, s1234 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;
    }
    return result;
}","public void test136143() throws Throwable {
    double double0 = MathArrays.linearCombination((-940.0194), (-940.0194), Double.NaN, 2466.439, (-4031.26377258), (-940.0194), (-940.0194), (-940.0194));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // split a4 and b4 as two 26 bits numbers
    final double ca4 = SPLIT_FACTOR * a4;
    final double a4High = ca4 - (ca4 - a4);
    final double a4Low = a4 - a4High;
    final double cb4 = SPLIT_FACTOR * b4;
    final double b4High = cb4 - (cb4 - b4);
    final double b4Low = b4 - b4High;
    // accurate multiplication a4 * b4
    final double prod4High = a4 * b4;
    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4
    final double s1234High = s123High + prod4High;
    final double s1234Prime = s1234High - prod4High;
    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);
    // final rounding, s1234 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;
    }
    return result;
}","public void test137144() throws Throwable {
    double double0 = MathArrays.linearCombination(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.32);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // final rounding, s123 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3;
    }
    return result;
}","public void test138145() throws Throwable {
    double double0 = MathArrays.linearCombination(Double.NaN, 0.0, 389.70562938315, 3.834E-20, 389.70562938315, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // do use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variables naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // split a3 and b3 as two 26 bits numbers
    final double ca3 = SPLIT_FACTOR * a3;
    final double a3High = ca3 - (ca3 - a3);
    final double a3Low = a3 - a3High;
    final double cb3 = SPLIT_FACTOR * b3;
    final double b3High = cb3 - (cb3 - b3);
    final double b3Low = b3 - b3High;
    // accurate multiplication a3 * b3
    final double prod3High = a3 * b3;
    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // accurate addition a1 * b1 + a2 * b2 + a3 * b3
    final double s123High = s12High + prod3High;
    final double s123Prime = s123High - prod3High;
    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);
    // final rounding, s123 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2 + a3 * b3;
    }
    return result;
}","public void test139146() throws Throwable {
    double double0 = MathArrays.linearCombination(0.0, 1.304E19, 0.0, (-2064.40309500868), (-2064.40309500868), 1.304E19);
    assertEquals((-2.6919816358913188E22), double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * @see #linearCombination(double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variable naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // final rounding, s12 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s12High + (prod1Low + prod2Low + s12Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2;
    }
    return result;
}","public void test140147() throws Throwable {
    double double0 = MathArrays.linearCombination(1.0, (double) 150, 1.34217729E8, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub>
 * @see #linearCombination(double, double, double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double a1, final double b1, final double a2, final double b2) {
    // the code below is split in many additions/subtractions that may
    // appear redundant. However, they should NOT be simplified, as they
    // use IEEE754 floating point arithmetic rounding properties.
    // as an example, the expression ""ca1 - (ca1 - a1)"" is NOT the same as ""a1""
    // The variable naming conventions are that xyzHigh contains the most significant
    // bits of xyz and xyzLow contains its least significant bits. So theoretically
    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
    // be represented in only one double precision number so we preserve two numbers
    // to hold it as long as we can, combining the high and low order bits together
    // only at the end, after cancellation may have occurred on high order bits
    // split a1 and b1 as two 26 bits numbers
    final double ca1 = SPLIT_FACTOR * a1;
    final double a1High = ca1 - (ca1 - a1);
    final double a1Low = a1 - a1High;
    final double cb1 = SPLIT_FACTOR * b1;
    final double b1High = cb1 - (cb1 - b1);
    final double b1Low = b1 - b1High;
    // accurate multiplication a1 * b1
    final double prod1High = a1 * b1;
    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);
    // split a2 and b2 as two 26 bits numbers
    final double ca2 = SPLIT_FACTOR * a2;
    final double a2High = ca2 - (ca2 - a2);
    final double a2Low = a2 - a2High;
    final double cb2 = SPLIT_FACTOR * b2;
    final double b2High = cb2 - (cb2 - b2);
    final double b2Low = b2 - b2High;
    // accurate multiplication a2 * b2
    final double prod2High = a2 * b2;
    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);
    // accurate addition a1 * b1 + a2 * b2
    final double s12High = prod1High + prod2High;
    final double s12Prime = s12High - prod2High;
    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);
    // final rounding, s12 may have suffered many cancellations, we try
    // to recover some bits from the extra words we have saved up to now
    double result = s12High + (prod1Low + prod2Low + s12Low);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = a1 * b1 + a2 * b2;
    }
    return result;
}","public void test141148() throws Throwable {
    double double0 = MathArrays.linearCombination(0.0, (double) 0, 333.279, (double) 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub>
 * @see #linearCombination(double, double, double, double, double, double)
 * @see #linearCombination(double, double, double, double, double, double, double, double)
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test142149() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = Double.POSITIVE_INFINITY;
    double double0 = MathArrays.linearCombination(doubleArray0, doubleArray0);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test143150() throws Throwable {
    double[] doubleArray0 = new double[8];
    double double0 = MathArrays.linearCombination(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","public void test144151() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0, 1);
    try {
        MathArrays.linearCombination(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8 != 1
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */"
"public static void sortInPlace(double[] x, final OrderDirection dir, double[]... yList) throws NullArgumentException, DimensionMismatchException {
    // Consistency checks.
    if (x == null) {
        throw new NullArgumentException();
    }
    final int yListLen = yList.length;
    final int len = x.length;
    for (int j = 0; j < yListLen; j++) {
        final double[] y = yList[j];
        if (y == null) {
            throw new NullArgumentException();
        }
        if (y.length != len) {
            throw new DimensionMismatchException(y.length, len);
        }
    }
    // Associate each abscissa ""x[i]"" with its index ""i"".
    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);
    for (int i = 0; i < len; i++) {
        list.add(new Pair<Double, Integer>(x[i], i));
    }
    // Create comparators for increasing and decreasing orders.
    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    } : new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o2.getKey().compareTo(o1.getKey());
        }
    };
    // Sort.
    Collections.sort(list, comp);
    // Modify the original array so that its elements are in
    // the prescribed order.
    // Retrieve indices of original locations.
    final int[] indices = new int[len];
    for (int i = 0; i < len; i++) {
        final Pair<Double, Integer> e = list.get(i);
        x[i] = e.getKey();
        indices[i] = e.getValue();
    }
    // In each of the associated arrays, move the
    // elements to their new location.
    for (int j = 0; j < yListLen; j++) {
        // Input array will be modified in place.
        final double[] yInPlace = yList[j];
        final double[] yOrig = yInPlace.clone();
        for (int i = 0; i < len; i++) {
            yInPlace[i] = yOrig[indices[i]];
        }
    }
}","public void test145152() throws Throwable {
    double[] doubleArray0 = new double[1];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    double[][] doubleArray1 = new double[6][0];
    doubleArray1[0] = null;
    try {
        MathArrays.sortInPlace(doubleArray0, mathArrays_OrderDirection0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other
 * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}
 * parameter.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param dir Order direction.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null
 * @since 3.0
 */"
"public static void sortInPlace(double[] x, double[]... yList) throws DimensionMismatchException, NullArgumentException {
    sortInPlace(x, OrderDirection.INCREASING, yList);
}","public void test146153() throws Throwable {
    try {
        MathArrays.sortInPlace((double[]) null, (double[][]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if
 * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then
 * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},
 * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null.
 * @since 3.0
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test147154() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 3.834E-20;
    double[] doubleArray1 = MathArrays.ebeMultiply(doubleArray0, doubleArray0);
    double double0 = MathArrays.safeNorm(doubleArray1);
    assertEquals(1.4699556E-39, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test148155() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 1.304E19;
    doubleArray0[2] = 1.304E19;
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(1.8441344853345161E19, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test149156() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = Double.NaN;
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static double safeNorm(double[] v) {
    double rdwarf = 3.834e-20;
    double rgiant = 1.304e+19;
    double s1 = 0;
    double s2 = 0;
    double s3 = 0;
    double x1max = 0;
    double x3max = 0;
    double floatn = v.length;
    double agiant = rgiant / floatn;
    for (int i = 0; i < v.length; i++) {
        double xabs = Math.abs(v[i]);
        if (xabs < rdwarf || xabs > agiant) {
            if (xabs > rdwarf) {
                if (xabs > x1max) {
                    double r = x1max / xabs;
                    s1 = 1 + s1 * r * r;
                    x1max = xabs;
                } else {
                    double r = xabs / x1max;
                    s1 += r * r;
                }
            } else {
                if (xabs > x3max) {
                    double r = x3max / xabs;
                    s3 = 1 + s3 * r * r;
                    x3max = xabs;
                } else {
                    if (xabs != 0) {
                        double r = xabs / x3max;
                        s3 += r * r;
                    }
                }
            }
        } else {
            s2 += xabs * xabs;
        }
    }
    double norm;
    if (s1 != 0) {
        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);
    } else {
        if (s2 == 0) {
            norm = x3max * Math.sqrt(s3);
        } else {
            if (s2 >= x3max) {
                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
            } else {
                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
            }
        }
    }
    return norm;
}","public void test150157() throws Throwable {
    double[] doubleArray0 = new double[9];
    double double0 = MathArrays.safeNorm(doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 *
 * The redistribution policy for MINPACK is available
 * <a href=""http://www.netlib.org/minpack/disclaimer"">here</a>, for
 * convenience, it is reproduced below.</p>
 *
 * <table border=""0"" width=""80%"" cellpadding=""10"" align=""center"" bgcolor=""#E0E0E0"">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     {@code This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.}
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED ""AS IS""
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @param v Vector of doubles.
 * @return the 2-norm of the vector.
 * @since 2.2
 */"
"public static void checkNonNegative(final long[][] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        for (int j = 0; j < in[i].length; j++) {
            if (in[i][j] < 0) {
                throw new NotPositiveException(in[i][j]);
            }
        }
    }
}","public void test151158() throws Throwable {
    long[][] longArray0 = new long[2][0];
    long[] longArray1 = new long[8];
    longArray1[2] = (-2715L);
    longArray0[0] = longArray1;
    try {
        MathArrays.checkNonNegative(longArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -2,715 is smaller than the minimum (0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"public static void checkNonNegative(final long[] in) throws NotPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] < 0) {
            throw new NotPositiveException(in[i]);
        }
    }
}","public void test152159() throws Throwable {
    long[] longArray0 = new long[4];
    longArray0[2] = (-1442L);
    try {
        MathArrays.checkNonNegative(longArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1,442 is smaller than the minimum (0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that all entries of the input array are >= 0.
 *
 * @param in Array to be tested
 * @throws NotPositiveException if any array entries are less than 0.
 * @since 3.1
 */"
"public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] <= 0) {
            throw new NotStrictlyPositiveException(in[i]);
        }
    }
}","public void test153160() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 1.1902911999999998E39;
    try {
        MathArrays.checkPositive(doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that all entries of the input array are strictly positive.
 *
 * @param in Array to be tested
 * @throws NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.
 * @since 3.1
 */"
"public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
    for (int i = 0; i < in.length; i++) {
        if (in[i] <= 0) {
            throw new NotStrictlyPositiveException(in[i]);
        }
    }
}","public void test154161() throws Throwable {
    double[] doubleArray0 = new double[0];
    MathArrays.checkPositive(doubleArray0);
    assertArrayEquals(new double[] {}, doubleArray0, 0.01);
}","/**
 * Check that all entries of the input array are strictly positive.
 *
 * @param in Array to be tested
 * @throws NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.
 * @since 3.1
 */"
"public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
    MathUtils.checkNotNull(in);
    for (int i = 1; i < in.length; i++) {
        if (in[i].length != in[0].length) {
            throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
        }
    }
}","public void test155162() throws Throwable {
    long[][] longArray0 = new long[8][4];
    long[] longArray1 = new long[9];
    longArray0[0] = longArray1;
    try {
        MathArrays.checkRectangular(longArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // some rows have length 4 while others have length 9
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Throws DimensionMismatchException if the input array is not rectangular.
 *
 * @param in array to be tested
 * @throws NullArgumentException if input array is null
 * @throws DimensionMismatchException if input array is not rectangular
 * @since 3.1
 */"
"public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
    MathUtils.checkNotNull(in);
    for (int i = 1; i < in.length; i++) {
        if (in[i].length != in[0].length) {
            throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
        }
    }
}","public void test156163() throws Throwable {
    long[][] longArray0 = new long[2][4];
    MathArrays.checkRectangular(longArray0);
    assertEquals(2, longArray0.length);
}","/**
 * Throws DimensionMismatchException if the input array is not rectangular.
 *
 * @param in array to be tested
 * @throws NullArgumentException if input array is null
 * @throws DimensionMismatchException if input array is not rectangular
 * @since 3.1
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test157164() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[1] = (double) (-628);
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false, false);
    assertFalse(boolean0);
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test158165() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 179;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, true, false);
    assertFalse(boolean0);
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
    return checkOrder(val, dir, strict, false);
}","public void test159166() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 179;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    boolean boolean0 = MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, false);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test160167() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 1.304E19;
    doubleArray0[2] = 1.304E19;
    doubleArray0[3] = 1.304E19;
    doubleArray0[4] = 1.304E19;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    double[][] doubleArray1 = new double[4][8];
    doubleArray1[0] = doubleArray0;
    doubleArray1[1] = doubleArray0;
    doubleArray1[2] = doubleArray0;
    doubleArray1[3] = doubleArray0;
    MathArrays.sortInPlace(doubleArray0, mathArrays_OrderDirection0, doubleArray1);
    try {
        MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, true, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // points 1 and 2 are not strictly increasing (13,040,000,000,000,000,000 >= 0)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test161168() throws Throwable {
    double[] doubleArray0 = new double[2];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    boolean boolean0 = MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false, false);
    assertTrue(boolean0);
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
    double previous = val[0];
    final int max = val.length;
    int index;
    ITEM: for (index = 1; index < max; index++) {
        switch(dir) {
            case INCREASING:
                if (strict) {
                    if (val[index] <= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] < previous) {
                        break ITEM;
                    }
                }
                break;
            case DECREASING:
                if (strict) {
                    if (val[index] >= previous) {
                        break ITEM;
                    }
                } else {
                    if (val[index] > previous) {
                        break ITEM;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[index];
    }
    if (index == max) {
        // Loop completed.
        return true;
    }
    // Loop early exit means wrong ordering.
    if (abort) {
        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
    } else {
        return false;
    }
}","public void test162169() throws Throwable {
    double[] doubleArray0 = new double[2];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.checkOrder(doubleArray0, mathArrays_OrderDirection0, false, false);
    assertTrue(boolean0);
}","/**
 * Check that the given array is sorted.
 *
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @param abort Whether to throw an exception if the check fails.
 * @return {@code true} if the array is sorted.
 * @throws NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test163170() throws Throwable {
    Integer[] integerArray0 = new Integer[6];
    Integer integer0 = new Integer(1319);
    integerArray0[0] = integer0;
    Integer integer1 = new Integer(206);
    integerArray0[1] = integer1;
    integerArray0[2] = integerArray0[0];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.isMonotonic(integerArray0, mathArrays_OrderDirection0, false);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test164171() throws Throwable {
    String[] stringArray0 = new String[9];
    stringArray0[0] = ""number of elements should be positive ({0})"";
    stringArray0[1] = ""7p#q|m7c]#<BcH+^y"";
    stringArray0[2] = ""0wvZ;11}"";
    stringArray0[3] = ""}Q??yHm xO"";
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    boolean boolean0 = MathArrays.isMonotonic(stringArray0, mathArrays_OrderDirection0, true);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test165172() throws Throwable {
    String[] stringArray0 = new String[9];
    stringArray0[0] = ""number of elements should be positive ({0})"";
    stringArray0[1] = ""7p#q|m7c]#<BcH+^y"";
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.isMonotonic(stringArray0, mathArrays_OrderDirection0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test166173() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    doubleArray0[0] = (Double) 1.34217729E8;
    doubleArray0[1] = (Double) 1.34217729E8;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    // Undeclared exception!
    try {
        MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test167174() throws Throwable {
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    String[] stringArray0 = new String[6];
    stringArray0[0] = """";
    stringArray0[1] = """";
    stringArray0[2] = """";
    stringArray0[3] = ""dk"";
    stringArray0[4] = "";Fk"";
    boolean boolean0 = MathArrays.isMonotonic(stringArray0, mathArrays_OrderDirection0, false);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test168175() throws Throwable {
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""2~G8wy:3bctW0"";
    stringArray0[2] = "",,0\"""";
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    boolean boolean0 = MathArrays.isMonotonic(stringArray0, mathArrays_OrderDirection0, true);
    assertFalse(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
    T previous = val[0];
    final int max = val.length;
    for (int i = 1; i < max; i++) {
        final int comp;
        switch(dir) {
            case INCREASING:
                comp = previous.compareTo(val[i]);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            case DECREASING:
                comp = val[i].compareTo(previous);
                if (strict) {
                    if (comp >= 0) {
                        return false;
                    }
                } else {
                    if (comp > 0) {
                        return false;
                    }
                }
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        previous = val[i];
    }
    return true;
}","public void test169176() throws Throwable {
    Double[] doubleArray0 = new Double[5];
    doubleArray0[0] = (Double) 1.1902911999999998E39;
    doubleArray0[1] = (Double) 1.1902911999999998E39;
    doubleArray0[2] = (Double) 1.1902911999999998E39;
    doubleArray0[3] = (Double) 1.1902911999999998E39;
    doubleArray0[4] = (Double) 1.1902911999999998E39;
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.INCREASING;
    boolean boolean0 = MathArrays.isMonotonic(doubleArray0, mathArrays_OrderDirection0, false);
    assertTrue(boolean0);
}","/**
 * Check that an array is monotonically increasing or decreasing.
 *
 * @param <T> the type of the elements in the specified array
 * @param val Values.
 * @param dir Ordering direction.
 * @param strict Whether the order should be strict.
 * @return {@code true} if sorted, {@code false} otherwise.
 */"
"public static double distanceInf(double[] p1, double[] p2) {
    double max = 0;
    for (int i = 0; i < p1.length; i++) {
        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
    }
    return max;
}","public void test170177() throws Throwable {
    double[] doubleArray0 = new double[2];
    double double0 = MathArrays.distanceInf(doubleArray0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>&infin;</sub> distance between the two points
 */"
"public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return FastMath.sqrt(sum);
}","public void test171178() throws Throwable {
    int[] intArray0 = new int[2];
    double double0 = MathArrays.distance(intArray0, intArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */"
"public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] /= b[i];
    }
    return result;
}","public void test172179() throws Throwable {
    double[] doubleArray0 = new double[2];
    double[] doubleArray1 = new double[5];
    try {
        MathArrays.ebeDivide(doubleArray1, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 5 != 2
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.
 *
 * @param a Numerator of the division.
 * @param b Denominator of the division.
 * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!Precision.equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test173180() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = MathArrays.ebeDivide(doubleArray0, doubleArray0);
    double[] doubleArray2 = new double[9];
    boolean boolean0 = MathArrays.equals(doubleArray1, doubleArray2);
    assertFalse(boolean0);
}","/**
 * Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by
 * {@link Precision#equals(double,double)}.
 *
 * @param x First array.
 * @param y Second array.
 * @return {@code true} if the values are both {@code null} or have same
 * dimension and equal elements.
 */"
"public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] *= b[i];
    }
    return result;
}","public void test174182() throws Throwable {
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = new double[2];
    try {
        MathArrays.ebeMultiply(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 7 != 2
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.
 *
 * @param a First factor of the multiplication.
 * @param b Second factor of the multiplication.
 * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] -= b[i];
    }
    return result;
}","public void test175183() throws Throwable {
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = new double[0];
    try {
        MathArrays.ebeSubtract(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4 != 0
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.
 *
 * @param a First term.
 * @param b Element to be subtracted.
 * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
    if (a.length != b.length) {
        throw new DimensionMismatchException(a.length, b.length);
    }
    final double[] result = a.clone();
    for (int i = 0; i < a.length; i++) {
        result[i] += b[i];
    }
    return result;
}","public void test176184() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = new double[6];
    try {
        MathArrays.ebeAdd(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8 != 6
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Creates an array whose contents will be the element-by-element
 * addition of the arguments.
 *
 * @param a First term of the addition.
 * @param b Second term of the addition.
 * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
 * @throws DimensionMismatchException if the array lengths differ.
 * @since 3.1
 */"
"public static void sortInPlace(double[] x, final OrderDirection dir, double[]... yList) throws NullArgumentException, DimensionMismatchException {
    // Consistency checks.
    if (x == null) {
        throw new NullArgumentException();
    }
    final int yListLen = yList.length;
    final int len = x.length;
    for (int j = 0; j < yListLen; j++) {
        final double[] y = yList[j];
        if (y == null) {
            throw new NullArgumentException();
        }
        if (y.length != len) {
            throw new DimensionMismatchException(y.length, len);
        }
    }
    // Associate each abscissa ""x[i]"" with its index ""i"".
    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);
    for (int i = 0; i < len; i++) {
        list.add(new Pair<Double, Integer>(x[i], i));
    }
    // Create comparators for increasing and decreasing orders.
    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    } : new Comparator<Pair<Double, Integer>>() {

        public int compare(Pair<Double, Integer> o1, Pair<Double, Integer> o2) {
            return o2.getKey().compareTo(o1.getKey());
        }
    };
    // Sort.
    Collections.sort(list, comp);
    // Modify the original array so that its elements are in
    // the prescribed order.
    // Retrieve indices of original locations.
    final int[] indices = new int[len];
    for (int i = 0; i < len; i++) {
        final Pair<Double, Integer> e = list.get(i);
        x[i] = e.getKey();
        indices[i] = e.getValue();
    }
    // In each of the associated arrays, move the
    // elements to their new location.
    for (int j = 0; j < yListLen; j++) {
        // Input array will be modified in place.
        final double[] yInPlace = yList[j];
        final double[] yOrig = yInPlace.clone();
        for (int i = 0; i < len; i++) {
            yInPlace[i] = yOrig[indices[i]];
        }
    }
}","public void test177185() throws Throwable {
    double[] doubleArray0 = new double[2];
    MathArrays.OrderDirection mathArrays_OrderDirection0 = MathArrays.OrderDirection.DECREASING;
    double[][] doubleArray1 = new double[0][1];
    MathArrays.sortInPlace(doubleArray0, mathArrays_OrderDirection0, doubleArray1);
    assertEquals(2, doubleArray0.length);
}","/**
 * Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other
 * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}
 * parameter.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param dir Order direction.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null
 * @since 3.0
 */"
"public static void sortInPlace(double[] x, double[]... yList) throws DimensionMismatchException, NullArgumentException {
    sortInPlace(x, OrderDirection.INCREASING, yList);
}","public void test178186() throws Throwable {
    double[] doubleArray0 = new double[3];
    double[][] doubleArray1 = new double[3][2];
    doubleArray1[0] = doubleArray0;
    doubleArray1[1] = doubleArray0;
    doubleArray1[2] = doubleArray0;
    MathArrays.sortInPlace(doubleArray0, doubleArray1);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if
 * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then
 * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},
 * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null.
 * @since 3.0
 */"
"public static void sortInPlace(double[] x, double[]... yList) throws DimensionMismatchException, NullArgumentException {
    sortInPlace(x, OrderDirection.INCREASING, yList);
}","public void test179187() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[][] doubleArray1 = new double[4][6];
    try {
        MathArrays.sortInPlace(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 8
        //
        verifyException(""org.apache.commons.math3.util.MathArrays"", e);
    }
}","/**
 * Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if
 * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then
 * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},
 * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.
 *
 * @param x Array to be sorted and used as a pattern for permutation
 * of the other arrays.
 * @param yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.
 * @throws DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.
 * @throws NullArgumentException if {@code x} or any {@code y} is null.
 * @since 3.0
 */"
"public static int[] copyOf(int[] source) {
    return copyOf(source, source.length);
}","public void test180188() throws Throwable {
    int[] intArray0 = new int[1];
    int[] intArray1 = MathArrays.copyOf(intArray0);
    assertNotSame(intArray1, intArray0);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"@SuppressWarnings(""unchecked"")
public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
    final T[][] array;
    if (columns < 0) {
        T[] dummyRow = buildArray(field, 0);
        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
    } else {
        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });
        for (int i = 0; i < rows; ++i) {
            Arrays.fill(array[i], field.getZero());
        }
    }
    return array;
}","public void test181190() throws Throwable {
    Class<FieldElement> class0 = FieldElement.class;
    Field<FieldElement<Integer>> field0 = (Field<FieldElement<Integer>>) mock(Field.class, new ViolatedAssumptionAnswer());
    doReturn(class0).when(field0).getRuntimeClass();
    doReturn((Object) null).when(field0).getZero();
    // Undeclared exception!
    try {
        MathArrays.buildArray(field0, (-1570), (-13));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.reflect.Array"", e);
    }
}","/**
 * Build a double dimension  array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p>
 * @param <T> the type of the field elements
 * @param field field to which array elements belong
 * @param rows number of rows in the array
 * @param columns number of columns (may be negative to build partial
 * arrays in the same way <code>new Field[rows][]</code> works)
 * @return a new array
 * @since 3.2
 */"
"public static double[] copyOf(double[] source) {
    return copyOf(source, source.length);
}","public void test182191() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = MathArrays.copyOf(doubleArray0);
    assertNotSame(doubleArray1, doubleArray0);
}","/**
 * Creates a copy of the {@code source} array.
 *
 * @param source Array to be copied.
 * @return the copied array.
 */"
"public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
    checkOrder(val, OrderDirection.INCREASING, true);
}","public void test183193() throws Throwable {
    double[] doubleArray0 = new double[1];
    MathArrays.checkOrder(doubleArray0);
    assertArrayEquals(new double[] { 0.0 }, doubleArray0, 0.01);
}","/**
 * Check that the given array is sorted in strictly increasing order.
 *
 * @param val Values.
 * @throws NonMonotonicSequenceException if the array is not sorted.
 * @since 2.2
 */"
