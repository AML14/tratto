focal_method,test_prefix,docstring
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test000() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(59.48167924, 59.48167924, 97);
    double double0 = poissonDistributionImpl0.cumulativeProbability(0);
    assertEquals(1.4703980961654014E-26, double0, 0.01);
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"public double getMean() {
    return mean;
}","public void test011() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(0.030589580535888672);
    double double0 = poissonDistributionImpl0.probability(1548);
    assertEquals(0.030589580535888672, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double probability(int x) {
    double ret;
    if (x < 0 || x == Integer.MAX_VALUE) {
        ret = 0.0;
    } else if (x == 0) {
        ret = FastMath.exp(-mean);
    } else {
        ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) / FastMath.sqrt(MathUtils.TWO_PI * x);
    }
    return ret;
}","public void test012() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(0.030589580535888672);
    double double0 = poissonDistributionImpl0.probability(1548);
    assertEquals(0.0, double0, 0.01);
}","/**
 * The probability mass function P(X = x) for a Poisson distribution.
 *
 * @param x the value at which the probability density function is
 *            evaluated.
 * @return the value of the probability mass function at x
 */"
"@Override
public int sample() throws MathException {
    return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);
}","public void test023() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(4.9E-324, 4.9E-324, 32767);
    int int0 = poissonDistributionImpl0.sample();
    assertEquals(0, int0);
}","/**
 * Generates a random value sampled from this distribution.
 *
 * <p><strong>Algorithm Description</strong>:
 * <ul><li> For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * <a href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li><
 *
 * <li> For large means, uses the rejection algorithm described in <br/>
 * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>
 * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>
 *
 * @return random value
 * @since 2.2
 * @throws MathException if an error occurs generating the random value
 */"
"public double getMean() {
    return mean;
}","public void test024() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(4.9E-324, 4.9E-324, 32767);
    int int0 = poissonDistributionImpl0.sample();
    assertEquals(4.9E-324, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double normalApproximateProbability(int x) throws MathException {
    // calculate the probability using half-correction
    return normal.cumulativeProbability(x + 0.5);
}","public void test035() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1151.89, 1151.89);
    double double0 = poissonDistributionImpl0.normalApproximateProbability(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Calculates the Poisson distribution function using a normal
 * approximation. The <code>N(mean, sqrt(mean))</code> distribution is used
 * to approximate the Poisson distribution.
 * <p>
 * The computation uses ""half-correction"" -- evaluating the normal
 * distribution function at <code>x + 0.5</code>
 * </p>
 *
 * @param x the upper bound, inclusive
 * @return the distribution function value calculated using a normal
 *         approximation
 * @throws MathException if an error occurs computing the normal
 *             approximation
 */"
"public double getMean() {
    return mean;
}","public void test036() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1151.89, 1151.89);
    double double0 = poissonDistributionImpl0.normalApproximateProbability(0);
    assertEquals(1151.89, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double normalApproximateProbability(int x) throws MathException {
    // calculate the probability using half-correction
    return normal.cumulativeProbability(x + 0.5);
}","public void test047() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(4.9E-324, 4.9E-324, 32767);
    try {
        poissonDistributionImpl0.normalApproximateProbability(0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Continued fraction diverged to NaN for value \u221E
        //
        verifyException(""org.apache.commons.math.util.ContinuedFraction"", e);
    }
}","/**
 * Calculates the Poisson distribution function using a normal
 * approximation. The <code>N(mean, sqrt(mean))</code> distribution is used
 * to approximate the Poisson distribution.
 * <p>
 * The computation uses ""half-correction"" -- evaluating the normal
 * distribution function at <code>x + 0.5</code>
 * </p>
 *
 * @param x the upper bound, inclusive
 * @return the distribution function value calculated using a normal
 *         approximation
 * @throws MathException if an error occurs computing the normal
 *             approximation
 */"
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test058() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(5.650007086920087E-9, (double) (-17));
    // Undeclared exception!
    poissonDistributionImpl0.cumulativeProbability(2396);
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test069() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(2322.1383677551, (-1425.3620083599687));
    try {
        poissonDistributionImpl0.cumulativeProbability(95);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Continued fraction diverged to NaN for value 2,322.138
        //
        verifyException(""org.apache.commons.math.util.ContinuedFraction"", e);
    }
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test0710() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(5.650007086920087E-9, 5.650007086920087E-9, 0);
    try {
        poissonDistributionImpl0.cumulativeProbability(2396);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // maximal number of iterations (0) exceeded
        //
        verifyException(""org.apache.commons.math.special.Gamma"", e);
    }
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"public PoissonDistributionImpl(double p, int maxIterations) {
    this(p, DEFAULT_EPSILON, maxIterations);
}","public void test0811() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = null;
    try {
        poissonDistributionImpl0 = new PoissonDistributionImpl((-2289.0505632029985), (-36));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // the Poisson mean must be positive (-2,289.051)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a new Poisson distribution with the given mean and maximum number of iterations.
 *
 * @param p the Poisson mean
 * @param maxIterations the maximum number of iterations for cumulative probabilites
 * @since 2.1
 */"
"public PoissonDistributionImpl(double p) {
    this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);
}","public void test0912() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = null;
    try {
        poissonDistributionImpl0 = new PoissonDistributionImpl(0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // the Poisson mean must be positive (0)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a new Poisson distribution with the given the mean. The mean value
 * must be positive; otherwise an <code>IllegalArgument</code> is thrown.
 *
 * @param p the Poisson mean
 * @throws IllegalArgumentException if p &le; 0
 */"
"public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
    if (p <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
    }
    mean = p;
    normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
    this.epsilon = epsilon;
    this.maxIterations = maxIterations;
}","public void test1013() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = null;
    try {
        poissonDistributionImpl0 = new PoissonDistributionImpl((-1067.2315), 0.0, 10000000);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // the Poisson mean must be positive (-1,067.232)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a new Poisson distribution with the given mean, convergence criterion
 * and maximum number of iterations.
 *
 * @param p the Poisson mean
 * @param epsilon the convergence criteria for cumulative probabilites
 * @param maxIterations the maximum number of iterations for cumulative probabilites
 * @since 2.1
 */"
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test1114() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.cumulativeProbability(Integer.MAX_VALUE);
    assertEquals(1.0, double0, 0.01);
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"public double getMean() {
    return mean;
}","public void test1115() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.cumulativeProbability(Integer.MAX_VALUE);
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"@Override
public double cumulativeProbability(int x) throws MathException {
    if (x < 0) {
        return 0;
    }
    if (x == Integer.MAX_VALUE) {
        return 1;
    }
    return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);
}","public void test1216() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.cumulativeProbability((-603));
    assertEquals(0.0, double0, 0.01);
}","/**
 * The probability distribution function P(X <= x) for a Poisson
 * distribution.
 *
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computed
 *             due to convergence or other numerical errors.
 */"
"public double getMean() {
    return mean;
}","public void test1217() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.cumulativeProbability((-603));
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double probability(int x) {
    double ret;
    if (x < 0 || x == Integer.MAX_VALUE) {
        ret = 0.0;
    } else if (x == 0) {
        ret = FastMath.exp(-mean);
    } else {
        ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) / FastMath.sqrt(MathUtils.TWO_PI * x);
    }
    return ret;
}","public void test1318() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl((double) 5775, 5775);
    double double0 = poissonDistributionImpl0.probability(5775);
    assertEquals(0.005249619238996912, double0, 0.01);
}","/**
 * The probability mass function P(X = x) for a Poisson distribution.
 *
 * @param x the value at which the probability density function is
 *            evaluated.
 * @return the value of the probability mass function at x
 */"
"public double getMean() {
    return mean;
}","public void test1419() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.probability(Integer.MAX_VALUE);
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double probability(int x) {
    double ret;
    if (x < 0 || x == Integer.MAX_VALUE) {
        ret = 0.0;
    } else if (x == 0) {
        ret = FastMath.exp(-mean);
    } else {
        ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) / FastMath.sqrt(MathUtils.TWO_PI * x);
    }
    return ret;
}","public void test1420() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.probability(Integer.MAX_VALUE);
    assertEquals(0.0, double0, 0.01);
}","/**
 * The probability mass function P(X = x) for a Poisson distribution.
 *
 * @param x the value at which the probability density function is
 *            evaluated.
 * @return the value of the probability mass function at x
 */"
"public double probability(int x) {
    double ret;
    if (x < 0 || x == Integer.MAX_VALUE) {
        ret = 0.0;
    } else if (x == 0) {
        ret = FastMath.exp(-mean);
    } else {
        ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) / FastMath.sqrt(MathUtils.TWO_PI * x);
    }
    return ret;
}","public void test1521() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.probability(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * The probability mass function P(X = x) for a Poisson distribution.
 *
 * @param x the value at which the probability density function is
 *            evaluated.
 * @return the value of the probability mass function at x
 */"
"public double probability(int x) {
    double ret;
    if (x < 0 || x == Integer.MAX_VALUE) {
        ret = 0.0;
    } else if (x == 0) {
        ret = FastMath.exp(-mean);
    } else {
        ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) / FastMath.sqrt(MathUtils.TWO_PI * x);
    }
    return ret;
}","public void test1622() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(853.1);
    double double0 = poissonDistributionImpl0.probability((-278));
    assertEquals(0.0, double0, 0.01);
}","/**
 * The probability mass function P(X = x) for a Poisson distribution.
 *
 * @param x the value at which the probability density function is
 *            evaluated.
 * @return the value of the probability mass function at x
 */"
"public double getMean() {
    return mean;
}","public void test1623() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(853.1);
    double double0 = poissonDistributionImpl0.probability((-278));
    assertEquals(853.1, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public PoissonDistributionImpl(double p, double epsilon) {
    this(p, epsilon, DEFAULT_MAX_ITERATIONS);
}","public void test1724() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = null;
    try {
        poissonDistributionImpl0 = new PoissonDistributionImpl((-278.599), (-278.599));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // the Poisson mean must be positive (-278.599)
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a new Poisson distribution with the given mean and convergence criterion.
 *
 * @param p the Poisson mean
 * @param epsilon the convergence criteria for cumulative probabilites
 * @since 2.1
 */"
"public double getMean() {
    return mean;
}","public void test1825() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.normalApproximateProbability(1439);
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"public double normalApproximateProbability(int x) throws MathException {
    // calculate the probability using half-correction
    return normal.cumulativeProbability(x + 0.5);
}","public void test1826() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    double double0 = poissonDistributionImpl0.normalApproximateProbability(1439);
    assertEquals(0.6198328899546514, double0, 0.01);
}","/**
 * Calculates the Poisson distribution function using a normal
 * approximation. The <code>N(mean, sqrt(mean))</code> distribution is used
 * to approximate the Poisson distribution.
 * <p>
 * The computation uses ""half-correction"" -- evaluating the normal
 * distribution function at <code>x + 0.5</code>
 * </p>
 *
 * @param x the upper bound, inclusive
 * @return the distribution function value calculated using a normal
 *         approximation
 * @throws MathException if an error occurs computing the normal
 *             approximation
 */"
"@Override
public int sample() throws MathException {
    return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);
}","public void test1927() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(2097151, 543.590923799);
    // Undeclared exception!
    poissonDistributionImpl0.sample();
}","/**
 * Generates a random value sampled from this distribution.
 *
 * <p><strong>Algorithm Description</strong>:
 * <ul><li> For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * <a href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li><
 *
 * <li> For large means, uses the rejection algorithm described in <br/>
 * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>
 * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>
 *
 * @return random value
 * @since 2.2
 * @throws MathException if an error occurs generating the random value
 */"
"public double getMean() {
    return mean;
}","public void test2028() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    int int0 = poissonDistributionImpl0.getDomainUpperBound(10000000);
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"@Override
protected int getDomainUpperBound(double p) {
    return Integer.MAX_VALUE;
}","public void test2029() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    int int0 = poissonDistributionImpl0.getDomainUpperBound(10000000);
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Access the domain value upper bound, based on <code>p</code>, used to
 * bracket a CDF root. This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return domain upper bound
 */"
"public double getMean() {
    return mean;
}","public void test2130() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    int int0 = poissonDistributionImpl0.sample();
    assertEquals(1427.9729143405275, poissonDistributionImpl0.getMean(), 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"@Override
public int sample() throws MathException {
    return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);
}","public void test2131() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    int int0 = poissonDistributionImpl0.sample();
    assertEquals(1435, int0);
}","/**
 * Generates a random value sampled from this distribution.
 *
 * <p><strong>Algorithm Description</strong>:
 * <ul><li> For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * <a href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li><
 *
 * <li> For large means, uses the rejection algorithm described in <br/>
 * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>
 * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>
 *
 * @return random value
 * @since 2.2
 * @throws MathException if an error occurs generating the random value
 */"
"public double getMean() {
    return mean;
}","public void test2232() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(853.1);
    double double0 = poissonDistributionImpl0.getMean();
    assertEquals(853.1, double0, 0.01);
}","/**
 * Get the Poisson mean for the distribution.
 *
 * @return the Poisson mean for the distribution.
 */"
"@Override
protected int getDomainLowerBound(double p) {
    return 0;
}","public void test2333() throws Throwable {
    PoissonDistributionImpl poissonDistributionImpl0 = new PoissonDistributionImpl(1427.9729143405275, 1427.9729143405275, 1439);
    poissonDistributionImpl0.getDomainLowerBound(1439);
}","/**
 * Access the domain value lower bound, based on <code>p</code>, used to
 * bracket a CDF root. This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return domain lower bound
 */"
