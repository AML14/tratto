focal_method,test_prefix,docstring
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test0000() throws Throwable {
    MathUtils.lcm(3000, 3000);
    MathUtils.sign(0L);
    MathUtils.cosh((-4.9E-324));
    double double0 = MathUtils.EPSILON;
    MathUtils.mulAndCheck((-24L), 0L);
    MathUtils.scalb(3000, 3000);
    MathUtils.sign((double) 3000);
    MathUtils.cosh((-2093.952733));
    // Undeclared exception!
    try {
        MathUtils.factorial(3000);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // result too large to represent in a long integer
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test0011() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    assertEquals((short) 1, short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test0012() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    assertEquals(double3, double1, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test0013() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    assertEquals(float1, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test0014() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    assertEquals(Double.POSITIVE_INFINITY, double4, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test0015() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    long long0 = MathUtils.addAndCheck((long) 0, 2855L);
    assertEquals(2855L, long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test0016() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    long long0 = MathUtils.addAndCheck((long) 0, 2855L);
    int int0 = MathUtils.gcd(0, 945);
    assertEquals(945, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test0017() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    long long0 = MathUtils.addAndCheck((long) 0, 2855L);
    int int0 = MathUtils.gcd(0, 945);
    float float2 = MathUtils.indicator(0.0F);
    assertEquals(1.0F, float2, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test0018() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    long long0 = MathUtils.addAndCheck((long) 0, 2855L);
    int int0 = MathUtils.gcd(0, 945);
    float float2 = MathUtils.indicator(0.0F);
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test0019() throws Throwable {
    MathUtils.addAndCheck(0L, 0L);
    MathUtils.equals((double) 0L, (double) 0L);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(0L, 0L);
    double double1 = MathUtils.indicator(1335.70629);
    double double2 = MathUtils.EPSILON;
    short short0 = MathUtils.sign((short) 1);
    float float0 = MathUtils.round((float) (short) 1, 0, (int) (short) 1);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.5;
    doubleArray0[1] = (double) (short) 1;
    doubleArray0[2] = 2746.4256;
    MathUtils.hash(doubleArray0);
    MathUtils.hash(0.0);
    double double3 = MathUtils.factorialDouble((short) 1);
    float float1 = MathUtils.round((float) 0L, (int) (short) 1);
    double double4 = MathUtils.sinh(2746.4256);
    long long0 = MathUtils.addAndCheck((long) 0, 2855L);
    int int0 = MathUtils.gcd(0, 945);
    float float2 = MathUtils.indicator(0.0F);
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.hash(0.0);
    float float3 = MathUtils.sign(0.0F);
    assertEquals(0.0F, float3, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test00210() throws Throwable {
    MathUtils.nextAfter(4.9E-324, 0.0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 4.9E-324;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = 0.0;
    MathUtils.hash(doubleArray0);
    MathUtils.indicator((byte) 0);
    MathUtils.sign(1530.2847F);
    MathUtils.scalb(0.0, (byte) 0);
    MathUtils.gcd((byte) 1, (-1));
    MathUtils.round(0.0, 1083);
    MathUtils.sign(1814L);
    MathUtils.addAndCheck(1762, (int) (byte) 0);
    MathUtils.indicator((float) 1);
    MathUtils.indicator((long) 1083);
    MathUtils.sign((byte) (-111));
    MathUtils.factorialDouble(1083);
    MathUtils.binomialCoefficientLog(1762, (byte) (-111));
    MathUtils.hash(doubleArray0);
    MathUtils.addAndCheck((-4640L), (-4640L));
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test00311() throws Throwable {
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.normalizeAngle(0.0, 2.2250738585072014E-308);
    MathUtils.sinh(0.0);
    MathUtils.equals(0.0, 0.0);
    MathUtils.sinh(0.0);
    MathUtils.round(0.0, 1, 1);
    MathUtils.round(0.0F, 283);
    MathUtils.equals((-110.3522941595321), 0.0);
    MathUtils.addAndCheck((long) 1, 4774L);
    MathUtils.binomialCoefficient(4, (-4276));
    MathUtils.nextAfter(0.0F, 1);
    MathUtils.round(0.0, 188);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 2.2250738585072014E-308;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 2874.20586468;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.factorial(1);
    MathUtils.binomialCoefficient(0, 0);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-2315), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test00412() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test00413() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    assertEquals(0L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test00414() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    assertEquals(3320, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test00415() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    assertEquals(3319.9999999999995, double1, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test00416() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    assertEquals(1.0, double2, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test00417() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test00418() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test00419() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    byte byte0 = MathUtils.indicator((byte) 0);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test00420() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    byte byte0 = MathUtils.indicator((byte) 0);
    int int1 = MathUtils.hash((-1.0));
    assertEquals((-1074790400), int1);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test00421() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    byte byte0 = MathUtils.indicator((byte) 0);
    int int1 = MathUtils.hash((-1.0));
    MathUtils.sign((byte) 1);
    double double3 = MathUtils.sinh(0.5);
    assertEquals(0.5210953054937474, double3, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test00422() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    byte byte0 = MathUtils.indicator((byte) 0);
    int int1 = MathUtils.hash((-1.0));
    MathUtils.sign((byte) 1);
    double double3 = MathUtils.sinh(0.5);
    long long1 = MathUtils.sign((long) (-1074790400));
    assertEquals((-1L), long1);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test00423() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1, 1);
    long long0 = MathUtils.subAndCheck(4312L, 4312L);
    int int0 = MathUtils.gcd(0, 3320);
    double double1 = MathUtils.nextAfter(3320, 0.0);
    double double2 = MathUtils.indicator((double) 4312L);
    MathUtils.scalb(0.0, 0);
    MathUtils.mulAndCheck(0L, 4312L);
    MathUtils.hash(571.8459247721023);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 3320;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = 3319.9999999999995;
    doubleArray0[4] = (double) 4312L;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.equals((double) 884287158, 0.0);
    float float0 = MathUtils.sign((float) 0L);
    byte byte0 = MathUtils.indicator((byte) 0);
    int int1 = MathUtils.hash((-1.0));
    MathUtils.sign((byte) 1);
    double double3 = MathUtils.sinh(0.5);
    long long1 = MathUtils.sign((long) (-1074790400));
    long long2 = MathUtils.indicator((long) (byte) 0);
    assertFalse(long2 == long1);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test00524() throws Throwable {
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.hash((double) 0);
    MathUtils.lcm((-3869), 52);
    MathUtils.sign((double) 201188);
    MathUtils.sign((byte) 0);
    MathUtils.gcd(52, 1);
    MathUtils.sign(52);
    MathUtils.sign((long) 201188);
    MathUtils.subAndCheck(0, 6603);
    MathUtils.mulAndCheck((long) 1, (-2588L));
    MathUtils.sign((-243.34741F));
    MathUtils.scalb((-3869), 1);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 201188;
    doubleArray0[1] = 1.0;
    doubleArray0[2] = 1.0;
    doubleArray0[3] = (double) 0;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.hash((double) 1);
    MathUtils.subAndCheck(1892, 31);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-3869), 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test00625() throws Throwable {
    MathUtils.log((-0.7478510541174533), (-0.7478510541174533));
    MathUtils.cosh(Double.NaN);
    long long0 = MathUtils.subAndCheck(3487L, (-2147483648L));
    assertEquals(2147487135L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test00626() throws Throwable {
    MathUtils.log((-0.7478510541174533), (-0.7478510541174533));
    MathUtils.cosh(Double.NaN);
    long long0 = MathUtils.subAndCheck(3487L, (-2147483648L));
    double double0 = MathUtils.nextAfter(Double.NaN, (-10.928587103411145));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test00627() throws Throwable {
    MathUtils.log((-0.7478510541174533), (-0.7478510541174533));
    MathUtils.cosh(Double.NaN);
    long long0 = MathUtils.subAndCheck(3487L, (-2147483648L));
    double double0 = MathUtils.nextAfter(Double.NaN, (-10.928587103411145));
    double double1 = MathUtils.binomialCoefficientLog(356, 356);
    assertEquals(0.0, double1, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test00628() throws Throwable {
    MathUtils.log((-0.7478510541174533), (-0.7478510541174533));
    MathUtils.cosh(Double.NaN);
    long long0 = MathUtils.subAndCheck(3487L, (-2147483648L));
    double double0 = MathUtils.nextAfter(Double.NaN, (-10.928587103411145));
    double double1 = MathUtils.binomialCoefficientLog(356, 356);
    int int0 = MathUtils.sign(356);
    assertEquals(1, int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test00729() throws Throwable {
    MathUtils.mulAndCheck(0L, 0L);
    MathUtils.mulAndCheck(0L, 0L);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-110.3522941595321);
    doubleArray0[1] = (double) 0L;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = (double) 0L;
    doubleArray0[4] = (double) 0L;
    MathUtils.equals(doubleArray0, doubleArray0);
    double[] doubleArray1 = new double[6];
    doubleArray1[0] = (-110.3522941595321);
    doubleArray1[1] = (double) 0L;
    doubleArray1[2] = (-110.3522941595321);
    doubleArray1[3] = (double) 0L;
    doubleArray1[4] = (double) 0L;
    doubleArray1[5] = (-110.3522941595321);
    int int0 = MathUtils.hash(doubleArray1);
    assertEquals(2068852981, int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test00730() throws Throwable {
    MathUtils.mulAndCheck(0L, 0L);
    MathUtils.mulAndCheck(0L, 0L);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-110.3522941595321);
    doubleArray0[1] = (double) 0L;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = (double) 0L;
    doubleArray0[4] = (double) 0L;
    MathUtils.equals(doubleArray0, doubleArray0);
    double[] doubleArray1 = new double[6];
    doubleArray1[0] = (-110.3522941595321);
    doubleArray1[1] = (double) 0L;
    doubleArray1[2] = (-110.3522941595321);
    doubleArray1[3] = (double) 0L;
    doubleArray1[4] = (double) 0L;
    doubleArray1[5] = (-110.3522941595321);
    int int0 = MathUtils.hash(doubleArray1);
    // Undeclared exception!
    try {
        MathUtils.addAndCheck(2068852981, 2068852981);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: add
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test00831() throws Throwable {
    MathUtils.equals(379.65915000474, 0.0);
    MathUtils.binomialCoefficient(52, 0);
    MathUtils.mulAndCheck((long) 52, (long) 52);
    MathUtils.indicator((long) 52);
    MathUtils.sign(2704L);
    MathUtils.binomialCoefficientLog(1535, 31);
    MathUtils.addAndCheck(0L, (long) 0);
    MathUtils.sign((short) 1143);
    MathUtils.sign(52);
    MathUtils.binomialCoefficientLog((short) 1143, (-1386));
    MathUtils.indicator((-872));
    MathUtils.nextAfter(0L, (-1386));
    MathUtils.factorialLog(1535);
    MathUtils.cosh((-1.0));
    MathUtils.lcm(0, (-1477));
    MathUtils.gcd((-1386), 2737);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test00932() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 1447680L;
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 395698079);
    MathUtils.subAndCheck((-377L), 1L);
    MathUtils.gcd(395698079, 395698079);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(395698079);
    MathUtils.round((float) (-3840L), 395698079, 1);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test01033() throws Throwable {
    MathUtils.mulAndCheck(31, (-4501));
    MathUtils.sign(699L);
    MathUtils.indicator((short) 0);
    MathUtils.indicator((double) (-139531));
    MathUtils.sign((long) 31);
    MathUtils.sign(0.0F);
    MathUtils.equals((double[]) null, (double[]) null);
    MathUtils.nextAfter(10.0, 1L);
    MathUtils.indicator(15L);
    MathUtils.cosh(699L);
    MathUtils.sign((-181.1638149));
    MathUtils.equals(6.283185307179586, 3319.9999999999995);
    MathUtils.sign((short) 29);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test01134() throws Throwable {
    MathUtils.equals(379.65915000474, 0.0);
    MathUtils.binomialCoefficient(52, 0);
    MathUtils.mulAndCheck((long) 52, (long) 52);
    MathUtils.indicator((long) 52);
    MathUtils.sign(2704L);
    MathUtils.binomialCoefficientLog(1535, 31);
    MathUtils.addAndCheck(0L, (long) 0);
    MathUtils.sign((short) 1143);
    MathUtils.sign(52);
    MathUtils.binomialCoefficientLog((short) 1143, (-1386));
    MathUtils.indicator(1);
    MathUtils.nextAfter(0L, (-1386));
    MathUtils.factorialLog(1535);
    MathUtils.cosh((-1.0));
    MathUtils.lcm(0, (-1477));
    MathUtils.gcd((-1386), 2737);
    MathUtils.subAndCheck((long) (short) 1143, 1509L);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test01235() throws Throwable {
    MathUtils.factorial(0);
    MathUtils.sign(0);
    MathUtils.round((float) 1L, 0);
    MathUtils.indicator((byte) (-121));
    MathUtils.sign((int) (byte) (-1));
    MathUtils.sinh(1L);
    MathUtils.mulAndCheck((-1L), (long) (byte) (-121));
    MathUtils.binomialCoefficient(0, (-1));
    MathUtils.indicator((byte) (-1));
    MathUtils.round((-180.6522257959), (int) (byte) (-1));
    MathUtils.subAndCheck((long) (byte) (-1), 0L);
    MathUtils.factorial(0);
    MathUtils.cosh(1.1752011936438016);
    MathUtils.mulAndCheck((-1330), (-1));
    MathUtils.indicator(21.6F);
    MathUtils.subAndCheck(1508, (-1));
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test01336() throws Throwable {
    int int0 = 300;
    MathUtils.mulAndCheck(300, 1);
    MathUtils.scalb((-2900.8202145115297), (-929));
    MathUtils.sign((-2900.8202145115297));
    int int1 = 453;
    MathUtils.binomialCoefficientLog(453, 1);
    MathUtils.equals(0.0, (double) 300);
    MathUtils.sign((long) 300);
    MathUtils.mulAndCheck((long) (-929), (long) 453);
    MathUtils.factorialLog(453);
    MathUtils.sign((-3894));
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-1), (-929));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test01437() throws Throwable {
    MathUtils.indicator((-1474.277532));
    MathUtils.sign((byte) 4);
    MathUtils.sign((short) (-241));
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test01538() throws Throwable {
    double double0 = (-1712.611);
    MathUtils.cosh((-1712.611));
    MathUtils.indicator((-1L));
    MathUtils.indicator((short) (-241));
    MathUtils.subAndCheck((-1), 31);
    // Undeclared exception!
    try {
        MathUtils.factorial((-32));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test01639() throws Throwable {
    MathUtils.nextAfter((-2200.8951), (-2200.8951));
    MathUtils.cosh((-2200.8951));
    MathUtils.sign(Float.NaN);
    MathUtils.sign((-912.0F));
    int int0 = (-2147234663);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-2147234663), (-2147234663));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);
}","public void test01740() throws Throwable {
    MathUtils.subAndCheck(0L, 0L);
    MathUtils.normalizeAngle(1.0, 10.0);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double cosh(double x) {
    return (Math.exp(x) + Math.exp(-x)) / 2.0;
}","public void test01841() throws Throwable {
    MathUtils.gcd(0, (-1));
    MathUtils.factorial(1);
    MathUtils.cosh(0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"">
 * hyperbolic cosine</a> of x.
 *
 * @param x double value for which to find the hyperbolic cosine
 * @return hyperbolic cosine of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test01942() throws Throwable {
    MathUtils.addAndCheck(53, 0);
    MathUtils.gcd(0, 0);
    MathUtils.indicator((double) 0);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test02043() throws Throwable {
    MathUtils.sinh((-1754.10975657812));
    MathUtils.round(0.0F, 0);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test02144() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-330), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test02245() throws Throwable {
    MathUtils.equals(0.0, 0.0);
    MathUtils.subAndCheck(31, (-1));
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test02346() throws Throwable {
    MathUtils.scalb(0.0, 822);
    MathUtils.scalb(822, 0);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);
}","public void test02447() throws Throwable {
    MathUtils.lcm(3517, 0);
    MathUtils.round((float) 0, 0, 0);
    MathUtils.normalizeAngle(1.0F, 1637.4906461181);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test02548() throws Throwable {
    MathUtils.subAndCheck(2123L, 4503599627370495L);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test02649() throws Throwable {
    int int0 = (-2255);
    MathUtils.sign((-2255));
    MathUtils.indicator(0.0F);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-2255), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test02750() throws Throwable {
    double double0 = (-1505.4677638);
    MathUtils.nextAfter((-1505.4677638), 0.0);
    int int0 = (-367);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-367), (-367));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test02851() throws Throwable {
    MathUtils.sign(0);
    MathUtils.round(1.0, 0);
    MathUtils.binomialCoefficient(0, 0);
    MathUtils.mulAndCheck(1L, 0L);
    MathUtils.mulAndCheck((-1175), 0);
    MathUtils.sinh(0.0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test02952() throws Throwable {
    MathUtils.mulAndCheck(0, (-1));
    MathUtils.indicator((short) (-204));
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundry cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test03053() throws Throwable {
    MathUtils.indicator((byte) 0);
    MathUtils.normalizeAngle((byte) 0, (byte) 1);
    MathUtils.mulAndCheck((-2323L), (long) (byte) 0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test03154() throws Throwable {
    long long0 = 0L;
    MathUtils.addAndCheck(0L, 0L);
    int int0 = 0;
    // Undeclared exception!
    try {
        MathUtils.round((float) 0L, 0, 3511);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding method.
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test03255() throws Throwable {
    MathUtils.round((-1617.9F), 0);
    MathUtils.binomialCoefficientLog(4, 0);
    MathUtils.nextAfter(0, (-1618.0F));
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test03356() throws Throwable {
    MathUtils.sign((-759.6439791));
    MathUtils.log(0.0, (-583.3606628057408));
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test03457() throws Throwable {
    int int0 = 0;
    int int1 = 1800;
    MathUtils.subAndCheck(0, 1800);
    byte byte0 = (byte) 0;
    MathUtils.indicator((byte) 0);
    int int2 = 0;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-1800), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test03558() throws Throwable {
    MathUtils.subAndCheck(1626L, 0L);
    int int0 = 0;
    MathUtils.binomialCoefficient(0, 0);
    MathUtils.mulAndCheck(1, 0);
    MathUtils.sinh(1);
    MathUtils.indicator((float) 1626L);
    MathUtils.round((double) 0, 1);
    MathUtils.mulAndCheck((-1L), (long) 0);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 0L;
    doubleArray0[1] = (double) 0L;
    doubleArray0[2] = (double) 0L;
    doubleArray0[3] = (double) 1626L;
    doubleArray0[4] = (double) 1L;
    doubleArray0[5] = (double) 0L;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.indicator((short) 451);
    MathUtils.normalizeAngle(0L, 2.2909552562);
    MathUtils.mulAndCheck(1639, (-1057));
    MathUtils.factorial(0);
    // Undeclared exception!
    try {
        MathUtils.round((float) 0, 2068, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding method.
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test03659() throws Throwable {
    MathUtils.factorialLog(0);
    MathUtils.round((-850.8327063), 0);
    MathUtils.indicator((-851.0));
    MathUtils.log((-850.8327063), 829.6205);
    MathUtils.gcd(0, (-2127031421));
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test03760() throws Throwable {
    MathUtils.round(0.0F, 0, 0);
    MathUtils.equals(2.0, 2.0);
    MathUtils.round(2.0, 0);
    MathUtils.scalb((-503.9778030393684), 0);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static int lcm(int a, int b) {
    return Math.abs(mulAndCheck(a / gcd(a, b), b));
}","public void test03861() throws Throwable {
    MathUtils.sign((-3029.091F));
    MathUtils.nextAfter((-3029.091F), (-1.0F));
    MathUtils.binomialCoefficientDouble(4, 4);
    MathUtils.indicator((-1L));
    MathUtils.lcm(4, 0);
}","/**
 * Returns the least common multiple between two integer values.
 *
 * @param a the first integer value.
 * @param b the second integer value.
 * @return the least common multiple between a and b.
 * @throws ArithmeticException if the lcm is too large to store as an int
 * @since 1.1
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test03962() throws Throwable {
    MathUtils.subAndCheck(4718, 4718);
    MathUtils.mulAndCheck(4718, 0);
    MathUtils.subAndCheck(207L, 207L);
    MathUtils.sign(1.0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test04063() throws Throwable {
    MathUtils.indicator((byte) 1);
    MathUtils.indicator((-1.0F));
    MathUtils.sign((short) (byte) 1);
    MathUtils.sign(0.0F);
    MathUtils.indicator((byte) 1);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test04164() throws Throwable {
    MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.scalb(0, (-1));
    MathUtils.equals((double[]) null, (double[]) null);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test04265() throws Throwable {
    MathUtils.indicator((-1));
    MathUtils.sign((-620.0F));
    MathUtils.indicator((byte) 0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test04366() throws Throwable {
    MathUtils.hash(1276.5594546284);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test04467() throws Throwable {
    short short0 = (short) 2846;
    MathUtils.sign((short) 2846);
    int int0 = 0;
    MathUtils.indicator(0);
    int int1 = 31;
    MathUtils.scalb((short) 1, 31);
    int int2 = (-176);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-176), (-1207));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test04568() throws Throwable {
    MathUtils.indicator((short) 0);
    MathUtils.sign((short) (-1));
    MathUtils.cosh(1.0);
    MathUtils.log(0.0, (short) (-1));
    // Undeclared exception!
    try {
        MathUtils.factorial((short) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test04669() throws Throwable {
    MathUtils.addAndCheck((-1), 0);
    int int0 = 0;
    MathUtils.subAndCheck(0, 819);
    int int1 = 3677;
    // Undeclared exception!
    try {
        MathUtils.round((double) (-1), 0, 3677);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test04770() throws Throwable {
    MathUtils.gcd(1, 1);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test04871() throws Throwable {
    MathUtils.lcm((-479), (-1));
    // Undeclared exception!
    try {
        MathUtils.factorial((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test04972() throws Throwable {
    MathUtils.indicator(0L);
    MathUtils.sign(2);
    MathUtils.binomialCoefficientLog(1, 0);
    MathUtils.sinh(1);
    MathUtils.sign(0L);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test05073() throws Throwable {
    MathUtils.sign(0.0);
    int int0 = (-1956);
    MathUtils.gcd((-1956), (-1956));
    int int1 = 3585;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(663, 3585);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test05174() throws Throwable {
    MathUtils.binomialCoefficientDouble(2421, (-3779));
    MathUtils.sign(Double.NaN);
    MathUtils.indicator((byte) (-36));
    MathUtils.normalizeAngle(Double.NaN, (byte) (-36));
    MathUtils.mulAndCheck(2421, 0);
    int int0 = 31;
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(1851, 31);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // result too large to represent in a long integer
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test05275() throws Throwable {
    MathUtils.scalb((-3868.132), 0);
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.sign((byte) 95);
    MathUtils.mulAndCheck(0, 0);
    // Undeclared exception!
    try {
        MathUtils.factorialLog((-2545));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n > 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test05376() throws Throwable {
    MathUtils.sign((short) 0);
    int int0 = 712;
    MathUtils.factorialDouble(712);
    MathUtils.round(Double.POSITIVE_INFINITY, (int) (short) 0, (-1634));
    MathUtils.indicator((byte) (-127));
    MathUtils.mulAndCheck(0, (int) (short) 0);
    MathUtils.sign((-1025.8123F));
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((byte) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test05477() throws Throwable {
    int int0 = 0;
    MathUtils.mulAndCheck(0, 0);
    MathUtils.round(0.0F, 0);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble(0, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test05578() throws Throwable {
    MathUtils.factorialDouble(941);
    MathUtils.indicator(1.0);
    MathUtils.sign(2976L);
    MathUtils.sinh(1.0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test05679() throws Throwable {
    MathUtils.mulAndCheck((-2696L), (-2696L));
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 7268416L;
    doubleArray0[1] = (double) (-2696L);
    doubleArray0[2] = (double) (-2696L);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.log((-2696.0), (-2696.0));
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test05780() throws Throwable {
    MathUtils.sign((-110L));
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test05881() throws Throwable {
    MathUtils.nextAfter((-1934.03970552), (-1934.03970552));
    MathUtils.addAndCheck(4503599627370496L, 4503599627370496L);
    MathUtils.round(0.0F, 2671);
    MathUtils.subAndCheck(2671, 2671);
    MathUtils.round(3885.95470837, 4, 0);
    MathUtils.indicator(994);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test05982() throws Throwable {
    MathUtils.sign(2944);
    double[] doubleArray0 = new double[0];
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.addAndCheck(2944, 31);
    MathUtils.factorialLog(786);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test06083() throws Throwable {
    MathUtils.equals(1083.8, 1083.8);
    MathUtils.round((-2676.102F), 0, 0);
    MathUtils.sign((-2677.0F));
    MathUtils.addAndCheck((-1967L), (-2288L));
    MathUtils.factorialLog(0);
    MathUtils.log((-1.0F), (-1266.6));
    MathUtils.subAndCheck(0, 839);
    // Undeclared exception!
    try {
        MathUtils.round((-1094.1), 839, 52);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test06184() throws Throwable {
    MathUtils.mulAndCheck(0L, 2033L);
    MathUtils.mulAndCheck(2033L, 2033L);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 0L;
    doubleArray0[1] = (double) 2033L;
    doubleArray0[2] = (double) 0L;
    MathUtils.equals(doubleArray0, doubleArray0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test06285() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-1109), (-1109));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test06386() throws Throwable {
    MathUtils.cosh(0.0);
    MathUtils.factorial(1);
    MathUtils.round((double) 1L, 1);
    MathUtils.addAndCheck((long) 1, 1L);
    double double0 = Double.POSITIVE_INFINITY;
    MathUtils.nextAfter(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
    MathUtils.nextAfter(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
    MathUtils.indicator((byte) 37);
    MathUtils.indicator((byte) 1);
    // Undeclared exception!
    try {
        MathUtils.round(0.0, (int) (byte) 1, (int) (byte) 37);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test06487() throws Throwable {
    MathUtils.round(54.987404F, 1, 1);
    MathUtils.indicator((short) 0);
    MathUtils.hash((double) 54.9F);
    MathUtils.cosh(1);
    MathUtils.indicator(2147483647L);
    MathUtils.addAndCheck(1, 1);
    MathUtils.addAndCheck(3230L, (long) 1);
    MathUtils.sign((long) 4944691);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(1, 4944691);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test06588() throws Throwable {
    MathUtils.sign(0.0F);
    MathUtils.indicator((short) (-206));
    MathUtils.nextAfter((short) (-1), 0.0);
    MathUtils.hash((double) 0.0F);
    MathUtils.binomialCoefficientLog(0, (short) (-206));
    MathUtils.nextAfter(1.0, 2601.66);
    MathUtils.sinh(0);
    MathUtils.factorialDouble(0);
    MathUtils.sign((int) (short) (-206));
    MathUtils.factorialLog(4061);
    MathUtils.sign((float) (-1));
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 2601.66;
    doubleArray0[1] = 1.0000000000000002;
    doubleArray0[2] = 29687.671918251523;
    doubleArray0[3] = (double) (short) (-206);
    doubleArray0[4] = 0.0;
    doubleArray0[5] = (double) (short) (-1);
    doubleArray0[6] = (double) 0.0F;
    doubleArray0[7] = (double) 0.0F;
    doubleArray0[8] = 29687.671918251523;
    MathUtils.hash(doubleArray0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundry cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test06689() throws Throwable {
    MathUtils.sinh(3018.52846);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-9218868437227405313L), (-2831L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test06790() throws Throwable {
    MathUtils.equals((-2317.8935063303857), (-2317.8935063303857));
    MathUtils.addAndCheck(31, 31);
    MathUtils.sign(0.0F);
    MathUtils.equals((double) 31, 321.5);
    MathUtils.sign(1445L);
    MathUtils.indicator(1);
    MathUtils.factorialDouble(52);
    MathUtils.equals((double) 1L, 4.9E-324);
    MathUtils.gcd(2, 1);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test06891() throws Throwable {
    MathUtils.hash(0.0);
    MathUtils.sinh(0.0);
    MathUtils.round((-1.0), 0, 0);
    MathUtils.addAndCheck((long) 0, 1999L);
    MathUtils.round(1748.0F, 1119);
    MathUtils.factorialDouble(1801);
    MathUtils.round((-1.0), 1, 0);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test06992() throws Throwable {
    MathUtils.lcm(2282, 2282);
    MathUtils.round((double) 2282, 3060);
    MathUtils.sign(0);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble(0, 421);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test07093() throws Throwable {
    MathUtils.lcm(0, 1253);
    MathUtils.sign(31);
    MathUtils.gcd(1, 22);
    MathUtils.log(22, 1);
    double[] doubleArray0 = new double[0];
    MathUtils.hash(doubleArray0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundry cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test07194() throws Throwable {
    MathUtils.mulAndCheck(0, (-4501));
    MathUtils.sign(678L);
    MathUtils.indicator((short) 0);
    MathUtils.indicator((double) 0);
    MathUtils.sign((long) 0);
    MathUtils.sign(0.0F);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-104L), 9223372036854774099L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int lcm(int a, int b) {
    return Math.abs(mulAndCheck(a / gcd(a, b), b));
}","public void test07295() throws Throwable {
    MathUtils.mulAndCheck((-2593L), 899L);
    MathUtils.sign((short) (-615));
    MathUtils.indicator((-860.92F));
    int int0 = 0;
    // Undeclared exception!
    try {
        MathUtils.lcm(0, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // / by zero
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the least common multiple between two integer values.
 *
 * @param a the first integer value.
 * @param b the second integer value.
 * @return the least common multiple between a and b.
 * @throws ArithmeticException if the lcm is too large to store as an int
 * @since 1.1
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test07396() throws Throwable {
    MathUtils.sinh(0.0);
    MathUtils.round(0.0, 0, 0);
    MathUtils.sign(0.0F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test07497() throws Throwable {
    MathUtils.lcm(840, 840);
    MathUtils.sign(840);
    MathUtils.sign((short) (-1));
    byte byte0 = (byte) 0;
    MathUtils.indicator((byte) 0);
    MathUtils.sign(0.0F);
    MathUtils.normalizeAngle(0.0, 1);
    MathUtils.normalizeAngle(840, 0.0F);
    MathUtils.subAndCheck((long) 1, 517L);
    MathUtils.indicator((int) (byte) 0);
    MathUtils.indicator(517L);
    MathUtils.subAndCheck(0L, (long) (byte) 1);
    MathUtils.sign((short) (-1));
    MathUtils.addAndCheck((int) (short) (-1), 974);
    MathUtils.indicator((short) (-1));
    MathUtils.indicator((-1.0F));
    MathUtils.gcd(973, 516);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(974, 840);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // result too large to represent in a long integer
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test07598() throws Throwable {
    MathUtils.mulAndCheck((-2144), 0);
    MathUtils.addAndCheck(0, 0);
    MathUtils.factorialDouble(0);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test07699() throws Throwable {
    MathUtils.nextAfter(0.0, 0.0);
    MathUtils.hash((-2574.0));
    MathUtils.indicator(1070.411672413604);
    // Undeclared exception!
    try {
        MathUtils.factorial((-1062986752));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test077100() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (-2876.801556);
    doubleArray0[1] = 3.141592653589793;
    doubleArray0[2] = (-3070.78921);
    doubleArray0[3] = 0.0;
    doubleArray0[4] = (-2453.60306502094);
    doubleArray0[5] = (-2290.1434776);
    doubleArray0[6] = 1108.064798174;
    MathUtils.hash(doubleArray0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test078101() throws Throwable {
    MathUtils.scalb(1.0, 0);
    MathUtils.binomialCoefficient(1105, 0);
    MathUtils.sign((-1));
    MathUtils.equals(1199.58787, (double) 1105);
    MathUtils.indicator((-1L));
    MathUtils.sign(3971L);
    MathUtils.subAndCheck(0, 0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test079102() throws Throwable {
    MathUtils.addAndCheck(0L, (-2067L));
    MathUtils.lcm(1359, (-1614));
    MathUtils.addAndCheck((-243), 0);
    MathUtils.mulAndCheck(731142, 1359);
    MathUtils.factorialLog(1359);
    MathUtils.indicator(Float.NaN);
    MathUtils.scalb((-1.0), (-1614));
    MathUtils.lcm((-422), 853);
    MathUtils.gcd(0, 0);
    MathUtils.indicator((short) 0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test080103() throws Throwable {
    MathUtils.normalizeAngle(0.0, 1.0);
    MathUtils.sign(616.1991F);
    MathUtils.sign((byte) 0);
    MathUtils.indicator(0L);
    MathUtils.sign(0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test081104() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (-322.307296);
    doubleArray0[1] = (-1.0);
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 244.86671;
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.binomialCoefficientLog(0, 0);
    MathUtils.log(244.86671, 0.0);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test082105() throws Throwable {
    byte byte0 = (byte) 0;
    MathUtils.indicator((byte) 0);
    int int0 = 0;
    MathUtils.subAndCheck(0, (int) (byte) 1);
    MathUtils.sign((-2087.4907F));
    int int1 = (-3156);
    MathUtils.lcm((-3156), (-3156));
    MathUtils.binomialCoefficientDouble(3156, (byte) 1);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-1518), (-3156));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test083106() throws Throwable {
    MathUtils.addAndCheck(52, (-1));
    MathUtils.binomialCoefficientLog(52, 51);
    MathUtils.sign(38L);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test084107() throws Throwable {
    MathUtils.sign(4);
    MathUtils.sign((long) 1);
    MathUtils.sign((byte) (-29));
    MathUtils.indicator((byte) 0);
    MathUtils.sign((long) 4);
    MathUtils.addAndCheck(0, 1);
    MathUtils.indicator(1L);
    MathUtils.log(0.0, 0.0);
    MathUtils.binomialCoefficientDouble(0, (-1));
    MathUtils.mulAndCheck((long) 1, (long) 0);
    MathUtils.normalizeAngle(0.0, 0.0);
    MathUtils.cosh(1L);
    MathUtils.mulAndCheck(57L, 0L);
    MathUtils.nextAfter(0.0, (-4.9E-324));
    MathUtils.round((-1.0F), (-1), 0);
    MathUtils.indicator((short) (byte) 0);
    // Undeclared exception!
    try {
        MathUtils.round((double) (-10.0F), 0, 1282);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test085108() throws Throwable {
    MathUtils.indicator(544);
    MathUtils.log(544, 544);
    MathUtils.indicator(544);
    MathUtils.normalizeAngle(113.58579447, 1);
    MathUtils.round(325.309F, 1, 1);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test086109() throws Throwable {
    MathUtils.sign((-3029.091F));
    MathUtils.nextAfter((-3029.091F), (-1.0F));
    MathUtils.binomialCoefficientDouble(4, 4);
    MathUtils.lcm(4, 0);
    // Undeclared exception!
    try {
        MathUtils.factorial(373);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // result too large to represent in a long integer
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test087110() throws Throwable {
    MathUtils.normalizeAngle(1069.1507236483772, (-850.954521));
    int int0 = 2;
    MathUtils.addAndCheck(1052, 2);
    // Undeclared exception!
    try {
        MathUtils.factorial(1054);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // result too large to represent in a long integer
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test088111() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 3946.2302;
    doubleArray0[1] = Double.NaN;
    doubleArray0[2] = (-1720.5420547137624);
    doubleArray0[3] = (-4.9E-324);
    doubleArray0[4] = 2403.7689728;
    doubleArray0[5] = (-4.9E-324);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.addAndCheck(828, 828);
    MathUtils.sign((short) 0);
    MathUtils.sign((short) 0);
    MathUtils.indicator((short) 0);
    MathUtils.subAndCheck((long) (short) 0, 9218868437227405312L);
    MathUtils.indicator(11);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test089112() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = 1.0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = (-2237.0);
    doubleArray0[3] = (-5515.636800492);
    doubleArray0[4] = Double.NaN;
    doubleArray0[5] = (-1.0);
    doubleArray0[6] = (-2617.34607633);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign((short) 899);
    MathUtils.indicator((short) 899);
    MathUtils.hash((-1.0));
    MathUtils.log(1.0, 0.0);
    MathUtils.round(784.95306F, (int) (short) 1);
    MathUtils.indicator(0.0);
    MathUtils.lcm(0, (short) 899);
    MathUtils.hash((-354.11686));
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test090113() throws Throwable {
    MathUtils.factorialDouble(0);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 1.0;
    doubleArray0[1] = 1186.58;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 1.0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = 1.0;
    MathUtils.equals((double[]) null, doubleArray0);
    MathUtils.indicator((-455L));
    MathUtils.cosh(0);
    MathUtils.indicator((double) 0);
    MathUtils.gcd(0, 0);
    MathUtils.binomialCoefficient(2804, 0);
    MathUtils.subAndCheck(0, 1);
    MathUtils.nextAfter(1.0, 0.0);
    MathUtils.factorialDouble(2804);
    MathUtils.nextAfter(0.0, 1186.58);
    MathUtils.binomialCoefficientLog(351, (-1));
    MathUtils.mulAndCheck((-455L), (-1630L));
    MathUtils.equals((double[]) null, (double[]) null);
    MathUtils.log(0.9999999999999999, 1.0);
    MathUtils.scalb(1186.58, 0);
    MathUtils.indicator((byte) (-1));
    MathUtils.hash(0.0);
    MathUtils.indicator((float) (-1630L));
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static int lcm(int a, int b) {
    return Math.abs(mulAndCheck(a / gcd(a, b), b));
}","public void test091114() throws Throwable {
    double double0 = (-1853.67);
    MathUtils.log(1470.7, (-1853.67));
    MathUtils.sign((short) 0);
    MathUtils.indicator(1);
    MathUtils.indicator(Double.NaN);
    // Undeclared exception!
    try {
        MathUtils.lcm((short) 0, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // / by zero
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the least common multiple between two integer values.
 *
 * @param a the first integer value.
 * @param b the second integer value.
 * @return the least common multiple between a and b.
 * @throws ArithmeticException if the lcm is too large to store as an int
 * @since 1.1
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test092115() throws Throwable {
    MathUtils.log(0.0, 0.0);
    MathUtils.cosh(Double.NaN);
    MathUtils.subAndCheck(3438L, (-2147483648L));
    MathUtils.nextAfter(Double.NaN, 0.0);
    MathUtils.binomialCoefficientLog(356, 356);
    MathUtils.sign(356);
    MathUtils.indicator(2147487086L);
    MathUtils.scalb(2147487086L, 1);
    MathUtils.binomialCoefficient(1, (-1));
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test093116() throws Throwable {
    long long0 = 9223372036854775807L;
    // Undeclared exception!
    try {
        MathUtils.subAndCheck((-2147483648L), 9223372036854775807L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test094117() throws Throwable {
    MathUtils.factorialLog(1354);
    MathUtils.round((float) 1354, 1354);
    MathUtils.round(0.0, 1354);
    MathUtils.round(Float.NaN, 1354, 0);
    MathUtils.sign(1.0F);
    MathUtils.binomialCoefficientDouble(2, 2);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 1.0F;
    doubleArray0[1] = (double) Float.NaN;
    doubleArray0[2] = (double) 2;
    doubleArray0[3] = 8413.972595307363;
    doubleArray0[4] = (double) 1354;
    doubleArray0[5] = 0.0;
    doubleArray0[6] = 0.0;
    doubleArray0[7] = (double) 2;
    doubleArray0[8] = (double) 0;
    double[] doubleArray1 = new double[1];
    doubleArray1[0] = 1.0;
    MathUtils.equals(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test095118() throws Throwable {
    int int0 = 0;
    MathUtils.sinh(0);
    MathUtils.factorialDouble(0);
    long long0 = (-9218868437227405313L);
    // Undeclared exception!
    MathUtils.factorialLog(2113929216);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test096119() throws Throwable {
    MathUtils.sinh(52);
    MathUtils.indicator(934.227F);
    MathUtils.indicator((byte) 31);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 52;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign((byte) 31);
    MathUtils.sign(4503599627370495L);
    MathUtils.factorial((byte) 1);
    MathUtils.sign(462.4014F);
    MathUtils.indicator((long) (byte) 1);
    MathUtils.sinh(Double.NEGATIVE_INFINITY);
    MathUtils.indicator((-1L));
    double[] doubleArray1 = new double[7];
    doubleArray1[0] = 1080.976317389;
    doubleArray1[1] = (double) 4503599627370495L;
    doubleArray1[2] = (double) 1.0F;
    doubleArray1[3] = (double) 462.4014F;
    doubleArray1[5] = (double) 934.227F;
    doubleArray1[6] = (double) 2147483647L;
    MathUtils.equals(doubleArray0, doubleArray1);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test097120() throws Throwable {
    MathUtils.binomialCoefficient(758, 758);
    MathUtils.indicator((-3704));
    MathUtils.nextAfter((-5328384.368904361), (-2618.33587));
    MathUtils.round((float) 1L, (-3704), 2);
    byte byte0 = (byte) (-124);
    MathUtils.sign((byte) (-124));
    int int0 = (-794);
    // Undeclared exception!
    try {
        MathUtils.factorialLog((-794));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n > 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test098121() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 2937.58149819;
    doubleArray0[1] = 6.283185307179586;
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-43.8565267608);
    doubleArray0[4] = 1.1102230246251565E-16;
    doubleArray0[5] = (-921.80277);
    doubleArray0[6] = 1.0;
    doubleArray0[7] = (-2076.6398838);
    doubleArray0[8] = 0.0;
    MathUtils.hash(doubleArray0);
    MathUtils.indicator(1390893829);
    MathUtils.hash(doubleArray0);
    MathUtils.sign(0.0);
    MathUtils.mulAndCheck(1390893829, (-1));
    MathUtils.subAndCheck(1390893829, 1);
    MathUtils.round((float) 1390893829, (-1390893829));
    MathUtils.mulAndCheck(3223L, (long) 1);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(2022, 1390893829);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test099122() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.sign((-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) (-1L);
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 1697859743);
    MathUtils.subAndCheck((-377L), 1L);
    MathUtils.gcd(1697859743, 1697859743);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(1697859743);
    MathUtils.round((float) (-3840L), 1697859743, 1);
    MathUtils.indicator((float) 1L);
    MathUtils.mulAndCheck((long) 1697859743, (long) 1697859743);
    // Undeclared exception!
    MathUtils.factorialDouble(1697859743);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundry cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test100123() throws Throwable {
    int int0 = 779;
    MathUtils.factorialLog(779);
    MathUtils.sign(4411.838655764204);
    MathUtils.lcm(779, 1286);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(4503599627370496L, (long) 1001794);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test101124() throws Throwable {
    MathUtils.nextAfter(2.2250738585072014E-308, (-1766.6440045686));
    MathUtils.round(Double.NaN, 4132, (-763));
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    long result = Math.round(binomialCoefficientDouble(n, k));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test102125() throws Throwable {
    MathUtils.mulAndCheck((-1), (-1));
    MathUtils.binomialCoefficientDouble(1, (-2857));
    MathUtils.indicator((-2857));
    MathUtils.binomialCoefficient(1, (-1705));
    MathUtils.binomialCoefficientDouble(0, (-1264));
    MathUtils.sign(2186.2F);
    MathUtils.mulAndCheck(31, 31);
    MathUtils.factorialLog(4362);
    // Undeclared exception!
    MathUtils.binomialCoefficient(3182, (-3431));
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException
 *      </code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test103126() throws Throwable {
    MathUtils.cosh(6.283185307179586);
    MathUtils.indicator((short) (-1));
    MathUtils.indicator((short) (-1));
    int int0 = 2;
    MathUtils.binomialCoefficientLog(2, 2);
    int int1 = 2;
    MathUtils.round((-3167.637F), 2, 2);
    int int2 = 4240;
    MathUtils.factorialDouble(4240);
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble(0, 118);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double cosh(double x) {
    return (Math.exp(x) + Math.exp(-x)) / 2.0;
}","public void test104127() throws Throwable {
    MathUtils.normalizeAngle(0.0, 0.0);
    MathUtils.normalizeAngle(1.0, 0.0);
    MathUtils.indicator(0L);
    MathUtils.indicator(0);
    MathUtils.lcm(4954, 0);
    MathUtils.binomialCoefficientDouble(4954, 578);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 1;
    doubleArray0[1] = (double) 4954;
    doubleArray0[2] = (double) 1;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.indicator((-44));
    MathUtils.equals(doubleArray0, (double[]) null);
    MathUtils.mulAndCheck(1, 0);
    MathUtils.log(4954.0, 1752.95617);
    MathUtils.gcd((-1), 2585);
    MathUtils.addAndCheck(0, (-1349));
    MathUtils.cosh(2585);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"">
 * hyperbolic cosine</a> of x.
 *
 * @param x double value for which to find the hyperbolic cosine
 * @return hyperbolic cosine of x
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test105128() throws Throwable {
    MathUtils.mulAndCheck(0L, 0L);
    MathUtils.mulAndCheck(0L, 0L);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 0L;
    doubleArray0[2] = (double) 0L;
    MathUtils.equals(doubleArray0, doubleArray0);
    double[] doubleArray1 = new double[3];
    doubleArray1[0] = (double) 0L;
    doubleArray1[1] = (-252.3568776820009);
    doubleArray1[2] = (double) 0L;
    MathUtils.equals(doubleArray1, doubleArray0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test106129() throws Throwable {
    MathUtils.log(0.0, 0.0);
    MathUtils.cosh(Double.NaN);
    MathUtils.subAndCheck(3438L, (-1676L));
    MathUtils.nextAfter(Double.NaN, (-0.0177823110247029));
    MathUtils.binomialCoefficientLog(356, 356);
    MathUtils.sign(356);
    MathUtils.subAndCheck(5114L, (long) 1);
    MathUtils.indicator((-931L));
    MathUtils.scalb(Double.NEGATIVE_INFINITY, 1);
    MathUtils.indicator(51.7F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test107130() throws Throwable {
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.normalizeAngle(0.0, 2.2250738585072014E-308);
    MathUtils.sinh(0.0);
    MathUtils.equals(0.0, 0.0);
    MathUtils.sinh(0.0);
    MathUtils.round(0.0, 1, 1);
    MathUtils.round(0.0F, 283);
    MathUtils.equals((-110.3522941595321), 0.0);
    MathUtils.addAndCheck((long) 1, 4774L);
    MathUtils.binomialCoefficient(4, (-4276));
    MathUtils.nextAfter(0.0F, 1);
    MathUtils.round(0.0, 188);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 2.2250738585072014E-308;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 2874.20586468;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.factorial(1);
    MathUtils.binomialCoefficient(0, 0);
    MathUtils.sign(148);
    MathUtils.scalb(Double.POSITIVE_INFINITY, 3295);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundry cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test108131() throws Throwable {
    MathUtils.binomialCoefficientDouble(0, 0);
    MathUtils.hash((double) 0);
    MathUtils.lcm((-3869), 52);
    MathUtils.sign((double) 201188);
    MathUtils.sign((byte) 0);
    MathUtils.gcd(52, 1);
    MathUtils.sign(52);
    MathUtils.sign((long) 201188);
    MathUtils.subAndCheck(0, 6603);
    MathUtils.mulAndCheck((long) 1, (-2588L));
    MathUtils.sign((-243.34741F));
    MathUtils.scalb((-3869), 1);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 201188;
    doubleArray0[1] = 1.0;
    doubleArray0[2] = 1.0;
    doubleArray0[3] = (double) 0;
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.hash((double) 1);
    MathUtils.subAndCheck(1892, 31);
    MathUtils.indicator((byte) 52);
    MathUtils.mulAndCheck((-9223372036854775808L), 1L);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","public void test109132() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 490948767);
    MathUtils.subAndCheck((-377L), (-377L));
    MathUtils.gcd(490948767, 490948767);
    MathUtils.sign(490948767);
    MathUtils.round((float) (-3840L), 490948767, 1);
    // Undeclared exception!
    MathUtils.binomialCoefficientDouble(490948767, (-2183));
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test110133() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 1447680L;
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 395698079);
    MathUtils.subAndCheck((-377L), 1447680L);
    MathUtils.gcd(395698079, 395698079);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(395698079);
    MathUtils.round((float) (-3840L), 395698079, 1);
    MathUtils.nextAfter((-2145.3777), (-377L));
    int int0 = 5316;
    MathUtils.indicator(5316);
    MathUtils.indicator(0.0F);
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(395698079, (-639));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    return Math.abs(mulAndCheck(a / gcd(a, b), b));
}","public void test111134() throws Throwable {
    MathUtils.nextAfter(4.9E-324, 0.0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 4.9E-324;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = 0.0;
    MathUtils.hash(doubleArray0);
    MathUtils.indicator((byte) 0);
    MathUtils.sign(1530.2847F);
    MathUtils.scalb(0.0, (byte) 0);
    MathUtils.gcd((byte) 1, (-1));
    int int0 = 1083;
    MathUtils.round(0.0, 1083);
    MathUtils.sign(1814L);
    // Undeclared exception!
    try {
        MathUtils.lcm(1083, 28658942);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the least common multiple between two integer values.
 *
 * @param a the first integer value.
 * @param b the second integer value.
 * @return the least common multiple between a and b.
 * @throws ArithmeticException if the lcm is too large to store as an int
 * @since 1.1
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test112135() throws Throwable {
    MathUtils.sign((-816.297189));
    double[] doubleArray0 = new double[5];
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 490948767);
    MathUtils.subAndCheck((-377L), 1L);
    MathUtils.gcd(490948767, 490948767);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(490948767);
    MathUtils.equals(1.0, 530.0596236264574);
    MathUtils.round((float) 490948767, (-1), 7);
    MathUtils.indicator((short) (-1017));
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test113136() throws Throwable {
    MathUtils.log(0.0, 0.0);
    MathUtils.cosh(Double.NaN);
    MathUtils.subAndCheck(3438L, (-2147483648L));
    MathUtils.nextAfter(Double.NaN, 0.0);
    MathUtils.binomialCoefficientLog(356, 356);
    MathUtils.sign(356);
    MathUtils.binomialCoefficient(4360, 1);
    MathUtils.indicator((short) 834);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test114137() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 1447680L;
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash(doubleArray0);
    MathUtils.sign((float) 395698079);
    MathUtils.subAndCheck((-377L), (-377L));
    MathUtils.gcd(395698079, 395698079);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(395698079);
    MathUtils.round((float) (-3840L), 395698079, 1);
    MathUtils.sign(Float.NaN);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test115138() throws Throwable {
    MathUtils.sign((-815.850163223983));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 1447680L;
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash((double[]) null);
    MathUtils.sign((float) 0);
    MathUtils.subAndCheck((-377L), 1L);
    MathUtils.gcd(0, 0);
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign(0);
    MathUtils.round((float) (-3840L), 0, 1);
    MathUtils.mulAndCheck(2964, 2972);
    MathUtils.indicator((-1.0));
    MathUtils.nextAfter((-3839.0F), (-1.0));
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test116139() throws Throwable {
    MathUtils.log(0.0, 0.0);
    MathUtils.cosh(Double.NaN);
    MathUtils.subAndCheck(3463L, (-2147483648L));
    MathUtils.nextAfter(Double.NaN, 0.0);
    MathUtils.binomialCoefficientLog(356, 356);
    MathUtils.sign(356);
    MathUtils.sign(2147483648L);
    MathUtils.binomialCoefficientLog(2803, 1);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""result too large to represent in a long integer"");
    }
    return result;
}","public void test117140() throws Throwable {
    MathUtils.log(0.0, 0.0);
    double double0 = MathUtils.SAFE_MIN;
    MathUtils.subAndCheck(3463L, (-2147483648L));
    MathUtils.nextAfter(Double.NaN, 0.15728391532667219);
    MathUtils.binomialCoefficientLog(356, 356);
    MathUtils.sign(356);
    MathUtils.gcd(356, 356);
    // Undeclared exception!
    MathUtils.factorial(2147483645);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test118141() throws Throwable {
    MathUtils.sign((-816.297189));
    MathUtils.mulAndCheck((-3840L), (-377L));
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 1447680L;
    doubleArray0[1] = (double) (-377L);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1.0);
    doubleArray0[4] = (-1.0);
    MathUtils.hash((-1.0));
    MathUtils.sign((float) (-1074790400));
    MathUtils.subAndCheck((-377L), 1L);
    MathUtils.gcd((-1074790400), (-1074790400));
    MathUtils.equals(doubleArray0, doubleArray0);
    MathUtils.sign((-2145386496));
    MathUtils.round((float) (-3840L), (-1074790400), 1);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test119142() throws Throwable {
    MathUtils.log(0.0, 0.0);
    MathUtils.cosh(Double.NaN);
    // Undeclared exception!
    try {
        MathUtils.subAndCheck(3463L, (-9223372036854775780L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test120143() throws Throwable {
    MathUtils.nextAfter(4.9E-324, 0.0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 4.9E-324;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = 0.0;
    MathUtils.hash(doubleArray0);
    MathUtils.indicator((byte) 0);
    MathUtils.sign(1530.2847F);
    MathUtils.scalb(0.0, (byte) 0);
    MathUtils.gcd((byte) 1, (-1));
    MathUtils.round(0.0, 1083);
    MathUtils.sign(1814L);
    MathUtils.indicator((float) 1);
    MathUtils.indicator((long) 1083);
    MathUtils.sign((byte) (-111));
    MathUtils.factorialDouble(1083);
    // Undeclared exception!
    MathUtils.binomialCoefficientLog(28658942, (byte) (-111));
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test121144() throws Throwable {
    MathUtils.indicator((-4138L));
    MathUtils.gcd(31, 31);
    MathUtils.cosh((-1L));
    // Undeclared exception!
    try {
        MathUtils.subAndCheck(9223372036854775807L, (-1572L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test122145() throws Throwable {
    int int0 = 7449;
    // Undeclared exception!
    try {
        MathUtils.subAndCheck(7449, (-2147483645));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
