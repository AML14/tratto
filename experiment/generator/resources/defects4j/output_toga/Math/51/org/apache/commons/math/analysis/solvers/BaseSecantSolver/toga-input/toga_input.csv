focal_method,test_prefix,docstring
"public double getStartValue() {
    return searchStart;
}","public void test000() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1785.980494615, 227.421396);
    Ceil ceil0 = new Ceil();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(1024, (UnivariateRealFunction) ceil0, (-4088.1339917), (double) 1024, allowedSolution0);
    assertEquals((-1532.0669958499998), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test001() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1785.980494615, 227.421396);
    Ceil ceil0 = new Ceil();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(1024, (UnivariateRealFunction) ceil0, (-4088.1339917), (double) 1024, allowedSolution0);
    assertEquals((-0.026840277934297774), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test012() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver(0.0);
    Rint rint0 = new Rint();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = illinoisSolver0.solve(31, (UnivariateRealFunction) rint0, (double) 31, 1.176342548272881E-8, (-1.5707963267948966), allowedSolution0);
    assertEquals((-1.5707963267948966), illinoisSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test013() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver(0.0);
    Rint rint0 = new Rint();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = illinoisSolver0.solve(31, (UnivariateRealFunction) rint0, (double) 31, 1.176342548272881E-8, (-1.5707963267948966), allowedSolution0);
    assertEquals(1.176342548272881E-8, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test024() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    UnivariateRealFunction univariateRealFunction0 = sigmoid0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(3333, univariateRealFunction0, (-2993.2715265), 549.77032, allowedSolution0);
    assertEquals(549.77032, pegasusSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test025() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    UnivariateRealFunction univariateRealFunction0 = sigmoid0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(3333, univariateRealFunction0, (-2993.2715265), 549.77032, allowedSolution0);
    assertEquals((-2993.2715265), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test036() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966));
    Identity identity0 = new Identity();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = illinoisSolver0.solve(2432, (UnivariateRealFunction) identity0, (-1.5707963267948966), 0.0, allowedSolution0);
    assertEquals((-0.7853981633974483), illinoisSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test037() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966));
    Identity identity0 = new Identity();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = illinoisSolver0.solve(2432, (UnivariateRealFunction) identity0, (-1.5707963267948966), 0.0, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test048() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-864.2), (-2125.2));
    Log1p log1p0 = new Log1p();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = illinoisSolver0.solve(2, (UnivariateRealFunction) log1p0, 0.0, (double) 2, 2012.456450328, allowedSolution0);
    assertEquals(2012.456450328, illinoisSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test049() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-864.2), (-2125.2));
    Log1p log1p0 = new Log1p();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = illinoisSolver0.solve(2, (UnivariateRealFunction) log1p0, 0.0, (double) 2, 2012.456450328, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test0510() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian(23, 0.14982303977012634, 4009.763325487);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(23, univariateRealFunction0, (-3044.2), 4009.763325487, (-0.1666666567325592));
    assertEquals((-0.1666666567325592), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test0511() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian(23, 0.14982303977012634, 4009.763325487);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(23, univariateRealFunction0, (-3044.2), 4009.763325487, (-0.1666666567325592));
    assertEquals(0.14982303977170247, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test0612() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test0613() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, regulaFalsiSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"public double getStartValue() {
    return searchStart;
}","public void test0614() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, regulaFalsiSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double getMax() {
    return searchMax;
}","public void test0715() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    pegasusSolver0.solve(3333, (UnivariateRealFunction) sigmoid0, (-2993.2715265), 549.77032, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals(549.77032, pegasusSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test0716() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    pegasusSolver0.solve(3333, (UnivariateRealFunction) sigmoid0, (-2993.2715265), 549.77032, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals((-702.9609497129845), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test0817() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-69.934811), (-69.934811));
    Atanh atanh0 = new Atanh();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        illinoisSolver0.solve(1, (UnivariateRealFunction) atanh0, (-2621.940926377), (-269.5762), allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (1) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test0918() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462), 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve((-742), (UnivariateRealFunction) sinc0, (-3332.0), (-4025.304530957489), 2879.14725, allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (-742) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1019() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-4.8559), (-4.8559));
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(5, (UnivariateRealFunction) cbrt0, (-4.8559), (-465.9968625720741), 1331.339230942915, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [-4.856, -465.997]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1120() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver();
    Floor floor0 = new Floor();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        regulaFalsiSolver0.solve(2979, (UnivariateRealFunction) floor0, 359.7455671164, (double) 2979, (double) 2979, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [359.746, 2,979], values: [359, 2,979]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1221() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.0), (-360.0));
    Sinc sinc0 = new Sinc();
    // Undeclared exception!
    try {
        pegasusSolver0.solve(38, (UnivariateRealFunction) sinc0, 46.042916482279, 951.9258407496, 951.9258407496, (AllowedSolution) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseSecantSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1322() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    // Undeclared exception!
    try {
        pegasusSolver0.solve((-3237), (UnivariateRealFunction) gaussian0, 6.4281638347818415E-6, 1.9868161777724352E-8, 1055.616);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (-3,237) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1423() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-358.62330608936577), 2725.29567932, 3128.7);
    Floor floor0 = new Floor();
    // Undeclared exception!
    try {
        pegasusSolver0.solve(791, (UnivariateRealFunction) floor0, (double) 791, (-0.12502530217170715), (double) 791);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [791, -0.125]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1524() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966), (-1.5707963267948966));
    Identity identity0 = new Identity();
    // Undeclared exception!
    try {
        illinoisSolver0.solve(2432, (UnivariateRealFunction) identity0, (double) (-32), (-1.5707963267948966), 0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [-32, -1.571], values: [-32, -1.571]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1625() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, (-360.07737924462), 2725.29567932);
    // Undeclared exception!
    try {
        pegasusSolver0.doSolve();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1726() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(0.0, 0.0036);
    Cosh cosh0 = new Cosh();
    regulaFalsiSolver0.setup(3542, cosh0, 0.0036, 0.0036, 0.0036);
    // Undeclared exception!
    try {
        regulaFalsiSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [0.004, 0.004]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1827() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.0));
    Sinc sinc0 = new Sinc();
    pegasusSolver0.setup(38, sinc0, 0.0, 46.042916482279, 0.0);
    // Undeclared exception!
    try {
        pegasusSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [0, 46.043], values: [1, 0.019]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1928() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.07737924462));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9025767054369, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2029() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(38, (UnivariateRealFunction) sinc0, 46.042916482279, 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9258407496, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2030() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(38, (UnivariateRealFunction) sinc0, 46.042916482279, 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9258407496, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2131() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(5.549536715928331E21, 372.48719237534914);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(503, (UnivariateRealFunction) sinc0, 46.73805687525366, 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9258407496, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2132() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(5.549536715928331E21, 372.48719237534914);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(503, (UnivariateRealFunction) sinc0, 46.73805687525366, 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(949.1866901926965, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2233() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, (-360.07737924462), 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2760.7), (double) 5, (-873.93), allowedSolution0);
    assertEquals((-873.93), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2234() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, (-360.07737924462), 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2760.7), (double) 5, (-873.93), allowedSolution0);
    assertEquals((-2760.7), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2335() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    double double0 = pegasusSolver0.solve(62, (UnivariateRealFunction) sinc0, 46.042916482279, (double) 62, (double) 62, allowedSolution0);
    assertEquals(62.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2336() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(3128.7, (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    double double0 = pegasusSolver0.solve(62, (UnivariateRealFunction) sinc0, 46.042916482279, (double) 62, (double) 62, allowedSolution0);
    assertEquals(55.88031929884201, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2437() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462), 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(106, (UnivariateRealFunction) sinc0, (-360.07737924462), 3128.7, 3128.7, allowedSolution0);
    assertEquals(3128.7, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2438() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462), 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(106, (UnivariateRealFunction) sinc0, (-360.07737924462), 3128.7, 3128.7, allowedSolution0);
    assertEquals(2996.160705657151, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2539() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.304E19, 1.304E19, 1.304E19);
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(156, (UnivariateRealFunction) cbrt0, (double) (-1720), (double) 156, allowedSolution0);
    assertEquals((-782.0), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test2540() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.304E19, 1.304E19, 1.304E19);
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(156, (UnivariateRealFunction) cbrt0, (double) (-1720), (double) 156, allowedSolution0);
    assertEquals(156.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2641() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, (-360.07737924462), 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-1.3550045623978706), 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9258407496, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2642() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, (-360.07737924462), 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-1.3550045623978706), 951.9258407496, 951.9258407496, allowedSolution0);
    assertEquals(951.9258407496, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2743() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.0), (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    pegasusSolver0.solve(38, (UnivariateRealFunction) sinc0, 46.04291648228, 951.9258407496, 951.9258407496, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals(46.04291648228, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // Update formula cannot make any progress: Update the
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test2744() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.0), (-360.0));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    pegasusSolver0.solve(38, (UnivariateRealFunction) sinc0, 46.04291648228, 951.9258407496, 951.9258407496, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals(951.9025740377073, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2845() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.592266061490975E-31);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(45, (UnivariateRealFunction) sinc0, 1.0E-6, 2435.9021, 2435.9021, allowedSolution0);
    assertEquals(2435.9021, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2846() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.592266061490975E-31);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(45, (UnivariateRealFunction) sinc0, 1.0E-6, 2435.9021, 2435.9021, allowedSolution0);
    assertEquals(2434.73430653209, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2947() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.792510290788597);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(8, univariateRealFunction0, (-808.9), 2719.82, (double) 8);
    assertEquals(8.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test2948() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.792510290788597);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(8, univariateRealFunction0, (-808.9), 2719.82, (double) 8);
    assertEquals((-5.0293312186144856E-5), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test3049() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(2159.7025852, 2211.438, (-1222.0));
    Sigmoid sigmoid0 = new Sigmoid(2211.438, (-1.0));
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = regulaFalsiSolver0.solve(654, (UnivariateRealFunction) sigmoid0, (-1.0), 2417.36304, (-1521.557701816037), allowedSolution0);
    assertEquals((-1.0), regulaFalsiSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test3050() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(2159.7025852, 2211.438, (-1222.0));
    Sigmoid sigmoid0 = new Sigmoid(2211.438, (-1.0));
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = regulaFalsiSolver0.solve(654, (UnivariateRealFunction) sigmoid0, (-1.0), 2417.36304, (-1521.557701816037), allowedSolution0);
    assertEquals(2415.867843712599, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test3151() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.3217759706711633E-11, 1.3217759706711633E-11, 1.3217759706711633E-11);
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(517, (UnivariateRealFunction) cbrt0, (-1206.289937), (double) 156, allowedSolution0);
    assertEquals(156.0, pegasusSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3152() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1.3217759706711633E-11, 1.3217759706711633E-11, 1.3217759706711633E-11);
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(517, (UnivariateRealFunction) cbrt0, (-1206.289937), (double) 156, allowedSolution0);
    assertEquals(4.44778868193722E-12, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, FUNC f, double min, double max) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min));
}","public void test3253() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966));
    Sinh sinh0 = new Sinh();
    // Undeclared exception!
    try {
        illinoisSolver0.solve(2432, (UnivariateRealFunction) sinh0, (-1.5707963267948966), (double) 2432);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (2,432) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3354() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0, 0.0, 0.0);
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(0, (UnivariateRealFunction) null, (double) 0, (-1645.0), allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3455() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian(23, 0.14982303977012634, 4009.763325487);
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(23, (UnivariateRealFunction) gaussian0, 4009.763325487, 5.0, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [4,009.763, 5]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
