focal_method,test_prefix,docstring
"public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return eigenvectors[i].copy();
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[20];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[1] = (-2065.058);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-900.97647));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    eigenDecompositionImpl0.getEigenvector(2);
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test011() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 1.6383884420078756E-37;
    doubleArray0[1] = 1510.81728832192;
    doubleArray0[2] = 1510.81728832192;
    doubleArray0[4] = 2272.14048519;
    doubleArray0[5] = 1.6383884420078756E-37;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-118.1102369));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 1699.3407);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test022() throws Throwable {
    double[] doubleArray0 = new double[0];
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray0, 0.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test033() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    eigenDecompositionImpl0.getRealEigenvalue(0);
}","/**
 * {@inheritDoc}
 */"
"public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return imagEigenvalues[i];
}","public void test044() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    eigenDecompositionImpl0.getImagEigenvalue(0);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test055() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    eigenDecompositionImpl0.getDeterminant();
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test066() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1715049633601);
    eigenDecompositionImpl0.getDeterminant();
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealMatrix getVT() throws InvalidMatrixException {
    if (cachedVt == null) {
        if (eigenvectors == null) {
            findEigenVectors();
        }
        final int m = eigenvectors.length;
        cachedVt = MatrixUtils.createRealMatrix(m, m);
        for (int k = 0; k < m; ++k) {
            cachedVt.setRowVector(k, eigenvectors[k]);
        }
    }
    // return the cached matrix
    return cachedVt;
}","public void test077() throws Throwable {
    double[] doubleArray0 = new double[23];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    // Undeclared exception!
    eigenDecompositionImpl0.getVT();
}","/**
 * {@inheritDoc}
 */"
"public DecompositionSolver getSolver() {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);
}","public void test088() throws Throwable {
    double[] doubleArray0 = new double[22];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    // Undeclared exception!
    eigenDecompositionImpl0.getSolver();
}","/**
 * {@inheritDoc}
 */"
"public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return eigenvectors[i].copy();
}","public void test099() throws Throwable {
    double[] doubleArray0 = new double[22];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1123.955770734739));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    // Undeclared exception!
    eigenDecompositionImpl0.getEigenvector(2);
}","/**
 * {@inheritDoc}
 */"
"public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return eigenvectors[i].copy();
}","public void test1010() throws Throwable {
    double[] doubleArray0 = new double[1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.563);
    try {
        eigenDecompositionImpl0.getEigenvector(4959);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4959
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test1111() throws Throwable {
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl((double[]) null, (double[]) null, 1294.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test1212() throws Throwable {
    double[] doubleArray0 = new double[5];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // a 5x1 matrix was provided instead of a square matrix
        //
        verifyException(""org.apache.commons.math.linear.TriDiagonalTransformer"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test1313() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 3991);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // no entry at indices (1, 0) in a 1x3,991 matrix
        //
        verifyException(""org.apache.commons.math.linear.Array2DRowRealMatrix"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test1414() throws Throwable {
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl((RealMatrix) null, 2028.36210992623);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test1515() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-603.0));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.TriDiagonalTransformer"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test1616() throws Throwable {
    double[] doubleArray0 = new double[0];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-2311.031969662));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.linear.Array2DRowRealMatrix"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public RealMatrix getVT() throws InvalidMatrixException {
    if (cachedVt == null) {
        if (eigenvectors == null) {
            findEigenVectors();
        }
        final int m = eigenvectors.length;
        cachedVt = MatrixUtils.createRealMatrix(m, m);
        for (int k = 0; k < m; ++k) {
            cachedVt.setRowVector(k, eigenvectors[k]);
        }
    }
    // return the cached matrix
    return cachedVt;
}","public void test1717() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[3] = 137.40041351;
    doubleArray0[2] = (-2313.34540487357);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    RealMatrix realMatrix1 = eigenDecompositionImpl0.getVT();
    assertNotSame(realMatrix0, realMatrix1);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test1818() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(2219.6592927939664, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test1919() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2526.563292244789;
    doubleArray0[3] = 137.40041351;
    doubleArray0[2] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2020() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(-0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2121() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(1.80800278215138E-39, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2222() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(2);
    assertEquals(2.6355465548414414E-24, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test2223() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(2);
    assertEquals((-5.6919029625047266E-11), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2324() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[1] = (-2065.058);
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    assertEquals(1.6411208230732223E-24, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2425() throws Throwable {
    double[] doubleArray0 = new double[20];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[1] = (-2065.058);
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-900.97647);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-900.97647));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    assertEquals(-0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2526() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(1.7833470828746292E-42, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test2627() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[1] = (-2065.058);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    openMapRealVector0.mapLog1pToSelf();
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        //
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2728() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(-0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2829() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test2930() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals((-3.673419846319966E-40), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test3031() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // cannot solve degree 3 equation
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"boolean isNonSingular();","public void test3132() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    DecompositionSolver decompositionSolver0 = eigenDecompositionImpl0.getSolver();
    assertFalse(decompositionSolver0.isNonSingular());
}","/**
 * Check if the decomposed matrix is non-singular.
 * @return true if the decomposed matrix is non-singular
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test3233() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    eigenDecompositionImpl0.getV();
    eigenDecompositionImpl0.getSolver();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test3334() throws Throwable {
    double[] doubleArray0 = new double[1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"boolean isNaN();","public void test3435() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    eigenDecompositionImpl0.getV();
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(2);
    assertTrue(realVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test3738() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    eigenDecompositionImpl0.getD();
    eigenDecompositionImpl0.getD();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test3940() throws Throwable {
    double[] doubleArray0 = new double[5];
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray0, 0.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test4041() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[1] = 3896.0;
    double[][] doubleArray1 = new double[5][3];
    doubleArray1[0] = doubleArray0;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray1, true);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 3896.0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // eigen decomposition of assymetric matrices not supported yet
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double[] getRealEigenvalues() throws InvalidMatrixException {
    return realEigenvalues.clone();
}","public void test4142() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    double[] doubleArray1 = eigenDecompositionImpl0.getRealEigenvalues();
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test4243() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-900.97647));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    try {
        eigenDecompositionImpl0.getRealEigenvalue((-3));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return imagEigenvalues[i];
}","public void test4344() throws Throwable {
    double[] doubleArray0 = new double[4];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, (-2065.058));
    try {
        eigenDecompositionImpl0.getImagEigenvalue(4);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test4445() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    eigenDecompositionImpl0.getImagEigenvalues();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
