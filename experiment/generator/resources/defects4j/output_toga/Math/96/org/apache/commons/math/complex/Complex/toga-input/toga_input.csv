focal_method,test_prefix,docstring
"public Complex acos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(this.sqrt1z().multiply(Complex.I)).log().multiply(Complex.I.negate());
}","public void test000() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.INF.log();
    Complex complex2 = complex0.subtract((Complex) null);
    Complex complex3 = complex2.sqrt1z();
    Complex complex4 = complex3.sin();
    complex4.NaN.sqrt();
    Complex complex5 = complex0.I.tan();
    Complex complex6 = complex5.I.sin();
    complex0.I.cosh();
    complex5.INF.multiply(complex3);
    Complex complex7 = complex2.sqrt();
    complex7.ONE.divide(complex1);
    Complex complex8 = Complex.NaN;
    complex2.conjugate();
    complex6.getReal();
    complex8.exp();
    complex7.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse cosine of this complex number
 * @since 1.2
 */"
"public Complex sin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.sin(real) * MathUtils.cosh(imaginary), Math.cos(real) * MathUtils.sinh(imaginary));
}","public void test011() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.sqrt1z();
    Complex complex2 = complex1.ZERO.exp();
    Complex complex3 = complex0.atan();
    Complex complex4 = complex0.multiply(complex3);
    complex1.equals(complex4);
    complex1.equals(complex0);
    Complex complex5 = complex4.subtract(complex0);
    complex5.NaN.tanh();
    complex5.ONE.createComplex(1.0, 1.0);
    Complex complex6 = Complex.ZERO;
    Complex complex7 = complex0.divide(complex6);
    Complex complex8 = new Complex(1.0, 1.0);
    Complex complex9 = complex3.log();
    complex4.abs();
    complex2.ONE.sin();
    Complex complex10 = complex2.subtract(complex1);
    complex0.isNaN();
    complex0.equals(""U%v"");
    complex9.atan();
    complex7.tanh();
    complex10.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 * sin(&plusmn;INFINITY + i) = NaN + NaN i
 * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test022() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.sinh();
    Complex complex2 = complex0.divide(complex0);
    complex2.acos();
    Complex complex3 = complex0.exp();
    complex1.equals(complex0);
    complex0.ONE.sinh();
    complex0.cosh();
    Complex complex4 = Complex.I;
    complex4.INF.cosh();
    complex3.divide(complex4);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test033() throws Throwable {
    Complex complex0 = new Complex(Double.NaN, Double.NaN);
    Complex complex1 = complex0.sinh();
    complex0.divide(complex1);
    complex1.equals(complex1);
    Complex complex2 = complex1.cosh();
    complex1.subtract(complex2);
    complex0.divide(complex0);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test044() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.I.sinh();
    Complex complex2 = complex0.cosh();
    Complex complex3 = Complex.INF;
    Complex complex4 = complex3.NaN.asin();
    complex4.INF.add(complex2);
    Complex complex5 = complex2.INF.createComplex((-1468.73531619093), (-1468.73531619093));
    complex0.INF.sinh();
    Complex complex6 = complex5.sqrt();
    Complex complex7 = complex2.INF.acos();
    complex2.ZERO.pow(complex1);
    complex3.I.sqrt();
    Complex complex8 = Complex.NaN;
    Complex complex9 = complex8.NaN.negate();
    Complex complex10 = complex0.pow(complex8);
    complex8.I.pow(complex3);
    complex8.isNaN();
    complex0.divide(complex9);
    complex8.NaN.sqrt1z();
    Complex complex11 = complex7.ZERO.tanh();
    Complex complex12 = Complex.INF;
    complex10.log();
    complex6.multiply(complex12);
    Complex complex13 = complex9.negate();
    complex13.NaN.add(complex11);
    complex9.hashCode();
    complex1.abs();
    Complex complex14 = complex1.cosh();
    complex14.getReal();
    Complex complex15 = complex1.atan();
    complex15.add(complex6);
    complex6.divide(complex2);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex tanh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
}","public void test055() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.tanh();
    complex1.NaN.subtract(complex0);
    Complex complex2 = complex0.I.log();
    Complex complex3 = complex2.I.sin();
    Complex complex4 = complex0.I.tanh();
    Complex complex5 = complex3.I.divide(complex4);
    complex2.ONE.asin();
    complex0.negate();
    complex0.equals((Object) null);
    complex3.conjugate();
    Complex complex6 = complex2.exp();
    Complex complex7 = complex5.cos();
    complex0.equals(complex1);
    Complex complex8 = complex6.NaN.cos();
    complex0.sinh();
    complex1.cos();
    complex8.isInfinite();
    complex8.multiply(complex1);
    complex7.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + i) = NaN + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>
 *
 * @return the hyperbolic tangent of this complex number
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test066() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.pow((Complex) null);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public Complex atan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(Complex.I).divide(Complex.I.subtract(this)).log().multiply(Complex.I.divide(createComplex(2.0, 0.0)));
}","public void test077() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.exp();
    Complex complex2 = complex0.INF.pow(complex1);
    complex0.isInfinite();
    complex1.multiply(complex0);
    Complex complex3 = complex0.createComplex(768.44308694, Double.POSITIVE_INFINITY);
    complex3.exp();
    complex3.isNaN();
    Complex complex4 = new Complex(Double.POSITIVE_INFINITY, 768.44308694);
    complex3.pow(complex4);
    complex2.exp();
    complex3.atan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public Complex sinh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(MathUtils.sinh(real) * Math.cos(imaginary), MathUtils.cosh(real) * Math.sin(imaginary));
}","public void test088() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.exp();
    complex0.isInfinite();
    Complex complex2 = complex1.NaN.divide(complex1);
    Complex complex3 = complex0.NaN.tan();
    Complex complex4 = Complex.ONE;
    complex3.ZERO.pow(complex4);
    Complex complex5 = complex1.conjugate();
    complex5.hashCode();
    Complex complex6 = complex1.sqrt1z();
    Complex complex7 = complex1.cosh();
    complex6.NaN.pow(complex0);
    complex6.ZERO.sinh();
    complex6.ZERO.exp();
    Complex complex8 = complex1.negate();
    complex3.abs();
    complex1.ONE.hashCode();
    Complex complex9 = complex8.cosh();
    complex0.asin();
    Complex complex10 = Complex.NaN;
    complex2.tanh();
    Complex complex11 = complex6.atan();
    complex11.I.pow(complex9);
    complex8.cos();
    complex11.isInfinite();
    Complex complex12 = complex7.createComplex((-8.333741798626477), Double.NaN);
    complex12.negate();
    complex10.negate();
    complex9.sinh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"" TARGET=""_top"">
 * hyperbolic sine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the hyperbolic sine of this complex number
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test099() throws Throwable {
    Complex complex0 = new Complex(10.0, (-3432.05322));
    Complex complex1 = complex0.I.createComplex(7.544137102816978, 7.544137102816978);
    Complex complex2 = new Complex(7.544137102816978, 7.544137102816978);
    Complex complex3 = complex2.ONE.pow(complex0);
    Complex complex4 = complex2.INF.createComplex(10.0, 7.544137102816978);
    Complex complex5 = complex1.sqrt1z();
    Complex complex6 = complex2.ONE.sinh();
    Complex complex7 = complex6.ZERO.negate();
    complex5.NaN.negate();
    Complex complex8 = complex7.INF.tan();
    complex0.ONE.hashCode();
    complex5.INF.log();
    Complex complex9 = complex0.subtract(complex2);
    Complex complex10 = new Complex(7.544137102816978, 7.544137102816978);
    complex1.abs();
    Complex complex11 = complex8.tanh();
    Complex complex12 = Complex.ONE;
    Complex complex13 = complex9.acos();
    complex11.conjugate();
    complex10.subtract(complex13);
    complex4.sinh();
    complex6.sin();
    complex3.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex tanh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
}","public void test1010() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.exp();
    Complex complex2 = complex0.NaN.asin();
    Complex complex3 = complex0.tanh();
    Complex complex4 = complex3.ONE.sqrt1z();
    complex0.abs();
    Complex complex5 = complex1.ZERO.createComplex(3644.6161, Double.POSITIVE_INFINITY);
    Complex complex6 = complex0.NaN.subtract(complex1);
    Complex complex7 = complex6.INF.exp();
    Complex complex8 = complex0.pow(complex2);
    Complex complex9 = complex8.ONE.subtract(complex0);
    complex8.NaN.conjugate();
    complex4.add(complex6);
    Complex complex10 = complex9.INF.multiply(complex5);
    Complex complex11 = Complex.ZERO;
    Complex complex12 = complex8.INF.pow(complex11);
    Complex complex13 = complex12.NaN.cosh();
    complex13.ONE.conjugate();
    Complex complex14 = complex5.atan();
    complex14.I.createComplex(3644.6161, Double.POSITIVE_INFINITY);
    complex14.INF.tanh();
    Complex complex15 = complex7.atan();
    complex15.getReal();
    complex9.log();
    Complex complex16 = complex8.sqrt1z();
    complex16.ZERO.multiply(complex5);
    Complex complex17 = complex5.acos();
    Complex complex18 = complex17.INF.tanh();
    complex18.I.atan();
    Complex complex19 = complex18.INF.conjugate();
    complex19.conjugate();
    complex2.abs();
    complex10.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + i) = NaN + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>
 *
 * @return the hyperbolic tangent of this complex number
 * @since 1.2
 */"
"public Complex sqrt1z() {
    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
}","public void test1111() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.ONE.tanh();
    Complex complex2 = complex1.ZERO.sqrt1z();
    Complex complex3 = complex0.NaN.sinh();
    Complex complex4 = complex0.INF.tan();
    complex4.INF.tan();
    complex4.NaN.createComplex(1.0, 1421.5139215);
    Complex complex5 = complex0.negate();
    complex1.ONE.negate();
    Complex complex6 = complex5.NaN.divide(complex3);
    Complex complex7 = complex5.tan();
    Complex complex8 = complex7.NaN.divide(complex1);
    complex6.NaN.createComplex(2165.6319138356293, 0.8813735870195429);
    complex8.INF.hashCode();
    complex6.NaN.conjugate();
    Complex complex9 = complex0.conjugate();
    complex3.add(complex6);
    complex2.asin();
    Complex complex10 = complex9.pow(complex2);
    complex9.tan();
    Complex complex11 = complex10.atan();
    Complex complex12 = complex11.cosh();
    Complex complex13 = complex10.negate();
    complex9.tanh();
    complex10.createComplex(1.0, 1.0);
    complex0.log();
    Complex complex14 = complex12.pow(complex13);
    complex14.sqrt1z();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex
 * number.
 * <p>
 * Computes the result directly as
 * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.</p>
 *
 * @return the square root of 1 - <code>this</code><sup>2</sup>
 * @since 1.2
 */"
"public Complex conjugate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test1212() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.conjugate();
}","/**
 * Return the conjugate of this complex number. The conjugate of
 * ""A + Bi"" is ""A - Bi"".
 * <p>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 * <p>
 * If the imaginary part is infinite, and the real part is not NaN,
 * the returned value has infinite imaginary part of the opposite
 * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
 * is <code>1 - NEGATIVE_INFINITY i</code></p>
 *
 * @return the conjugate of this Complex object
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test1313() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.I.log();
    complex1.I.createComplex((-390.83975926481037), (-390.83975926481037));
    complex1.NaN.sqrt1z();
    Complex complex2 = complex0.cosh();
    complex0.INF.sqrt1z();
    complex2.getImaginary();
    Complex complex3 = complex1.acos();
    complex2.add(complex3);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex asin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return sqrt1z().add(this.multiply(Complex.I)).log().multiply(Complex.I.negate());
}","public void test1414() throws Throwable {
    Complex complex0 = new Complex((-1.0), (-1.0));
    complex0.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public double getReal() {
    return real;
}","public void test1515() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.I.hashCode();
    Complex complex1 = complex0.sqrt();
    complex1.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part
 */"
"public Complex sin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.sin(real) * MathUtils.cosh(imaginary), Math.cos(real) * MathUtils.sinh(imaginary));
}","public void test1616() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.acos();
    Complex complex2 = complex1.NaN.tan();
    complex0.getReal();
    complex1.isNaN();
    Complex complex3 = complex1.conjugate();
    complex3.multiply(complex0);
    Complex complex4 = complex0.sqrt();
    Complex complex5 = complex4.NaN.add(complex2);
    Complex complex6 = complex5.NaN.sqrt();
    complex6.NaN.hashCode();
    complex1.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 * sin(&plusmn;INFINITY + i) = NaN + NaN i
 * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public Complex conjugate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test1717() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.asin();
    complex0.subtract(complex1);
    complex0.conjugate();
}","/**
 * Return the conjugate of this complex number. The conjugate of
 * ""A + Bi"" is ""A - Bi"".
 * <p>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 * <p>
 * If the imaginary part is infinite, and the real part is not NaN,
 * the returned value has infinite imaginary part of the opposite
 * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
 * is <code>1 - NEGATIVE_INFINITY i</code></p>
 *
 * @return the conjugate of this Complex object
 */"
"public Complex acos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(this.sqrt1z().multiply(Complex.I)).log().multiply(Complex.I.negate());
}","public void test1818() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.INF;
    complex1.multiply(complex0);
    Complex complex2 = complex0.NaN.subtract(complex1);
    complex2.NaN.cos();
    Complex complex3 = complex0.atan();
    Complex complex4 = complex3.NaN.tanh();
    complex1.acos();
    Complex complex5 = complex4.sin();
    complex5.divide(complex3);
    complex4.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse cosine of this complex number
 * @since 1.2
 */"
"public Complex tanh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
}","public void test1919() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.tan();
    complex0.log();
    complex0.cos();
    complex1.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + i) = NaN + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>
 *
 * @return the hyperbolic tangent of this complex number
 * @since 1.2
 */"
"public Complex negate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test2020() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.ZERO.tanh();
    complex0.I.divide(complex1);
    Complex complex2 = complex0.sqrt();
    complex2.negate();
}","/**
 * Return the additive inverse of this complex number.
 * <p>
 * Returns <code>Complex.NaN</code> if either real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 *
 * @return the negation of this complex number
 */"
"public Complex cosh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(MathUtils.cosh(real) * Math.cos(imaginary), MathUtils.sinh(real) * Math.sin(imaginary));
}","public void test2121() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.cos();
    Complex complex1 = complex0.tanh();
    complex1.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test2222() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex0.divide(complex1);
    complex1.getImaginary();
    complex2.pow(complex1);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public boolean isInfinite() {
    return !isNaN() && (Double.isInfinite(real) || Double.isInfinite(imaginary));
}","public void test2323() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.ONE.acos();
    complex0.isInfinite();
}","/**
 * Returns true if either the real or imaginary part of this complex number
 * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or
 * <code>Double.NEGATIVE_INFINITY</code>) and neither part
 * is <code>NaN</code>.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is <code>NaN</code>
 */"
"public Complex sin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.sin(real) * MathUtils.cosh(imaginary), Math.cos(real) * MathUtils.sinh(imaginary));
}","public void test2424() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.NaN.cosh();
    complex0.getReal();
    Complex complex2 = complex1.atan();
    complex0.multiply(complex2);
    complex1.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 * sin(&plusmn;INFINITY + i) = NaN + NaN i
 * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test2525() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.NaN.sinh();
    Complex complex2 = complex0.NaN.tan();
    complex0.isInfinite();
    complex0.abs();
    complex2.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test2626() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.ONE;
    complex0.equals(complex1);
    complex0.createComplex(0.0, (-1264.8377));
    complex1.add(complex0);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex sqrt() {
    if (isNaN()) {
        return Complex.NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(Math.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test2727() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.atan();
    complex1.pow(complex0);
    complex1.sinh();
    complex0.ZERO.tanh();
    complex1.cos();
    complex0.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * <p>
 * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:
 * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>
 * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>
 *  else return <code>|b|/2t + sign(b)t i </code></pre></li>
 * </ol>
 * where <ul>
 * <li><code>|a| = {@link Math#abs}(a)</code></li>
 * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>
 * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>
 * </ul></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 * </code></pre></p>
 *
 * @return the square root of this complex number
 * @since 1.2
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test2828() throws Throwable {
    Complex complex0 = new Complex(2421.19, 2421.19);
    Complex complex1 = complex0.ONE.exp();
    complex0.ONE.tan();
    complex1.ONE.pow(complex0);
    complex0.isInfinite();
    Object object0 = new Object();
    complex0.equals(object0);
}","/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */"
"protected Complex createComplex(double real, double imaginary) {
    return new Complex(real, imaginary);
}","public void test2929() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.INF.log();
    Complex complex1 = complex0.conjugate();
    Complex complex2 = complex1.sinh();
    complex2.asin();
    complex1.cosh();
    complex0.asin();
    complex1.createComplex((-812.52763692), 0.0);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param real the real part
 * @param imaginary the imaginary part
 * @return a new complex number instance
 * @since 1.2
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test3030() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.INF.exp();
    complex1.ONE.hashCode();
    Complex complex2 = Complex.ONE;
    complex0.divide(complex2);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex multiply(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(rhs.real) || Double.isInfinite(rhs.imaginary)) {
        // we don't use Complex.isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * rhs.real - imaginary * rhs.imaginary, real * rhs.imaginary + imaginary * rhs.real);
}","public void test3131() throws Throwable {
    Complex complex0 = new Complex(5311.3745360906, 0.0);
    complex0.tan();
    complex0.sinh();
    Complex complex1 = complex0.asin();
    complex1.multiply(complex0);
}","/**
 * Return the product of this complex number and the given complex number.
 * <p>
 * Implements preliminary checks for NaN and infinity followed by
 * the definitional formula:
 * <pre><code>
 * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 * </code></pre>
 * </p>
 * <p>
 * Returns {@link #NaN} if either this or <code>rhs</code> has one or more
 * NaN parts.
 * </p>
 * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more
 * NaN parts and if either this or <code>rhs</code> has one or more
 * infinite parts (same result is returned regardless of the sign of the
 * components).
 * </p>
 * <p>
 * Returns finite values in components of the result per the
 * definitional formula in all remaining cases.
 *  </p>
 *
 * @param rhs the other complex number
 * @return the complex number product
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex tanh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
}","public void test3232() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.INF.acos();
    complex1.I.log();
    Complex complex2 = complex0.multiply(complex1);
    complex2.I.tan();
    Complex complex3 = complex0.pow((Complex) null);
    // Undeclared exception!
    try {
        complex3.INF.tanh();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + i) = NaN + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>
 *
 * @return the hyperbolic tangent of this complex number
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test3333() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.INF.acos();
    Complex complex2 = complex0.atan();
    Complex complex3 = complex2.ZERO.sin();
    complex2.sqrt();
    complex2.cosh();
    complex3.pow(complex1);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test3434() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    Complex complex1 = Complex.INF;
    complex0.divide(complex1);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex sqrt() {
    if (isNaN()) {
        return Complex.NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(Math.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test3535() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.ZERO.sin();
    complex0.abs();
    complex0.ONE.cos();
    complex0.asin();
    complex0.equals(complex1);
    Complex complex2 = complex1.conjugate();
    Complex complex3 = complex2.sqrt();
    Complex complex4 = complex3.ONE.divide(complex2);
    Complex complex5 = complex2.sin();
    complex5.I.asin();
    Complex complex6 = complex5.multiply(complex1);
    complex6.asin();
    complex3.getImaginary();
    Complex complex7 = complex4.exp();
    complex1.negate();
    complex7.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * <p>
 * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:
 * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>
 * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>
 *  else return <code>|b|/2t + sign(b)t i </code></pre></li>
 * </ol>
 * where <ul>
 * <li><code>|a| = {@link Math#abs}(a)</code></li>
 * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>
 * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>
 * </ul></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 * </code></pre></p>
 *
 * @return the square root of this complex number
 * @since 1.2
 */"
"public Complex conjugate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test3636() throws Throwable {
    Complex complex0 = new Complex(74.0, (-2709.178363033));
    Complex complex1 = Complex.INF;
    complex0.ONE.divide(complex1);
    complex0.ZERO.conjugate();
    complex0.sqrt();
    complex1.sinh();
    complex1.conjugate();
}","/**
 * Return the conjugate of this complex number. The conjugate of
 * ""A + Bi"" is ""A - Bi"".
 * <p>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 * <p>
 * If the imaginary part is infinite, and the real part is not NaN,
 * the returned value has infinite imaginary part of the opposite
 * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
 * is <code>1 - NEGATIVE_INFINITY i</code></p>
 *
 * @return the conjugate of this Complex object
 */"
"public Complex cosh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(MathUtils.cosh(real) * Math.cos(imaginary), MathUtils.sinh(real) * Math.sin(imaginary));
}","public void test3737() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex0.ONE.multiply(complex1);
    Complex complex3 = complex0.ONE.cosh();
    complex2.ONE.subtract(complex1);
    complex3.NaN.sqrt1z();
    Complex complex4 = complex0.createComplex(2208.740607618692, (-2083.8));
    complex4.sqrt1z();
    complex2.cos();
    complex2.hashCode();
    complex0.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public Complex negate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test3838() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.isInfinite();
    Complex complex1 = complex0.sqrt();
    complex0.ONE.cos();
    Complex complex2 = complex1.sqrt();
    complex2.hashCode();
    complex2.conjugate();
    complex0.negate();
}","/**
 * Return the additive inverse of this complex number.
 * <p>
 * Returns <code>Complex.NaN</code> if either real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 *
 * @return the negation of this complex number
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test3939() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.atan();
    Complex complex2 = complex1.cos();
    complex2.INF.sinh();
    Complex complex3 = new Complex(197.128545704, 0.34697285770402114);
    complex1.ZERO.add(complex3);
    complex1.negate();
    complex1.pow(complex0);
    Complex complex4 = complex2.sinh();
    complex3.divide(complex4);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex subtract(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());
}","public void test4040() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.ONE.cosh();
    complex0.ONE.cosh();
    Complex complex1 = complex0.cos();
    Complex complex2 = complex0.negate();
    Complex complex3 = complex0.pow(complex2);
    complex3.sqrt1z();
    complex2.getReal();
    complex1.getImaginary();
    complex1.subtract(complex3);
}","/**
 * Return the difference between this complex number and the given complex
 * number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) - (c + di) = (a-c) + (b-d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic. </p>
 *
 * @param rhs the other complex number
 * @return the complex number difference
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex negate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test4141() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.cosh();
    complex0.subtract(complex1);
    Complex complex2 = new Complex(0.0, 1.0);
    complex2.multiply(complex0);
    complex2.exp();
    Complex complex3 = complex2.exp();
    complex2.atan();
    Complex complex4 = complex0.divide(complex2);
    complex4.tan();
    complex3.negate();
}","/**
 * Return the additive inverse of this complex number.
 * <p>
 * Returns <code>Complex.NaN</code> if either real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 *
 * @return the negation of this complex number
 */"
"public double getReal() {
    return real;
}","public void test4242() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.ZERO;
    complex0.ZERO.add(complex1);
    Complex complex2 = complex0.tan();
    complex2.add(complex0);
    complex1.getReal();
    complex1.hashCode();
    complex0.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part
 */"
"public Complex exp() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double expReal = Math.exp(real);
    return createComplex(expReal * Math.cos(imaginary), expReal * Math.sin(imaginary));
}","public void test4343() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.I.sin();
    complex1.sinh();
    complex1.createComplex((-777.8817), 0.0);
    Complex complex2 = complex1.ONE.tanh();
    complex0.sqrt1z();
    complex2.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * exp(1 &plusmn; INFINITY i) = NaN + NaN i
 * exp(INFINITY + i) = INFINITY + INFINITY i
 * exp(-INFINITY + i) = 0 + 0i
 * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return <i>e</i><sup><code>this</code></sup>
 * @since 1.2
 */"
"public Complex acos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(this.sqrt1z().multiply(Complex.I)).log().multiply(Complex.I.negate());
}","public void test4444() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.ONE.acos();
    Complex complex2 = complex0.atan();
    complex2.ONE.createComplex((-1.0), 330.624838257935);
    complex0.hashCode();
    complex1.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse cosine of this complex number
 * @since 1.2
 */"
"public Complex cos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.cos(real) * MathUtils.cosh(imaginary), -Math.sin(real) * MathUtils.sinh(imaginary));
}","public void test4545() throws Throwable {
    Complex complex0 = new Complex((-2219.6584337653), (-2219.6584337653));
    Complex complex1 = Complex.INF;
    complex1.ZERO.multiply(complex0);
    Complex complex2 = complex0.NaN.pow(complex1);
    complex2.INF.cosh();
    complex0.ONE.tan();
    complex1.ZERO.multiply(complex2);
    complex1.INF.pow(complex2);
    Complex complex3 = complex0.sqrt();
    complex3.ONE.cos();
    Complex complex4 = complex3.NaN.add(complex1);
    Complex complex5 = complex0.log();
    Complex complex6 = complex5.I.cos();
    complex0.cosh();
    Complex complex7 = Complex.ONE;
    Complex complex8 = complex5.NaN.multiply(complex7);
    complex0.exp();
    complex6.equals(complex4);
    complex8.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the cosine of this complex number
 * @since 1.2
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test4646() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.NaN.sqrt();
    Complex complex2 = complex1.NaN.acos();
    Complex complex3 = complex1.I.acos();
    Complex complex4 = complex1.ONE.multiply(complex3);
    complex4.NaN.conjugate();
    Complex complex5 = complex3.I.asin();
    complex5.subtract(complex2);
    Complex complex6 = complex0.cos();
    complex3.add(complex6);
    complex1.add(complex0);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test4747() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.ZERO.acos();
    Complex complex2 = complex0.NaN.cos();
    complex2.ZERO.add(complex1);
    complex2.ONE.negate();
    Complex complex3 = complex0.log();
    complex1.I.exp();
    Complex complex4 = complex0.conjugate();
    complex3.divide(complex1);
    Complex complex5 = complex3.multiply(complex4);
    complex5.divide(complex1);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex conjugate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test4848() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.ZERO;
    complex0.ZERO.add(complex1);
    Complex complex2 = Complex.INF;
    complex2.NaN.cosh();
    Complex complex3 = complex2.ZERO.log();
    complex3.NaN.cosh();
    Complex complex4 = complex0.subtract(complex2);
    complex2.hashCode();
    complex0.isInfinite();
    Complex complex5 = complex2.INF.negate();
    complex4.isNaN();
    complex4.conjugate();
    complex5.conjugate();
}","/**
 * Return the conjugate of this complex number. The conjugate of
 * ""A + Bi"" is ""A - Bi"".
 * <p>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 * <p>
 * If the imaginary part is infinite, and the real part is not NaN,
 * the returned value has infinite imaginary part of the opposite
 * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
 * is <code>1 - NEGATIVE_INFINITY i</code></p>
 *
 * @return the conjugate of this Complex object
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test4949() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.ZERO.asin();
    complex1.INF.cosh();
    complex0.I.conjugate();
    Complex complex2 = complex0.tanh();
    Complex complex3 = complex2.pow(complex0);
    complex2.getReal();
    Complex complex4 = complex1.cosh();
    complex4.ONE.acos();
    Complex complex5 = complex3.atan();
    complex3.cosh();
    Object object0 = new Object();
    complex5.equals(object0);
}","/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */"
"public boolean isNaN() {
    return Double.isNaN(real) || Double.isNaN(imaginary);
}","public void test5050() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.isNaN();
}","/**
 * Returns true if either or both parts of this complex number is NaN;
 * false otherwise
 *
 * @return  true if either or both parts of this complex number is NaN;
 * false otherwise
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test5151() throws Throwable {
    Complex complex0 = new Complex(0.0, 889.38078);
    Complex complex1 = complex0.acos();
    complex1.hashCode();
    Complex complex2 = complex1.log();
    Complex complex3 = complex1.asin();
    complex0.I.cos();
    complex3.equals(""org.apache.commons.math.complex.Complex"");
    Complex complex4 = complex1.ONE.conjugate();
    complex1.INF.atan();
    complex0.abs();
    complex2.isInfinite();
    complex2.negate();
    complex4.getImaginary();
    complex0.I.sin();
    complex2.negate();
    Complex complex5 = complex3.I.exp();
    complex5.negate();
    Complex complex6 = Complex.ONE;
    Complex complex7 = complex6.ZERO.acos();
    complex3.pow(complex6);
    complex7.abs();
    complex3.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test5252() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.sqrt1z();
    Complex complex2 = complex1.sqrt1z();
    complex2.ZERO.tanh();
    Complex complex3 = complex0.sinh();
    Complex complex4 = complex3.ONE.negate();
    complex4.exp();
    complex0.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test5353() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.ONE.sqrt();
    complex1.NaN.asin();
    complex1.I.hashCode();
    Complex complex2 = complex0.tanh();
    complex2.ZERO.createComplex(0.0, 0.0);
    complex2.sin();
    complex0.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test5454() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.atan();
    complex0.abs();
    Complex complex2 = complex0.tan();
    Complex complex3 = complex2.INF.subtract(complex1);
    Complex complex4 = complex3.I.createComplex(106.2, 106.2);
    Complex complex5 = complex2.I.negate();
    Complex complex6 = complex1.subtract(complex0);
    Complex complex7 = complex6.negate();
    Complex complex8 = complex0.conjugate();
    Complex complex9 = complex7.ONE.sqrt();
    complex9.INF.conjugate();
    Complex complex10 = Complex.I;
    Complex complex11 = complex8.I.divide(complex10);
    Complex complex12 = complex7.ZERO.atan();
    Complex complex13 = complex12.cosh();
    Complex complex14 = complex6.conjugate();
    complex14.ONE.add(complex11);
    complex14.ZERO.sinh();
    Complex complex15 = complex6.multiply(complex5);
    complex0.negate();
    Complex complex16 = complex12.sinh();
    complex6.sinh();
    Complex complex17 = complex4.tanh();
    complex17.ZERO.cos();
    complex2.ZERO.exp();
    complex1.asin();
    complex13.exp();
    complex8.acos();
    complex15.tanh();
    complex6.cos();
    complex16.asin();
    complex3.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex log() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.log(abs()), Math.atan2(imaginary, real));
}","public void test5555() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.INF;
    Complex complex2 = complex1.ONE.divide(complex0);
    complex2.sin();
    Complex complex3 = complex0.multiply(complex1);
    complex0.I.tanh();
    Complex complex4 = complex3.asin();
    complex3.I.cos();
    Complex complex5 = complex4.sqrt();
    Complex complex6 = complex5.conjugate();
    complex6.INF.subtract(complex0);
    complex5.INF.sinh();
    complex5.cos();
    complex3.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and
 * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 * log(INFINITY + i) = INFINITY + 0i
 * log(-INFINITY + i) = INFINITY + &pi;i
 * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 * log(0 + 0i) = -INFINITY + 0i
 * </code></pre></p>
 *
 * @return ln of this complex number.
 * @since 1.2
 */"
"public double abs() {
    if (isNaN()) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (Math.abs(real) < Math.abs(imaginary)) {
        if (imaginary == 0.0) {
            return Math.abs(real);
        }
        double q = real / imaginary;
        return (Math.abs(imaginary) * Math.sqrt(1 + q * q));
    } else {
        if (real == 0.0) {
            return Math.abs(imaginary);
        }
        double q = imaginary / real;
        return (Math.abs(real) * Math.sqrt(1 + q * q));
    }
}","public void test5656() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.log();
    complex1.INF.asin();
    Complex complex2 = complex0.conjugate();
    Complex complex3 = complex2.ONE.cos();
    Complex complex4 = complex3.I.sqrt();
    complex4.I.atan();
    Complex complex5 = complex0.log();
    Complex complex6 = complex0.log();
    complex6.NaN.tanh();
    complex2.negate();
    complex5.isInfinite();
    complex2.abs();
}","/**
 * Return the absolute value of this complex number.
 * <p>
 * Returns <code>NaN</code> if either real or imaginary part is
 * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if
 * neither part is <code>NaN</code>, but at least one part takes an infinite
 * value.</p>
 *
 * @return the absolute value
 */"
"public double abs() {
    if (isNaN()) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (Math.abs(real) < Math.abs(imaginary)) {
        if (imaginary == 0.0) {
            return Math.abs(real);
        }
        double q = real / imaginary;
        return (Math.abs(imaginary) * Math.sqrt(1 + q * q));
    } else {
        if (real == 0.0) {
            return Math.abs(imaginary);
        }
        double q = imaginary / real;
        return (Math.abs(real) * Math.sqrt(1 + q * q));
    }
}","public void test5757() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = new Complex(0.0, (-1183.3164516957));
    Complex complex2 = complex0.add(complex1);
    complex1.ONE.asin();
    Complex complex3 = complex0.subtract(complex2);
    complex3.ONE.hashCode();
    Complex complex4 = complex1.sqrt();
    complex4.cosh();
    complex4.INF.sin();
    complex2.I.cosh();
    complex4.NaN.asin();
    complex4.NaN.tan();
    complex2.hashCode();
    complex2.abs();
}","/**
 * Return the absolute value of this complex number.
 * <p>
 * Returns <code>NaN</code> if either real or imaginary part is
 * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if
 * neither part is <code>NaN</code>, but at least one part takes an infinite
 * value.</p>
 *
 * @return the absolute value
 */"
"public Complex cos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.cos(real) * MathUtils.cosh(imaginary), -Math.sin(real) * MathUtils.sinh(imaginary));
}","public void test5858() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.abs();
    Complex complex1 = complex0.tanh();
    Complex complex2 = complex1.createComplex(1.0, 0.0);
    Complex complex3 = complex1.pow(complex0);
    complex3.INF.tan();
    Complex complex4 = complex3.pow(complex2);
    complex1.cos();
    complex0.cos();
    complex4.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the cosine of this complex number
 * @since 1.2
 */"
"public Complex atan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(Complex.I).divide(Complex.I.subtract(this)).log().multiply(Complex.I.divide(createComplex(2.0, 0.0)));
}","public void test5959() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.ONE.exp();
    Complex complex2 = complex1.INF.atan();
    complex1.ONE.log();
    complex2.ONE.sinh();
    Complex complex3 = complex0.createComplex((-3540.78), Double.POSITIVE_INFINITY);
    complex0.multiply(complex2);
    complex3.NaN.add((Complex) null);
    Complex complex4 = complex0.log();
    complex4.ONE.tan();
    // Undeclared exception!
    try {
        complex0.atan();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public Complex sinh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(MathUtils.sinh(real) * Math.cos(imaginary), MathUtils.cosh(real) * Math.sin(imaginary));
}","public void test6060() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    Complex complex1 = complex0.INF.log();
    Complex complex2 = complex1.I.tanh();
    Complex complex3 = complex1.ZERO.negate();
    complex3.I.hashCode();
    complex3.NaN.conjugate();
    Complex complex4 = complex1.exp();
    Complex complex5 = Complex.ONE;
    Complex complex6 = complex4.ZERO.subtract(complex5);
    complex5.hashCode();
    Complex complex7 = complex6.NaN.createComplex(0.0, (-896.0));
    Complex complex8 = complex7.ZERO.cos();
    Complex complex9 = complex1.ONE.pow(complex0);
    complex9.ONE.exp();
    complex9.hashCode();
    Complex complex10 = complex0.sqrt1z();
    Complex complex11 = complex7.ONE.atan();
    Complex complex12 = complex10.acos();
    complex12.NaN.exp();
    complex4.isNaN();
    Complex complex13 = complex12.sqrt1z();
    Complex complex14 = complex1.log();
    complex14.I.acos();
    complex0.tan();
    complex8.hashCode();
    complex2.multiply(complex13);
    complex9.divide(complex11);
    complex7.sinh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"" TARGET=""_top"">
 * hyperbolic sine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the hyperbolic sine of this complex number
 * @since 1.2
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test6161() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.I;
    Complex complex2 = complex0.divide(complex1);
    Complex complex3 = complex1.tan();
    complex0.abs();
    Complex complex4 = complex3.INF.sinh();
    Complex complex5 = complex2.cos();
    Complex complex6 = complex5.log();
    Complex complex7 = complex1.add(complex3);
    complex0.ONE.subtract(complex2);
    complex7.I.subtract(complex3);
    complex7.ONE.acos();
    complex2.exp();
    complex4.log();
    Complex complex8 = complex7.multiply(complex6);
    complex8.I.asin();
    complex2.ONE.log();
    complex8.equals("""");
}","/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */"
"public Complex subtract(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());
}","public void test6262() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.I;
    complex0.add(complex1);
    Complex complex2 = Complex.INF;
    complex1.subtract(complex2);
}","/**
 * Return the difference between this complex number and the given complex
 * number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) - (c + di) = (a-c) + (b-d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic. </p>
 *
 * @param rhs the other complex number
 * @return the complex number difference
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex sqrt() {
    if (isNaN()) {
        return Complex.NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(Math.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test6363() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.INF.cosh();
    Complex complex1 = complex0.ONE.createComplex((-1947.5748239076702), (-1947.5748239076702));
    Complex complex2 = complex1.ZERO.acos();
    complex2.NaN.tanh();
    Complex complex3 = complex0.cosh();
    complex1.getReal();
    complex0.acos();
    complex3.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * <p>
 * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:
 * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>
 * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>
 *  else return <code>|b|/2t + sign(b)t i </code></pre></li>
 * </ol>
 * where <ul>
 * <li><code>|a| = {@link Math#abs}(a)</code></li>
 * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>
 * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>
 * </ul></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 * </code></pre></p>
 *
 * @return the square root of this complex number
 * @since 1.2
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test6464() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.I.cos();
    Complex complex2 = Complex.ZERO;
    complex1.I.multiply(complex2);
    Complex complex3 = complex1.I.multiply(complex2);
    complex0.hashCode();
    Complex complex4 = Complex.INF;
    Complex complex5 = complex4.INF.subtract(complex0);
    Complex complex6 = complex4.INF.cos();
    complex0.equals(complex4);
    complex5.log();
    complex4.abs();
    Complex complex7 = complex4.createComplex(1.0, Double.POSITIVE_INFINITY);
    complex5.ONE.atan();
    complex7.I.subtract(complex6);
    complex7.ONE.add(complex3);
    Complex complex8 = complex5.sqrt1z();
    Complex complex9 = complex8.I.asin();
    complex9.ZERO.divide(complex5);
    complex6.sin();
    complex8.atan();
    Complex complex10 = complex4.sin();
    complex5.log();
    Complex complex11 = complex3.cos();
    complex11.atan();
    complex0.add(complex10);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex negate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test6565() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.ONE.tan();
    Complex complex2 = complex1.ONE.atan();
    Complex complex3 = complex0.I.sinh();
    Complex complex4 = complex0.exp();
    Complex complex5 = complex4.ZERO.add(complex3);
    Complex complex6 = complex4.NaN.sin();
    Complex complex7 = complex1.ONE.atan();
    complex7.INF.add(complex4);
    Complex complex8 = complex0.createComplex((-1934.24497), 2.0);
    Complex complex9 = complex8.pow(complex2);
    complex6.atan();
    Complex complex10 = complex8.cos();
    complex10.I.divide(complex2);
    Complex complex11 = complex5.multiply(complex10);
    complex11.abs();
    complex11.abs();
    complex2.getImaginary();
    complex0.getReal();
    complex9.hashCode();
    complex3.hashCode();
    complex6.negate();
}","/**
 * Return the additive inverse of this complex number.
 * <p>
 * Returns <code>Complex.NaN</code> if either real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 *
 * @return the negation of this complex number
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test6666() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.sin();
    Complex complex2 = complex1.ZERO.acos();
    Complex complex3 = complex0.cosh();
    Complex complex4 = complex3.ONE.sinh();
    Complex complex5 = complex4.tanh();
    Complex complex6 = complex1.sinh();
    complex6.hashCode();
    Complex complex7 = complex6.INF.multiply(complex5);
    Complex complex8 = complex7.ONE.conjugate();
    Complex complex9 = complex3.ZERO.divide(complex2);
    Complex complex10 = complex9.ZERO.sqrt();
    complex10.INF.tanh();
    Complex complex11 = complex1.subtract(complex0);
    complex11.negate();
    complex4.INF.cos();
    Complex complex12 = complex1.sqrt();
    complex3.isInfinite();
    Complex complex13 = complex4.negate();
    complex13.pow(complex5);
    Complex complex14 = complex0.acos();
    complex14.getImaginary();
    Complex complex15 = complex8.tanh();
    complex15.equals(complex7);
    complex12.sinh();
    complex5.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test6767() throws Throwable {
    Complex complex0 = new Complex((-160.37400995), (-2865.3408205399464));
    Complex complex1 = new Complex(1215.191198536, (-242.9881993088024));
    Complex complex2 = complex0.subtract(complex1);
    complex0.hashCode();
    complex1.NaN.sinh();
    Complex complex3 = complex0.atan();
    complex1.subtract(complex2);
    Complex complex4 = complex3.multiply(complex0);
    complex3.cos();
    complex4.sinh();
    Complex complex5 = Complex.ONE;
    complex3.divide(complex5);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"protected Complex createComplex(double real, double imaginary) {
    return new Complex(real, imaginary);
}","public void test6868() throws Throwable {
    Complex complex0 = new Complex(786.1387374983, (-158.0));
    Complex complex1 = complex0.INF.tan();
    complex1.ZERO.divide(complex0);
    complex1.ONE.hashCode();
    Complex complex2 = complex0.cosh();
    complex2.ZERO.subtract(complex0);
    complex0.abs();
    Complex complex3 = complex0.sin();
    complex2.hashCode();
    complex3.negate();
    complex1.isNaN();
    complex0.negate();
    complex3.ZERO.createComplex(0.0, 0.0);
    complex3.createComplex(3992.7536647, 3992.7536647);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param real the real part
 * @param imaginary the imaginary part
 * @return a new complex number instance
 * @since 1.2
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test6969() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = new Complex((-792.473236817), (-792.473236817));
    complex0.I.pow(complex1);
    complex0.hashCode();
    complex0.hashCode();
    complex0.sinh();
    complex0.getImaginary();
    Complex complex2 = complex0.createComplex(1.0, 1.0);
    complex0.add(complex2);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex tanh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
}","public void test7070() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.INF;
    complex0.hashCode();
    Complex complex2 = complex1.I.sqrt1z();
    Complex complex3 = complex0.NaN.pow(complex1);
    Complex complex4 = Complex.ONE;
    Complex complex5 = complex0.subtract(complex4);
    complex5.ONE.exp();
    complex3.atan();
    complex2.asin();
    complex2.atan();
    complex1.getReal();
    complex4.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + i) = NaN + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>
 *
 * @return the hyperbolic tangent of this complex number
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test7171() throws Throwable {
    Complex complex0 = new Complex(0.0, Double.POSITIVE_INFINITY);
    Complex complex1 = complex0.ONE.createComplex(2.0, (-1.0));
    complex1.INF.createComplex(2.0, 0.0);
    complex1.add(complex0);
    complex0.pow((Complex) null);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public Complex atan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return this.add(Complex.I).divide(Complex.I.subtract(this)).log().multiply(Complex.I.divide(createComplex(2.0, 0.0)));
}","public void test7272() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.I;
    complex0.I.add(complex1);
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex1.I.divide(complex2);
    Complex complex4 = complex3.divide(complex0);
    Complex complex5 = complex4.NaN.sqrt();
    Complex complex6 = complex5.I.tan();
    complex6.ZERO.atan();
    Complex complex7 = complex3.I.sin();
    complex7.INF.sqrt1z();
    Complex complex8 = complex2.sin();
    complex8.createComplex((-3051.1), (-3051.1));
    complex2.NaN.subtract(complex0);
    Complex complex9 = complex2.NaN.atan();
    complex0.abs();
    complex1.ONE.acos();
    complex1.subtract(complex2);
    complex9.getReal();
    complex8.acos();
    complex5.atan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public Complex cosh() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(MathUtils.cosh(real) * Math.cos(imaginary), MathUtils.sinh(real) * Math.sin(imaginary));
}","public void test7373() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.acos();
    Complex complex2 = complex1.subtract(complex0);
    Complex complex3 = complex2.NaN.asin();
    Complex complex4 = complex0.I.cosh();
    Complex complex5 = complex1.I.subtract(complex4);
    complex5.ONE.exp();
    Complex complex6 = complex3.INF.sin();
    complex4.INF.log();
    Complex complex7 = complex0.createComplex(Double.POSITIVE_INFINITY, 0.0);
    Complex complex8 = complex5.tanh();
    complex7.tanh();
    Complex complex9 = complex1.ZERO.sqrt();
    complex9.ONE.log();
    complex1.getReal();
    complex3.hashCode();
    complex5.isNaN();
    complex0.getReal();
    Complex complex10 = complex1.tan();
    complex2.pow(complex0);
    complex6.exp();
    Complex complex11 = complex3.cosh();
    complex11.divide(complex2);
    complex10.multiply(complex4);
    complex1.cos();
    complex8.abs();
    complex4.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public Complex negate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test7474() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.tan();
    Complex complex2 = Complex.ONE;
    complex0.hashCode();
    Complex complex3 = complex2.asin();
    Complex complex4 = complex1.pow(complex2);
    Complex complex5 = complex2.asin();
    complex4.getReal();
    complex2.I.exp();
    Complex complex6 = complex0.tanh();
    Complex complex7 = complex6.INF.createComplex(Double.NaN, Double.NaN);
    complex7.I.cos();
    complex3.isNaN();
    complex6.NaN.subtract(complex3);
    Object object0 = new Object();
    complex6.equals(object0);
    Complex complex8 = complex1.tan();
    complex1.multiply(complex8);
    complex3.sin();
    complex5.negate();
}","/**
 * Return the additive inverse of this complex number.
 * <p>
 * Returns <code>Complex.NaN</code> if either real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 *
 * @return the negation of this complex number
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test7575() throws Throwable {
    Complex complex0 = new Complex(494.6711311699403, 494.6711311699403);
    Complex complex1 = Complex.I;
    complex0.multiply(complex1);
    complex0.ONE.hashCode();
    complex0.abs();
    complex0.sin();
    Complex complex2 = complex0.multiply(complex1);
    complex2.isInfinite();
    complex1.add(complex2);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex sin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.sin(real) * MathUtils.cosh(imaginary), Math.cos(real) * MathUtils.sinh(imaginary));
}","public void test7676() throws Throwable {
    Complex complex0 = new Complex(192.2034991042, 192.2034991042);
    Complex complex1 = complex0.log();
    Complex complex2 = complex1.ONE.acos();
    Complex complex3 = complex1.NaN.conjugate();
    Complex complex4 = complex1.ONE.pow(complex0);
    complex4.ZERO.sqrt1z();
    complex0.log();
    complex1.INF.subtract(complex3);
    Complex complex5 = complex1.atan();
    complex5.I.exp();
    Complex complex6 = complex0.cos();
    complex6.multiply(complex5);
    complex1.tan();
    complex2.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 * sin(&plusmn;INFINITY + i) = NaN + NaN i
 * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public Complex sqrt() {
    if (isNaN()) {
        return Complex.NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(Math.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test7777() throws Throwable {
    Complex complex0 = new Complex((-1681.68), 0.0);
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex0.I.subtract(complex1);
    complex2.NaN.sqrt1z();
    Complex complex3 = complex0.atan();
    Complex complex4 = complex3.ZERO.tanh();
    complex3.hashCode();
    Complex complex5 = complex3.tan();
    Complex complex6 = complex5.sqrt1z();
    Complex complex7 = complex6.INF.subtract(complex1);
    complex7.INF.atan();
    Complex complex8 = complex0.divide(complex3);
    Complex complex9 = complex8.NaN.cosh();
    Complex complex10 = complex0.acos();
    Complex complex11 = complex0.log();
    Complex complex12 = complex10.NaN.log();
    Complex complex13 = complex2.sinh();
    Complex complex14 = complex13.I.divide(complex3);
    Complex complex15 = complex14.ZERO.cos();
    complex11.getImaginary();
    complex10.isInfinite();
    complex4.equals(complex2);
    complex9.abs();
    complex6.isNaN();
    complex2.asin();
    complex11.exp();
    complex12.negate();
    complex15.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * <p>
 * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:
 * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>
 * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>
 *  else return <code>|b|/2t + sign(b)t i </code></pre></li>
 * </ol>
 * where <ul>
 * <li><code>|a| = {@link Math#abs}(a)</code></li>
 * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>
 * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>
 * </ul></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 * </code></pre></p>
 *
 * @return the square root of this complex number
 * @since 1.2
 */"
"public Complex subtract(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());
}","public void test7878() throws Throwable {
    Complex complex0 = new Complex(Double.POSITIVE_INFINITY, 0.0);
    Complex complex1 = complex0.ZERO.atan();
    Complex complex2 = complex0.divide(complex1);
    Complex complex3 = complex2.ONE.acos();
    Complex complex4 = complex1.ONE.cosh();
    Complex complex5 = complex4.INF.negate();
    Complex complex6 = complex4.INF.asin();
    Complex complex7 = complex1.ONE.pow(complex3);
    complex6.NaN.pow(complex0);
    Complex complex8 = complex0.log();
    complex0.add(complex6);
    Complex complex9 = complex5.createComplex(0.0, 0.0);
    complex8.sqrt();
    complex5.abs();
    Complex complex10 = complex0.multiply(complex4);
    complex9.isInfinite();
    complex5.atan();
    Complex complex11 = complex3.sqrt();
    Complex complex12 = complex10.INF.atan();
    Complex complex13 = complex0.log();
    Complex complex14 = complex10.cosh();
    complex14.INF.atan();
    Object object0 = new Object();
    complex11.equals(object0);
    complex7.negate();
    complex12.pow(complex13);
    Complex complex15 = Complex.NaN;
    complex0.subtract(complex15);
}","/**
 * Return the difference between this complex number and the given complex
 * number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) - (c + di) = (a-c) + (b-d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic. </p>
 *
 * @param rhs the other complex number
 * @return the complex number difference
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex log() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.log(abs()), Math.atan2(imaginary, real));
}","public void test7979() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex1.atan();
    complex0.ONE.multiply(complex2);
    Complex complex3 = complex0.NaN.asin();
    complex0.getReal();
    Complex complex4 = complex3.INF.sqrt1z();
    complex0.getImaginary();
    Complex complex5 = complex3.tan();
    complex5.NaN.asin();
    Complex complex6 = complex3.acos();
    Complex complex7 = complex6.asin();
    complex7.exp();
    complex6.INF.subtract(complex1);
    complex6.atan();
    complex7.INF.tan();
    Complex complex8 = complex0.add(complex2);
    complex8.ZERO.add(complex7);
    complex8.subtract(complex7);
    complex8.conjugate();
    Complex complex9 = complex4.add(complex2);
    complex9.tan();
    complex4.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and
 * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 * log(INFINITY + i) = INFINITY + 0i
 * log(-INFINITY + i) = INFINITY + &pi;i
 * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 * log(0 + 0i) = -INFINITY + 0i
 * </code></pre></p>
 *
 * @return ln of this complex number.
 * @since 1.2
 */"
"public Complex sqrt1z() {
    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
}","public void test8080() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.tan();
    Complex complex2 = complex1.ZERO.sqrt1z();
    complex2.cos();
    Complex complex3 = complex1.ONE.tanh();
    Complex complex4 = complex0.sin();
    Complex complex5 = complex4.negate();
    complex5.I.sinh();
    complex5.NaN.exp();
    Complex complex6 = Complex.ONE;
    Complex complex7 = complex0.I.pow(complex6);
    complex7.ONE.negate();
    complex4.isInfinite();
    Complex complex8 = complex0.negate();
    Complex complex9 = complex8.INF.pow(complex1);
    Complex complex10 = complex3.multiply(complex4);
    Complex complex11 = Complex.INF;
    complex10.add(complex11);
    complex11.ONE.cosh();
    complex9.log();
    complex9.equals((Object) null);
    complex10.isInfinite();
    complex11.log();
    complex11.sqrt1z();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex
 * number.
 * <p>
 * Computes the result directly as
 * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.</p>
 *
 * @return the square root of 1 - <code>this</code><sup>2</sup>
 * @since 1.2
 */"
"public Complex asin() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return sqrt1z().add(this.multiply(Complex.I)).log().multiply(Complex.I.negate());
}","public void test8181() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.divide((Complex) null);
    // Undeclared exception!
    try {
        complex1.asin();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite.</p>
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex add(Complex rhs) {
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","public void test8282() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.ZERO.tanh();
    complex0.add((Complex) null);
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Inifinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test8383() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = Complex.ONE;
    Complex complex2 = complex0.I.multiply(complex1);
    complex0.isInfinite();
    Complex complex3 = complex0.acos();
    Complex complex4 = Complex.ZERO;
    Complex complex5 = complex0.INF.add(complex4);
    Complex complex6 = complex3.createComplex(0.0, 2.0);
    complex6.NaN.tanh();
    complex1.getReal();
    Complex complex7 = complex2.add(complex3);
    Complex complex8 = complex7.ONE.conjugate();
    Complex complex9 = complex8.createComplex(1.0, 0.0);
    Complex complex10 = complex3.sin();
    complex0.I.divide(complex9);
    complex3.hashCode();
    complex10.tan();
    complex0.divide(complex5);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex cos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.cos(real) * MathUtils.cosh(imaginary), -Math.sin(real) * MathUtils.sinh(imaginary));
}","public void test8484() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.NaN.acos();
    Complex complex2 = complex0.createComplex((-2583.96), (-2583.96));
    Complex complex3 = complex1.add(complex2);
    Complex complex4 = complex1.INF.log();
    Complex complex5 = complex1.INF.sqrt();
    complex4.ONE.hashCode();
    complex5.sinh();
    complex3.I.divide(complex4);
    complex0.equals(complex2);
    Complex complex6 = complex1.tan();
    Complex complex7 = complex2.I.add(complex5);
    complex0.NaN.exp();
    complex1.I.hashCode();
    complex6.isInfinite();
    Complex complex8 = complex1.divide(complex2);
    complex8.NaN.tan();
    complex8.ONE.sqrt();
    Complex complex9 = complex6.conjugate();
    complex2.sin();
    Complex complex10 = complex4.conjugate();
    complex6.ONE.subtract(complex1);
    complex0.log();
    complex9.acos();
    complex10.divide(complex7);
    complex3.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the cosine of this complex number
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test8585() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex1.INF.multiply(complex0);
    Complex complex3 = complex0.createComplex(1191.6533687, (-1649.7033461966562));
    Complex complex4 = complex3.ONE.negate();
    Complex complex5 = complex3.I.subtract(complex2);
    complex5.NaN.tanh();
    Complex complex6 = complex3.pow(complex1);
    complex6.getImaginary();
    Complex complex7 = complex0.pow(complex3);
    complex7.ONE.conjugate();
    Complex complex8 = complex3.sqrt();
    Complex complex9 = complex8.multiply(complex7);
    complex8.multiply(complex6);
    Complex complex10 = complex9.NaN.exp();
    Complex complex11 = complex8.ONE.cosh();
    Complex complex12 = complex4.sin();
    complex12.I.pow(complex11);
    complex12.ONE.createComplex((-1649.7033461966562), (-1649.7033461966562));
    complex9.tan();
    Complex complex13 = complex0.sinh();
    complex13.I.pow(complex4);
    complex5.abs();
    Complex complex14 = complex10.sin();
    complex3.cos();
    complex14.pow(complex5);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test8686() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.ONE.sqrt();
    Complex complex2 = complex0.INF.createComplex(2450.33, 2.0);
    Complex complex3 = complex0.NaN.pow(complex1);
    Complex complex4 = complex0.INF.sin();
    Complex complex5 = complex0.ONE.atan();
    Complex complex6 = complex0.createComplex(0.0, 2450.33);
    Complex complex7 = complex5.multiply(complex3);
    complex6.NaN.acos();
    Complex complex8 = complex4.sin();
    Complex complex9 = complex0.conjugate();
    Complex complex10 = complex5.multiply(complex9);
    complex10.ZERO.cos();
    complex2.isInfinite();
    Complex complex11 = Complex.I;
    Complex complex12 = complex6.add(complex11);
    complex4.asin();
    complex2.NaN.sinh();
    complex8.hashCode();
    Complex complex13 = complex2.conjugate();
    Complex complex14 = complex12.asin();
    Complex complex15 = complex14.pow(complex12);
    complex15.ONE.sqrt1z();
    complex15.INF.hashCode();
    Complex complex16 = complex4.log();
    complex4.ONE.sqrt();
    complex0.exp();
    Complex complex17 = complex16.cos();
    complex14.getImaginary();
    complex7.atan();
    Complex complex18 = Complex.ZERO;
    complex7.multiply(complex18);
    complex4.hashCode();
    complex13.asin();
    complex14.abs();
    complex17.divide(complex1);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test8787() throws Throwable {
    Complex complex0 = new Complex((-1.0), 2.0);
    complex0.hashCode();
    Complex complex1 = Complex.INF;
    Complex complex2 = complex1.I.asin();
    Complex complex3 = complex0.multiply(complex1);
    Complex complex4 = complex0.conjugate();
    complex1.INF.sqrt1z();
    complex4.NaN.sqrt();
    Complex complex5 = complex2.NaN.asin();
    complex4.abs();
    Complex complex6 = complex2.I.pow(complex0);
    Complex complex7 = complex4.sqrt1z();
    complex0.isNaN();
    complex2.sqrt1z();
    Complex complex8 = complex3.conjugate();
    complex2.cos();
    Complex complex9 = complex8.tanh();
    Complex complex10 = complex6.sqrt();
    complex8.tan();
    Complex complex11 = complex9.ZERO.pow(complex7);
    complex11.I.pow(complex10);
    complex1.negate();
    complex9.cos();
    Complex complex12 = complex4.sinh();
    complex11.multiply(complex12);
    complex5.cosh();
    Complex complex13 = complex5.sin();
    complex13.divide(complex6);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex tan() {
    if (isNaN()) {
        return Complex.NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test8888() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.createComplex(1602.95755678, 1602.95755678);
    Complex complex2 = complex1.acos();
    Complex complex3 = complex1.I.cosh();
    complex3.NaN.negate();
    Complex complex4 = complex3.I.cos();
    complex4.ZERO.subtract(complex2);
    Complex complex5 = complex1.pow(complex0);
    complex5.ZERO.acos();
    Complex complex6 = complex5.pow(complex3);
    complex6.ONE.sqrt1z();
    Complex complex7 = complex5.ZERO.cosh();
    complex1.sinh();
    complex1.atan();
    complex4.cos();
    complex2.isNaN();
    complex7.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * tan(1 &plusmn; INFINITY i) = 0 + NaN i
 * tan(&plusmn;INFINITY + i) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>
 *
 * @return the tangent of this complex number
 * @since 1.2
 */"
"public boolean isNaN() {
    return Double.isNaN(real) || Double.isNaN(imaginary);
}","public void test8989() throws Throwable {
    Complex complex0 = new Complex(470.00681317, (-3029.47));
    complex0.ZERO.sqrt();
    Complex complex1 = new Complex((-3029.47), (-870.1));
    Complex complex2 = complex0.I.multiply(complex1);
    complex2.NaN.atan();
    complex0.subtract((Complex) null);
    complex0.ONE.pow(complex2);
    Complex complex3 = complex0.I.sinh();
    complex3.hashCode();
    // Undeclared exception!
    try {
        complex1.isNaN();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Returns true if either or both parts of this complex number is NaN;
 * false otherwise
 *
 * @return  true if either or both parts of this complex number is NaN;
 * false otherwise
 */"
"public Complex cos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.cos(real) * MathUtils.cosh(imaginary), -Math.sin(real) * MathUtils.sinh(imaginary));
}","public void test9090() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    Complex complex1 = complex0.sin();
    complex1.INF.subtract(complex0);
    Complex complex2 = complex0.log();
    Complex complex3 = complex2.NaN.sqrt1z();
    Complex complex4 = complex2.tan();
    Complex complex5 = complex2.atan();
    complex5.INF.tanh();
    Complex complex6 = complex4.NaN.negate();
    complex6.I.negate();
    complex6.ONE.cos();
    Complex complex7 = complex6.ZERO.exp();
    complex7.ZERO.negate();
    Complex complex8 = complex2.acos();
    complex8.INF.sqrt();
    Complex complex9 = complex3.ONE.sqrt1z();
    complex3.tan();
    Complex complex10 = complex3.negate();
    complex10.ZERO.tan();
    Complex complex11 = complex10.ZERO.asin();
    complex0.NaN.cosh();
    Complex complex12 = complex0.cos();
    complex12.cos();
    complex9.getReal();
    complex12.cosh();
    Complex complex13 = complex12.exp();
    complex13.cos();
    Complex complex14 = complex11.sin();
    complex9.equals(complex14);
    complex4.isNaN();
    complex1.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the cosine of this complex number
 * @since 1.2
 */"
"public Complex cos() {
    if (isNaN()) {
        return Complex.NaN;
    }
    return createComplex(Math.cos(real) * MathUtils.cosh(imaginary), -Math.sin(real) * MathUtils.sinh(imaginary));
}","public void test9191() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.NaN.sin();
    Complex complex2 = complex1.ZERO.tan();
    complex0.NaN.divide(complex2);
    complex2.hashCode();
    Complex complex3 = Complex.ZERO;
    Complex complex4 = complex3.ONE.cosh();
    Complex complex5 = complex4.asin();
    Complex complex6 = complex2.tanh();
    complex6.INF.add(complex2);
    Complex complex7 = complex2.exp();
    complex0.isInfinite();
    Complex complex8 = complex0.log();
    Complex complex9 = complex5.add(complex7);
    complex8.divide(complex9);
    complex6.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * <p>
 * Implements the formula: <pre>
 * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code>.</p>
 * <p>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.<pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>
 *
 * @return the cosine of this complex number
 * @since 1.2
 */"
"public Complex pow(Complex x) {
    if (x == null) {
        throw new NullPointerException();
    }
    return this.log().multiply(x).exp();
}","public void test9292() throws Throwable {
    Complex complex0 = new Complex(0.0, Double.POSITIVE_INFINITY);
    Complex complex1 = complex0.ONE.createComplex(2.0, (-1.0));
    complex1.ZERO.multiply(complex0);
    complex1.INF.createComplex(2.0, 0.0);
    complex1.add(complex0);
    complex0.pow((Complex) null);
}","/**
 * Returns of value of this complex number raised to the power of <code>x</code>.
 * <p>
 * Implements the formula: <pre>
 * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>
 * where <code>exp</code> and <code>log</code> are {@link #exp} and
 * {@link #log}, respectively.</p>
 * <p>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is <code>NaN</code> or infinite, or if <code>y</code>
 * equals {@link Complex#ZERO}.</p>
 *
 * @param x the exponent.
 * @return <code>this</code><sup><code>x</code></sup>
 * @throws NullPointerException if x is null
 * @since 1.2
 */"
"public Complex multiply(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(rhs.real) || Double.isInfinite(rhs.imaginary)) {
        // we don't use Complex.isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * rhs.real - imaginary * rhs.imaginary, real * rhs.imaginary + imaginary * rhs.real);
}","public void test9393() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.isNaN();
    Complex complex1 = complex0.conjugate();
    complex1.ZERO.subtract(complex0);
    Complex complex2 = complex0.multiply((Complex) null);
    // Undeclared exception!
    try {
        complex2.ZERO.multiply(complex1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Return the product of this complex number and the given complex number.
 * <p>
 * Implements preliminary checks for NaN and infinity followed by
 * the definitional formula:
 * <pre><code>
 * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 * </code></pre>
 * </p>
 * <p>
 * Returns {@link #NaN} if either this or <code>rhs</code> has one or more
 * NaN parts.
 * </p>
 * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more
 * NaN parts and if either this or <code>rhs</code> has one or more
 * infinite parts (same result is returned regardless of the sign of the
 * components).
 * </p>
 * <p>
 * Returns finite values in components of the result per the
 * definitional formula in all remaining cases.
 *  </p>
 *
 * @param rhs the other complex number
 * @return the complex number product
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex divide(Complex rhs) {
    if (isNaN() || rhs.isNaN()) {
        return NaN;
    }
    double c = rhs.getReal();
    double d = rhs.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (rhs.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (Math.abs(c) < Math.abs(d)) {
        if (d == 0.0) {
            return createComplex(real / c, imaginary / c);
        }
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        if (c == 0.0) {
            return createComplex(imaginary / d, -real / c);
        }
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test9494() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.NaN.subtract(complex0);
    Complex complex2 = complex0.I.log();
    Complex complex3 = complex2.I.sin();
    Complex complex4 = complex0.I.tanh();
    Complex complex5 = complex4.sinh();
    Complex complex6 = complex5.I.divide(complex4);
    complex2.ONE.asin();
    complex6.ONE.createComplex((-828.93354208067), (-828.93354208067));
    complex0.negate();
    complex0.equals(complex5);
    complex3.conjugate();
    complex3.sin();
    Complex complex7 = complex2.exp();
    complex6.cos();
    Complex complex8 = complex4.tan();
    complex8.ZERO.atan();
    complex0.equals(complex0);
    complex4.pow(complex0);
    Complex complex9 = complex7.sqrt();
    Complex complex10 = complex9.NaN.cos();
    complex8.conjugate();
    complex0.sinh();
    complex0.cos();
    Complex complex11 = complex10.multiply(complex0);
    complex11.divide(complex1);
}","/**
 * Return the quotient of this complex number and the given complex number.
 * <p>
 * Implements the definitional formula
 * <pre><code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di               c<sup>2</sup> + d<sup>2</sup>
 * </code></pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.</p>
 * <p>
 * Infinite and NaN values are handled / returned according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either this or <code>rhs</code> has a NaN value in either part,
 *  {@link #NaN} is returned.</li>
 * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If this and <code>rhs</code> are both infinite,
 * {@link #NaN} is returned.</li>
 * <li>If this is finite (i.e., has no infinite or NaN parts) and
 *  <code>rhs</code> is infinite (one or both parts infinite),
 * {@link #ZERO} is returned.</li>
 * <li>If this is infinite and <code>rhs</code> is finite, NaN values are
 * returned in the parts of the result if the {@link java.lang.Double}
 * rules applied to the definitional formula force NaN results.</li>
 * </ul></p>
 *
 * @param rhs the other complex number
 * @return the complex number quotient
 * @throws NullPointerException if <code>rhs</code> is null
 */"
"public Complex conjugate() {
    if (isNaN()) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test9595() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.exp();
    Complex complex2 = complex1.ONE.atan();
    Complex complex3 = complex2.INF.pow(complex1);
    complex0.isInfinite();
    complex2.multiply(complex0);
    Complex complex4 = complex0.createComplex(768.44308694, Double.POSITIVE_INFINITY);
    Complex complex5 = complex4.exp();
    complex5.ONE.conjugate();
    complex4.isInfinite();
    Complex complex6 = new Complex(Double.POSITIVE_INFINITY, 768.44308694);
    complex3.INF.tan();
    complex4.pow(complex6);
    Complex complex7 = complex3.exp();
    complex4.atan();
    complex7.conjugate();
}","/**
 * Return the conjugate of this complex number. The conjugate of
 * ""A + Bi"" is ""A - Bi"".
 * <p>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals <code>Double.NaN</code>.</p>
 * <p>
 * If the imaginary part is infinite, and the real part is not NaN,
 * the returned value has infinite imaginary part of the opposite
 * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>
 * is <code>1 - NEGATIVE_INFINITY i</code></p>
 *
 * @return the conjugate of this Complex object
 */"
