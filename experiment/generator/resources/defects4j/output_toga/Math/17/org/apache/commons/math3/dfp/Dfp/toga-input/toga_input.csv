focal_method,test_prefix,docstring
"protected Dfp(final DfpField field, long x) {
    // initialize as if 0
    mant = new int[field.getRadixDigits()];
    nans = FINITE;
    this.field = field;
    boolean isLongMin = false;
    if (x == Long.MIN_VALUE) {
        // special case for Long.MIN_VALUE (-9223372036854775808)
        // we must shift it before taking its absolute value
        isLongMin = true;
        ++x;
    }
    // set the sign
    if (x < 0) {
        sign = -1;
        x = -x;
    } else {
        sign = 1;
    }
    exp = 0;
    while (x != 0) {
        System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);
        mant[mant.length - 1] = (int) (x % RADIX);
        x /= RADIX;
        exp++;
    }
    if (isLongMin) {
        // remove the shift added for Long.MIN_VALUE
        // we know in this case that fixing the last digit is sufficient
        for (int i = 0; i < mant.length - 1; i++) {
            if (mant[i] != 0) {
                mant[i]++;
                break;
            }
        }
    }
}","public void test00() throws Throwable {
    Dfp dfp0 = null;
    try {
        dfp0 = new Dfp((DfpField) null, 0L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.dfp.Dfp"", e);
    }
}","/**
 * Create an instance from a long value.
 * @param field field to which this instance belongs
 * @param x value to convert to an instance
 */"
"protected Dfp(final DfpField field, double x) {
    // initialize as if 0
    mant = new int[field.getRadixDigits()];
    sign = 1;
    exp = 0;
    nans = FINITE;
    this.field = field;
    long bits = Double.doubleToLongBits(x);
    long mantissa = bits & 0x000fffffffffffffL;
    int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;
    if (exponent == -1023) {
        // Zero or sub-normal
        if (x == 0) {
            // make sure 0 has the right sign
            if ((bits & 0x8000000000000000L) != 0) {
                sign = -1;
            }
            return;
        }
        exponent++;
        // Normalize the subnormal number
        while ((mantissa & 0x0010000000000000L) == 0) {
            exponent--;
            mantissa <<= 1;
        }
        mantissa &= 0x000fffffffffffffL;
    }
    if (exponent == 1024) {
        // infinity or NAN
        if (x != x) {
            sign = (byte) 1;
            nans = QNAN;
        } else if (x < 0) {
            sign = (byte) -1;
            nans = INFINITE;
        } else {
            sign = (byte) 1;
            nans = INFINITE;
        }
        return;
    }
    Dfp xdfp = new Dfp(field, mantissa);
    // Divide by 2^52, then add one
    xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());
    xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));
    if ((bits & 0x8000000000000000L) != 0) {
        xdfp = xdfp.negate();
    }
    System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
    sign = xdfp.sign;
    exp = xdfp.exp;
    nans = xdfp.nans;
}","public void test11() throws Throwable {
    Dfp dfp0 = null;
    try {
        dfp0 = new Dfp((DfpField) null, 549.05631869213);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.dfp.Dfp"", e);
    }
}","/**
 * Create an instance from a double value.
 * @param field field to which this instance belongs
 * @param x value to convert to an instance
 */"
"protected Dfp(final DfpField field) {
    mant = new int[field.getRadixDigits()];
    sign = 1;
    exp = 0;
    nans = FINITE;
    this.field = field;
}","public void test22() throws Throwable {
    Dfp dfp0 = null;
    try {
        dfp0 = new Dfp((DfpField) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.dfp.Dfp"", e);
    }
}","/**
 * Makes an instance with a value of zero.
 * @param field field to which this instance belongs
 */"
"public DfpField(final int decimalDigits) {
    this(decimalDigits, true);
}","public void test33() throws Throwable {
    DfpField dfpField0 = new DfpField((-1657));
}","/**
 * Create a factory for the specified number of radix digits.
 * <p>
 * Note that since the {@link Dfp} class uses 10000 as its radix, each radix
 * digit is equivalent to 4 decimal digits. This implies that asking for
 * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
 * all cases.
 * </p>
 * @param decimalDigits minimal number of decimal digits.
 */"
"public static Dfp copysign(final Dfp x, final Dfp y) {
    Dfp result = x.newInstance(x);
    result.sign = y.sign;
    return result;
}","public void test44() throws Throwable {
    // Undeclared exception!
    try {
        Dfp.copysign((Dfp) null, (Dfp) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.dfp.Dfp"", e);
    }
}","/**
 * Creates an instance that is the same as x except that it has the sign of y.
 * abs(x) = dfp.copysign(x, dfp.one)
 * @param x number to get the value from
 * @param y number to get the sign from
 * @return a number with the value of x and the sign of y
 */"
"protected Dfp(final DfpField field, byte x) {
    this(field, (long) x);
}","public void test55() throws Throwable {
    Dfp dfp0 = null;
    try {
        dfp0 = new Dfp((DfpField) null, (byte) (-93));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.dfp.Dfp"", e);
    }
}","/**
 * Create an instance from a byte value.
 * @param field field to which this instance belongs
 * @param x value to convert to an instance
 */"
