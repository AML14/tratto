focal_method,test_prefix,docstring
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[3];
    double[] doubleArray1 = new double[1];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(0.0, 0.0, doubleArray0, doubleArray1);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    try {
        highamHall54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray1, 0.0, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1 != 0
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test011() throws Throwable {
    double[] doubleArray0 = new double[8];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(0.0, 0.0, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(5).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    try {
        highamHall54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, doubleArray0, 3219.24015011664, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8 != 10
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    stepSize = forward ? step : -step;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // first stage
        computeDerivatives(stepStart, y, yDotK[0]);
        // next stages
        for (int k = 1; k < stages; ++k) {
            for (int j = 0; j < y0.length; ++j) {
                double sum = a[k - 1][0] * yDotK[0][j];
                for (int l = 1; l < k; ++l) {
                    sum += a[k - 1][l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
        }
        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
            double sum = b[0] * yDotK[0][j];
            for (int l = 1; l < stages; ++l) {
                sum += b[l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
        }
        // discrete events handling
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            // stepsize control for next step
            final double nextT = stepStart + stepSize;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            if (nextIsLast) {
                stepSize = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    stepStart = Double.NaN;
    stepSize = Double.NaN;
}","public void test022() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(eventHandler0).g(anyDouble(), any(double[].class));
    gillIntegrator0.addEventHandler(eventHandler0, 570.4101323738074, 570.4101323738074, 1017);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    // Undeclared exception!
    gillIntegrator0.integrate(expandableStatefulODE0, 570.4101323738074);
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test033() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator((-220.8858634), (-220.8858634), doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double double0 = dormandPrince54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (-220.8858634), doubleArray0, 0.0, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return evaluations.getMaximalCount();
}","public void test044() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1203.928542009299, 1203.928542009299, 1203.928542009299, Double.NaN);
    graggBulirschStoerIntegrator0.setMaxEvaluations(0);
    int int0 = graggBulirschStoerIntegrator0.getMaxEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test055() throws Throwable {
    double[] doubleArray0 = new double[6];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0, 0.0, doubleArray0, doubleArray0);
    double double0 = dormandPrince54Integrator0.getCurrentSignedStepsize();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test066() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-1062.793099660106));
    midpointIntegrator0.setMaxEvaluations(0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    try {
        midpointIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (-2884.68803), doubleArray0, 0.0, doubleArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded
        //
        verifyException(""org.apache.commons.math3.util.Incrementor$1"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test077() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(2596.669037036749, 2596.669037036749, 0.78125, 0.0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    // Undeclared exception!
    try {
        highamHall54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 0.0, (double[]) null, 0.0, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test088() throws Throwable {
    double[] doubleArray0 = new double[0];
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(2.384185791015625E-4, (-421.461515), doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    // Undeclared exception!
    try {
        graggBulirschStoerIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (-421.461515), doubleArray0, (-1943.57583495), doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.ode.nonstiff.GraggBulirschStoerIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            if (forward) {
                if (stepStart + stepSize >= t) {
                    stepSize = t - stepStart;
                }
            } else {
                if (stepStart + stepSize <= t) {
                    stepSize = t - stepStart;
                }
            }
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test099() throws Throwable {
    double[] doubleArray0 = new double[4];
    DormandPrince853Integrator dormandPrince853Integrator0 = new DormandPrince853Integrator(0.0, (-1.0), doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    try {
        dormandPrince853Integrator0.integrate(expandableStatefulODE0, (-2848.829017));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 != 4
        //
        verifyException(""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            if (forward) {
                if (stepStart + stepSize >= t) {
                    stepSize = t - stepStart;
                }
            } else {
                if (stepStart + stepSize <= t) {
                    stepSize = t - stepStart;
                }
            }
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test1010() throws Throwable {
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator(2481.1941896976573, 2481.1941896976573, 2481.1941896976573, 1.0);
    // Undeclared exception!
    try {
        highamHall54Integrator0.integrate((ExpandableStatefulODE) null, 2481.1941896976573);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final double[] yDot0 = new double[y.length];
    final double[] y1 = new double[y.length];
    final double[] yTmp = new double[y.length];
    final double[] yTmpDot = new double[y.length];
    final double[][] diagonal = new double[sequence.length - 1][];
    final double[][] y1Diag = new double[sequence.length - 1][];
    for (int k = 0; k < sequence.length - 1; ++k) {
        diagonal[k] = new double[y.length];
        y1Diag[k] = new double[y.length];
    }
    final double[][][] fk = new double[sequence.length][][];
    for (int k = 0; k < sequence.length; ++k) {
        fk[k] = new double[sequence[k] + 1][];
        // all substeps start at the same point, so share the first array
        fk[k][0] = yDot0;
        for (int l = 0; l < sequence[k]; ++l) {
            fk[k][l + 1] = new double[y0.length];
        }
    }
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[] yDot1 = new double[y0.length];
    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];
    // initial scaling
    final double[] scale = new double[mainSetDimension];
    rescale(y, y, scale);
    // initial order selection
    final double tol = (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));
    int targetIter = FastMath.max(1, FastMath.min(sequence.length - 2, (int) FastMath.floor(0.5 - 0.6 * log10R)));
    // set up an interpolator sharing the integrator arrays
    final AbstractStepInterpolator interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0, y1, yDot1, yMidDots, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    stepStart = equations.getTime();
    double hNew = 0;
    double maxError = Double.MAX_VALUE;
    boolean previousRejected = false;
    boolean firstTime = true;
    boolean newStep = true;
    boolean firstStepAlreadyComputed = false;
    initIntegration(equations.getTime(), y0, t);
    costPerTimeUnit[0] = 0;
    isLastStep = false;
    do {
        double error;
        boolean reject = false;
        if (newStep) {
            interpolator.shift();
            // first evaluation, at the beginning of the step
            if (!firstStepAlreadyComputed) {
                computeDerivatives(stepStart, y, yDot0);
            }
            if (firstTime) {
                hNew = initializeStep(forward, 2 * targetIter + 1, scale, stepStart, y, yDot0, yTmp, yTmpDot);
            }
            newStep = false;
        }
        stepSize = hNew;
        // step adjustment near bounds
        if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
            stepSize = t - stepStart;
        }
        final double nextT = stepStart + stepSize;
        isLastStep = forward ? (nextT >= t) : (nextT <= t);
        // iterate over several substep sizes
        int k = -1;
        for (boolean loop = true; loop; ) {
            ++k;
            // modified midpoint integration with the current substep
            if (!tryStep(stepStart, y, stepSize, k, scale, fk[k], (k == 0) ? yMidDots[0] : diagonal[k - 1], (k == 0) ? y1 : y1Diag[k - 1], yTmp)) {
                // the stability check failed, we reduce the global step
                hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
                reject = true;
                loop = false;
            } else {
                // the substep was computed successfully
                if (k > 0) {
                    // extrapolate the state at the end of the step
                    // using last iteration data
                    extrapolate(0, k, y1Diag, y1);
                    rescale(y, y1, scale);
                    // estimate the error at the end of the step.
                    error = 0;
                    for (int j = 0; j < mainSetDimension; ++j) {
                        final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
                        error += e * e;
                    }
                    error = FastMath.sqrt(error / mainSetDimension);
                    if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
                        // error is too big, we reduce the global step
                        hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
                        reject = true;
                        loop = false;
                    } else {
                        maxError = FastMath.max(4 * error, 1.0);
                        // compute optimal stepsize for this order
                        final double exp = 1.0 / (2 * k + 1);
                        double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);
                        final double pow = FastMath.pow(stepControl3, exp);
                        fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));
                        optimalStep[k] = FastMath.abs(filterStep(stepSize * fac, forward, true));
                        costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];
                        // check convergence
                        switch(k - targetIter) {
                            case -1:
                                if ((targetIter > 1) && !previousRejected) {
                                    // check if we can stop iterations now
                                    if (error <= 1.0) {
                                        // convergence have been reached just before targetIter
                                        loop = false;
                                    } else {
                                        // estimate if there is a chance convergence will
                                        // be reached on next iteration, using the
                                        // asymptotic evolution of error
                                        final double ratio = ((double) sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                                        if (error > ratio * ratio) {
                                            // we don't expect to converge on next iteration
                                            // we reject the step immediately and reduce order
                                            reject = true;
                                            loop = false;
                                            targetIter = k;
                                            if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                                --targetIter;
                                            }
                                            hNew = optimalStep[targetIter];
                                        }
                                    }
                                }
                                break;
                            case 0:
                                if (error <= 1.0) {
                                    // convergence has been reached exactly at targetIter
                                    loop = false;
                                } else {
                                    // estimate if there is a chance convergence will
                                    // be reached on next iteration, using the
                                    // asymptotic evolution of error
                                    final double ratio = ((double) sequence[k + 1]) / sequence[0];
                                    if (error > ratio * ratio) {
                                        // we don't expect to converge on next iteration
                                        // we reject the step immediately
                                        reject = true;
                                        loop = false;
                                        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                            --targetIter;
                                        }
                                        hNew = optimalStep[targetIter];
                                    }
                                }
                                break;
                            case 1:
                                if (error > 1.0) {
                                    reject = true;
                                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                        --targetIter;
                                    }
                                    hNew = optimalStep[targetIter];
                                }
                                loop = false;
                                break;
                            default:
                                if ((firstTime || isLastStep) && (error <= 1.0)) {
                                    loop = false;
                                }
                                break;
                        }
                    }
                }
            }
        }
        if (!reject) {
            // derivatives at end of step
            computeDerivatives(stepStart + stepSize, y1, yDot1);
        }
        // dense output handling
        double hInt = getMaxStep();
        if (!reject) {
            // extrapolate state at middle point of the step
            for (int j = 1; j <= k; ++j) {
                extrapolate(0, j, diagonal, yMidDots[0]);
            }
            final int mu = 2 * k - mudif + 3;
            for (int l = 0; l < mu; ++l) {
                // derivative at middle point of the step
                final int l2 = l / 2;
                double factor = FastMath.pow(0.5 * sequence[l2], l);
                int middleIndex = fk[l2].length / 2;
                for (int i = 0; i < y0.length; ++i) {
                    yMidDots[l + 1][i] = factor * fk[l2][middleIndex + l][i];
                }
                for (int j = 1; j <= k - l2; ++j) {
                    factor = FastMath.pow(0.5 * sequence[j + l2], l);
                    middleIndex = fk[l2 + j].length / 2;
                    for (int i = 0; i < y0.length; ++i) {
                        diagonal[j - 1][i] = factor * fk[l2 + j][middleIndex + l][i];
                    }
                    extrapolate(l2, j, diagonal, yMidDots[l + 1]);
                }
                for (int i = 0; i < y0.length; ++i) {
                    yMidDots[l + 1][i] *= stepSize;
                }
                // compute centered differences to evaluate next derivatives
                for (int j = (l + 1) / 2; j <= k; ++j) {
                    for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
                        for (int i = 0; i < y0.length; ++i) {
                            fk[j][m][i] -= fk[j][m - 2][i];
                        }
                    }
                }
            }
            if (mu >= 0) {
                // estimate the dense output coefficients
                final GraggBulirschStoerStepInterpolator gbsInterpolator = (GraggBulirschStoerStepInterpolator) interpolator;
                gbsInterpolator.computeCoefficients(mu, stepSize);
                if (useInterpolationError) {
                    // use the interpolation error to limit stepsize
                    final double interpError = gbsInterpolator.estimateError(scale);
                    hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu + 4)), 0.01));
                    if (interpError > 10.0) {
                        hNew = hInt;
                        reject = true;
                    }
                }
            }
        }
        if (!reject) {
            // Discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            stepStart = acceptStep(interpolator, y1, yDot1, t);
            // prepare next step
            interpolator.storeTime(stepStart);
            System.arraycopy(y1, 0, y, 0, y0.length);
            System.arraycopy(yDot1, 0, yDot0, 0, y0.length);
            firstStepAlreadyComputed = true;
            int optimalIter;
            if (k == 1) {
                optimalIter = 2;
                if (previousRejected) {
                    optimalIter = 1;
                }
            } else if (k <= targetIter) {
                optimalIter = k;
                if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
                    optimalIter = k - 1;
                } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
                    optimalIter = FastMath.min(k + 1, sequence.length - 2);
                }
            } else {
                optimalIter = k - 1;
                if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
                    optimalIter = k - 2;
                }
                if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
                    optimalIter = FastMath.min(k, sequence.length - 2);
                }
            }
            if (previousRejected) {
                // after a rejected step neither order nor stepsize
                // should increase
                targetIter = FastMath.min(optimalIter, k);
                hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);
            } else {
                // stepsize control
                if (optimalIter <= k) {
                    hNew = optimalStep[optimalIter];
                } else {
                    if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
                        hNew = filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k], forward, false);
                    } else {
                        hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k], forward, false);
                    }
                }
                targetIter = optimalIter;
            }
            newStep = true;
        }
        hNew = FastMath.min(hNew, hInt);
        if (!forward) {
            hNew = -hNew;
        }
        firstTime = false;
        if (reject) {
            isLastStep = false;
            previousRejected = true;
        } else {
            previousRejected = false;
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test1111() throws Throwable {
    double[] doubleArray0 = new double[0];
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(0.0, 0.0, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    // Undeclared exception!
    try {
        graggBulirschStoerIntegrator0.integrate(expandableStatefulODE0, 0.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.ode.nonstiff.GraggBulirschStoerIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {
    evaluations.incrementCount();
    expandable.computeDerivatives(t, y, yDot);
}","public void test1212() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.setMaxEvaluations(0);
    double[] doubleArray0 = new double[0];
    try {
        gillIntegrator0.computeDerivatives(0, doubleArray0, doubleArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded
        //
        verifyException(""org.apache.commons.math3.util.Incrementor$1"", e);
    }
}","/**
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 * @exception DimensionMismatchException if arrays dimensions do not match equations settings
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // initialize working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final double[] yDot = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
    interpolator.reinitialize(y, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    // set up integration control objects
    initIntegration(equations.getTime(), y0, t);
    // compute the initial Nordsieck vector using the configured starter integrator
    start(equations.getTime(), y, t);
    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
    interpolator.storeTime(stepStart);
    final int lastRow = nordsieck.getRowDimension() - 1;
    // reuse the step that was chosen by the starter integrator
    double hNew = stepSize;
    interpolator.rescale(hNew);
    // main integration loop
    isLastStep = false;
    do {
        double error = 10;
        while (error >= 1.0) {
            stepSize = hNew;
            // evaluate error using the last term of the Taylor expansion
            error = 0;
            for (int i = 0; i < mainSetDimension; ++i) {
                final double yScale = FastMath.abs(y[i]);
                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
                final double ratio = nordsieck.getEntry(lastRow, i) / tol;
                error += ratio * ratio;
            }
            error = FastMath.sqrt(error / mainSetDimension);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = computeStepGrowShrinkFactor(error);
                hNew = filterStep(stepSize * factor, forward, false);
                interpolator.rescale(hNew);
            }
        }
        // predict a first estimate of the state at step end
        final double stepEnd = stepStart + stepSize;
        interpolator.shift();
        interpolator.setInterpolatedTime(stepEnd);
        System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
        // evaluate the derivative
        computeDerivatives(stepEnd, y, yDot);
        // update Nordsieck vector
        final double[] predictedScaled = new double[y0.length];
        for (int j = 0; j < y0.length; ++j) {
            predictedScaled[j] = stepSize * yDot[j];
        }
        final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
        updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);
        interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);
        // discrete events handling
        interpolator.storeTime(stepEnd);
        stepStart = acceptStep(interpolator, y, yDot, t);
        scaled = predictedScaled;
        nordsieck = nordsieckTmp;
        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (resetOccurred) {
                // some events handler has triggered changes that
                // invalidate the derivatives, we need to restart from scratch
                start(stepStart, y, t);
                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
            }
            // stepsize control for next step
            final double factor = computeStepGrowShrinkFactor(error);
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
            interpolator.rescale(hNew);
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test1313() throws Throwable {
    AdamsBashforthIntegrator adamsBashforthIntegrator0 = new AdamsBashforthIntegrator(3, 2632.11502318578, 3, 3, 2632.11502318578);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    // Undeclared exception!
    try {
        adamsBashforthIntegrator0.integrate(expandableStatefulODE0, 2632.11502318578);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // matrix must have at least one column
        //
        verifyException(""org.apache.commons.math3.linear.Array2DRowRealMatrix"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final double[] yDot0 = new double[y.length];
    final double[] y1 = new double[y.length];
    final double[] yTmp = new double[y.length];
    final double[] yTmpDot = new double[y.length];
    final double[][] diagonal = new double[sequence.length - 1][];
    final double[][] y1Diag = new double[sequence.length - 1][];
    for (int k = 0; k < sequence.length - 1; ++k) {
        diagonal[k] = new double[y.length];
        y1Diag[k] = new double[y.length];
    }
    final double[][][] fk = new double[sequence.length][][];
    for (int k = 0; k < sequence.length; ++k) {
        fk[k] = new double[sequence[k] + 1][];
        // all substeps start at the same point, so share the first array
        fk[k][0] = yDot0;
        for (int l = 0; l < sequence[k]; ++l) {
            fk[k][l + 1] = new double[y0.length];
        }
    }
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[] yDot1 = new double[y0.length];
    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];
    // initial scaling
    final double[] scale = new double[mainSetDimension];
    rescale(y, y, scale);
    // initial order selection
    final double tol = (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));
    int targetIter = FastMath.max(1, FastMath.min(sequence.length - 2, (int) FastMath.floor(0.5 - 0.6 * log10R)));
    // set up an interpolator sharing the integrator arrays
    final AbstractStepInterpolator interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0, y1, yDot1, yMidDots, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    stepStart = equations.getTime();
    double hNew = 0;
    double maxError = Double.MAX_VALUE;
    boolean previousRejected = false;
    boolean firstTime = true;
    boolean newStep = true;
    boolean firstStepAlreadyComputed = false;
    initIntegration(equations.getTime(), y0, t);
    costPerTimeUnit[0] = 0;
    isLastStep = false;
    do {
        double error;
        boolean reject = false;
        if (newStep) {
            interpolator.shift();
            // first evaluation, at the beginning of the step
            if (!firstStepAlreadyComputed) {
                computeDerivatives(stepStart, y, yDot0);
            }
            if (firstTime) {
                hNew = initializeStep(forward, 2 * targetIter + 1, scale, stepStart, y, yDot0, yTmp, yTmpDot);
            }
            newStep = false;
        }
        stepSize = hNew;
        // step adjustment near bounds
        if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
            stepSize = t - stepStart;
        }
        final double nextT = stepStart + stepSize;
        isLastStep = forward ? (nextT >= t) : (nextT <= t);
        // iterate over several substep sizes
        int k = -1;
        for (boolean loop = true; loop; ) {
            ++k;
            // modified midpoint integration with the current substep
            if (!tryStep(stepStart, y, stepSize, k, scale, fk[k], (k == 0) ? yMidDots[0] : diagonal[k - 1], (k == 0) ? y1 : y1Diag[k - 1], yTmp)) {
                // the stability check failed, we reduce the global step
                hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
                reject = true;
                loop = false;
            } else {
                // the substep was computed successfully
                if (k > 0) {
                    // extrapolate the state at the end of the step
                    // using last iteration data
                    extrapolate(0, k, y1Diag, y1);
                    rescale(y, y1, scale);
                    // estimate the error at the end of the step.
                    error = 0;
                    for (int j = 0; j < mainSetDimension; ++j) {
                        final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
                        error += e * e;
                    }
                    error = FastMath.sqrt(error / mainSetDimension);
                    if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
                        // error is too big, we reduce the global step
                        hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
                        reject = true;
                        loop = false;
                    } else {
                        maxError = FastMath.max(4 * error, 1.0);
                        // compute optimal stepsize for this order
                        final double exp = 1.0 / (2 * k + 1);
                        double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);
                        final double pow = FastMath.pow(stepControl3, exp);
                        fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));
                        optimalStep[k] = FastMath.abs(filterStep(stepSize * fac, forward, true));
                        costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];
                        // check convergence
                        switch(k - targetIter) {
                            case -1:
                                if ((targetIter > 1) && !previousRejected) {
                                    // check if we can stop iterations now
                                    if (error <= 1.0) {
                                        // convergence have been reached just before targetIter
                                        loop = false;
                                    } else {
                                        // estimate if there is a chance convergence will
                                        // be reached on next iteration, using the
                                        // asymptotic evolution of error
                                        final double ratio = ((double) sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                                        if (error > ratio * ratio) {
                                            // we don't expect to converge on next iteration
                                            // we reject the step immediately and reduce order
                                            reject = true;
                                            loop = false;
                                            targetIter = k;
                                            if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                                --targetIter;
                                            }
                                            hNew = optimalStep[targetIter];
                                        }
                                    }
                                }
                                break;
                            case 0:
                                if (error <= 1.0) {
                                    // convergence has been reached exactly at targetIter
                                    loop = false;
                                } else {
                                    // estimate if there is a chance convergence will
                                    // be reached on next iteration, using the
                                    // asymptotic evolution of error
                                    final double ratio = ((double) sequence[k + 1]) / sequence[0];
                                    if (error > ratio * ratio) {
                                        // we don't expect to converge on next iteration
                                        // we reject the step immediately
                                        reject = true;
                                        loop = false;
                                        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                            --targetIter;
                                        }
                                        hNew = optimalStep[targetIter];
                                    }
                                }
                                break;
                            case 1:
                                if (error > 1.0) {
                                    reject = true;
                                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                                        --targetIter;
                                    }
                                    hNew = optimalStep[targetIter];
                                }
                                loop = false;
                                break;
                            default:
                                if ((firstTime || isLastStep) && (error <= 1.0)) {
                                    loop = false;
                                }
                                break;
                        }
                    }
                }
            }
        }
        if (!reject) {
            // derivatives at end of step
            computeDerivatives(stepStart + stepSize, y1, yDot1);
        }
        // dense output handling
        double hInt = getMaxStep();
        if (!reject) {
            // extrapolate state at middle point of the step
            for (int j = 1; j <= k; ++j) {
                extrapolate(0, j, diagonal, yMidDots[0]);
            }
            final int mu = 2 * k - mudif + 3;
            for (int l = 0; l < mu; ++l) {
                // derivative at middle point of the step
                final int l2 = l / 2;
                double factor = FastMath.pow(0.5 * sequence[l2], l);
                int middleIndex = fk[l2].length / 2;
                for (int i = 0; i < y0.length; ++i) {
                    yMidDots[l + 1][i] = factor * fk[l2][middleIndex + l][i];
                }
                for (int j = 1; j <= k - l2; ++j) {
                    factor = FastMath.pow(0.5 * sequence[j + l2], l);
                    middleIndex = fk[l2 + j].length / 2;
                    for (int i = 0; i < y0.length; ++i) {
                        diagonal[j - 1][i] = factor * fk[l2 + j][middleIndex + l][i];
                    }
                    extrapolate(l2, j, diagonal, yMidDots[l + 1]);
                }
                for (int i = 0; i < y0.length; ++i) {
                    yMidDots[l + 1][i] *= stepSize;
                }
                // compute centered differences to evaluate next derivatives
                for (int j = (l + 1) / 2; j <= k; ++j) {
                    for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
                        for (int i = 0; i < y0.length; ++i) {
                            fk[j][m][i] -= fk[j][m - 2][i];
                        }
                    }
                }
            }
            if (mu >= 0) {
                // estimate the dense output coefficients
                final GraggBulirschStoerStepInterpolator gbsInterpolator = (GraggBulirschStoerStepInterpolator) interpolator;
                gbsInterpolator.computeCoefficients(mu, stepSize);
                if (useInterpolationError) {
                    // use the interpolation error to limit stepsize
                    final double interpError = gbsInterpolator.estimateError(scale);
                    hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu + 4)), 0.01));
                    if (interpError > 10.0) {
                        hNew = hInt;
                        reject = true;
                    }
                }
            }
        }
        if (!reject) {
            // Discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            stepStart = acceptStep(interpolator, y1, yDot1, t);
            // prepare next step
            interpolator.storeTime(stepStart);
            System.arraycopy(y1, 0, y, 0, y0.length);
            System.arraycopy(yDot1, 0, yDot0, 0, y0.length);
            firstStepAlreadyComputed = true;
            int optimalIter;
            if (k == 1) {
                optimalIter = 2;
                if (previousRejected) {
                    optimalIter = 1;
                }
            } else if (k <= targetIter) {
                optimalIter = k;
                if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
                    optimalIter = k - 1;
                } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
                    optimalIter = FastMath.min(k + 1, sequence.length - 2);
                }
            } else {
                optimalIter = k - 1;
                if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
                    optimalIter = k - 2;
                }
                if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
                    optimalIter = FastMath.min(k, sequence.length - 2);
                }
            }
            if (previousRejected) {
                // after a rejected step neither order nor stepsize
                // should increase
                targetIter = FastMath.min(optimalIter, k);
                hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);
            } else {
                // stepsize control
                if (optimalIter <= k) {
                    hNew = optimalStep[optimalIter];
                } else {
                    if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
                        hNew = filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k], forward, false);
                    } else {
                        hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k], forward, false);
                    }
                }
                targetIter = optimalIter;
            }
            newStep = true;
        }
        hNew = FastMath.min(hNew, hInt);
        if (!forward) {
            hNew = -hNew;
        }
        firstTime = false;
        if (reject) {
            isLastStep = false;
            previousRejected = true;
        } else {
            previousRejected = false;
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","public void test1414() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(5, 0, 505.29965, 4.450312892752409);
    graggBulirschStoerIntegrator0.addStepHandler((StepHandler) null);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    ExpandableStatefulODE expandableStatefulODE0 = new ExpandableStatefulODE(firstOrderConverter0);
    // Undeclared exception!
    try {
        graggBulirschStoerIntegrator0.integrate(expandableStatefulODE0, (double) (-1211));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getMinStep() {
    return minStep;
}","public void test1515() throws Throwable {
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(5, 0, 505.29965, 4.450312892752409);
    graggBulirschStoerIntegrator0.setMaxEvaluations((-1211));
    assertEquals(5.0, graggBulirschStoerIntegrator0.getMinStep(), 0.01);
}","/**
 * Get the minimal step.
 * @return minimal step
 */"
"public String getName() {
    return name;
}","public void test1616() throws Throwable {
    double[] doubleArray0 = new double[1];
    HighamHall54Integrator highamHall54Integrator0 = new HighamHall54Integrator((-3730.0862259082087), 0.0, doubleArray0, doubleArray0);
    FixedStepHandler fixedStepHandler0 = mock(FixedStepHandler.class, new ViolatedAssumptionAnswer());
    StepNormalizer stepNormalizer0 = new StepNormalizer(0.0, fixedStepHandler0);
    highamHall54Integrator0.addStepHandler(stepNormalizer0);
    assertEquals(""Higham-Hall 5(4)"", highamHall54Integrator0.getName());
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test1717() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    gillIntegrator0.addEventHandler(eventHandler0, 0.0, (-450.374), 0, (UnivariateSolver) null);
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test1718() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    gillIntegrator0.addEventHandler(eventHandler0, 0.0, (-450.374), 0, (UnivariateSolver) null);
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test1819() throws Throwable {
    ClassicalRungeKuttaIntegrator classicalRungeKuttaIntegrator0 = new ClassicalRungeKuttaIntegrator((-1.1270175653862835));
    classicalRungeKuttaIntegrator0.clearEventHandlers();
    assertEquals(Double.NaN, classicalRungeKuttaIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test1820() throws Throwable {
    ClassicalRungeKuttaIntegrator classicalRungeKuttaIntegrator0 = new ClassicalRungeKuttaIntegrator((-1.1270175653862835));
    classicalRungeKuttaIntegrator0.clearEventHandlers();
    assertEquals(Double.NaN, classicalRungeKuttaIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {
    evaluations.incrementCount();
    expandable.computeDerivatives(t, y, yDot);
}","public void test1921() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    double[] doubleArray0 = new double[0];
    // Undeclared exception!
    try {
        gillIntegrator0.computeDerivatives(0, doubleArray0, doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 * @exception DimensionMismatchException if arrays dimensions do not match equations settings
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test2022() throws Throwable {
    double[] doubleArray0 = new double[2];
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(1523.4801996885988, 1523.4801996885988, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(1).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    try {
        graggBulirschStoerIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 1523.4801996885988, doubleArray0, 1523.4801996885988, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // too small integration interval: length = 0
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test2123() throws Throwable {
    double[] doubleArray0 = new double[0];
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator(0.0, 2260.9539330813764, doubleArray0, doubleArray0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    // Undeclared exception!
    dormandPrince54Integrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (-220.8858634), doubleArray0, 0.0, doubleArray0);
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test2224() throws Throwable {
    ThreeEighthesIntegrator threeEighthesIntegrator0 = new ThreeEighthesIntegrator(0.0);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[6];
    try {
        threeEighthesIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, 474.0, doubleArray0, 110.2558, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 0
        //
        verifyException(""org.apache.commons.math3.ode.AbstractIntegrator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2325() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(570.4101323738074, 570.4101323738074, 570.4101323738074, 570.4101323738074, (-1829.963)).when(eventHandler0).g(anyDouble(), any(double[].class));
    gillIntegrator0.addEventHandler(eventHandler0, 570.4101323738074, 570.4101323738074, 1017);
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2326() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(570.4101323738074, 570.4101323738074, 570.4101323738074, 570.4101323738074, (-1829.963)).when(eventHandler0).g(anyDouble(), any(double[].class));
    gillIntegrator0.addEventHandler(eventHandler0, 570.4101323738074, 570.4101323738074, 1017);
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    if (y0.length != equations.getDimension()) {
        throw new DimensionMismatchException(y0.length, equations.getDimension());
    }
    if (y.length != equations.getDimension()) {
        throw new DimensionMismatchException(y.length, equations.getDimension());
    }
    // prepare expandable stateful equations
    final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
    expandableODE.setTime(t0);
    expandableODE.setPrimaryState(y0);
    // perform integration
    integrate(expandableODE, t);
    // extract results back from the stateful equations
    System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
    return expandableODE.getTime();
}","public void test2327() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(570.4101323738074, 570.4101323738074, 570.4101323738074, 570.4101323738074, (-1829.963)).when(eventHandler0).g(anyDouble(), any(double[].class));
    gillIntegrator0.addEventHandler(eventHandler0, 570.4101323738074, 570.4101323738074, 1017);
    SecondOrderDifferentialEquations secondOrderDifferentialEquations0 = mock(SecondOrderDifferentialEquations.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(secondOrderDifferentialEquations0).getDimension();
    FirstOrderConverter firstOrderConverter0 = new FirstOrderConverter(secondOrderDifferentialEquations0);
    double[] doubleArray0 = new double[0];
    double double0 = gillIntegrator0.integrate((FirstOrderDifferentialEquations) firstOrderConverter0, (double) 1017, doubleArray0, (-1623.58756927), doubleArray0);
    assertEquals((-1623.58756927), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getCurrentStepStart() {
    return stepStart;
}","public void test2428() throws Throwable {
    double[] doubleArray0 = new double[7];
    GraggBulirschStoerIntegrator graggBulirschStoerIntegrator0 = new GraggBulirschStoerIntegrator(0.0, (-193.6399867), doubleArray0, doubleArray0);
    graggBulirschStoerIntegrator0.setMaxEvaluations(58);
    assertEquals(Double.NaN, graggBulirschStoerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2530() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(0.075);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(""5e~bUB;g"").when(eventHandler0).toString();
    eulerIntegrator0.addEventHandler(eventHandler0, 0.0, 0.075, (-7));
    Collection<EventHandler> collection0 = eulerIntegrator0.getEventHandlers();
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2531() throws Throwable {
    EulerIntegrator eulerIntegrator0 = new EulerIntegrator(0.075);
    EventHandler eventHandler0 = mock(EventHandler.class, new ViolatedAssumptionAnswer());
    doReturn(""5e~bUB;g"").when(eventHandler0).toString();
    eulerIntegrator0.addEventHandler(eventHandler0, 0.0, 0.075, (-7));
    Collection<EventHandler> collection0 = eulerIntegrator0.getEventHandlers();
    assertEquals(Double.NaN, eulerIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2632() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getName();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2633() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getName();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2734() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getStepHandlers();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2735() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getStepHandlers();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2836() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    double double0 = gillIntegrator0.getCurrentStepStart();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2837() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    double double0 = gillIntegrator0.getCurrentStepStart();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return evaluations.getMaximalCount();
}","public void test2938() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    int int0 = gillIntegrator0.getMaxEvaluations();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test2939() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    int int0 = gillIntegrator0.getMaxEvaluations();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test2940() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator(570.4101323738074);
    int int0 = gillIntegrator0.getMaxEvaluations();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test3041() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getEvaluations();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test3042() throws Throwable {
    GillIntegrator gillIntegrator0 = new GillIntegrator((-450.374));
    gillIntegrator0.getEvaluations();
    assertEquals(Double.NaN, gillIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test3143() throws Throwable {
    DormandPrince54Integrator dormandPrince54Integrator0 = new DormandPrince54Integrator((-9.147934308113573), (-9.147934308113573), (-3005.0), (-3005.0));
    double double0 = dormandPrince54Integrator0.getCurrentSignedStepsize();
    assertEquals(9.147934308113573, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentSignedStepsize() {
    return stepSize;
}","public void test3244() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-1062.793099660106));
    midpointIntegrator0.clearStepHandlers();
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentSignedStepsize(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getCurrentStepStart() {
    return stepStart;
}","public void test3245() throws Throwable {
    MidpointIntegrator midpointIntegrator0 = new MidpointIntegrator((-1062.793099660106));
    midpointIntegrator0.clearStepHandlers();
    assertEquals(Double.NaN, midpointIntegrator0.getCurrentStepStart(), 0.01);
}","/**
 * {@inheritDoc}
 */"
