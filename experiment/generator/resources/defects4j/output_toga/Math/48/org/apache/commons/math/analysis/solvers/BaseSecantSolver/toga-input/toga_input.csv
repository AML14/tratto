focal_method,test_prefix,docstring
"public double getStartValue() {
    return searchStart;
}","public void test000() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1785.980494615, 227.421396);
    Ceil ceil0 = new Ceil();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(1024, (UnivariateRealFunction) ceil0, (-4088.1339917), (double) 1024, allowedSolution0);
    assertEquals((-1532.0669958499998), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test001() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(1785.980494615, 227.421396);
    Ceil ceil0 = new Ceil();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(1024, (UnivariateRealFunction) ceil0, (-4088.1339917), (double) 1024, allowedSolution0);
    assertEquals((-0.026840277934297774), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test012() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-6723.93));
    Abs abs0 = new Abs();
    double double0 = illinoisSolver0.solve(414, (UnivariateRealFunction) abs0, 0.15623792920103693, 0.0);
    assertEquals(0.07811896460051847, illinoisSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(int maxEval, FUNC f, double min, double max) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min));
}","public void test013() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-6723.93));
    Abs abs0 = new Abs();
    double double0 = illinoisSolver0.solve(414, (UnivariateRealFunction) abs0, 0.15623792920103693, 0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test024() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-864.2), (-2125.2));
    Log1p log1p0 = new Log1p();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = illinoisSolver0.solve(2, (UnivariateRealFunction) log1p0, 0.0, (double) 2, 2012.456450328, allowedSolution0);
    assertEquals(2012.456450328, illinoisSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test025() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-864.2), (-2125.2));
    Log1p log1p0 = new Log1p();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = illinoisSolver0.solve(2, (UnivariateRealFunction) log1p0, 0.0, (double) 2, 2012.456450328, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test036() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(215, (UnivariateRealFunction) gaussian0, (-219.1901488425366), (-219.1901488425366), (double) 215, allowedSolution0);
    assertEquals(215.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test037() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(215, (UnivariateRealFunction) gaussian0, (-219.1901488425366), (-219.1901488425366), (double) 215, allowedSolution0);
    assertEquals((-219.1901488425366), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test048() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian((-7.650976138217585), 25);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(25, univariateRealFunction0, (-808.9), (double) 25, (-7.650976138217585));
    assertEquals((-7.650976138217585), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test049() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian((-7.650976138217585), 25);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(25, univariateRealFunction0, (-808.9), (double) 25, (-7.650976138217585));
    assertEquals((-808.8999999999999), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test0510() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, regulaFalsiSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test0511() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test0512() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(1.176342548272881E-8, 1.176342548272881E-8);
    HarmonicOscillator harmonicOscillator0 = new HarmonicOscillator(1.176342548272881E-8, 0.0, 1.176342548272881E-8);
    UnivariateRealFunction univariateRealFunction0 = harmonicOscillator0.derivative();
    regulaFalsiSolver0.solve(62, univariateRealFunction0, 0.0, 0.0, 0.0);
    double double0 = regulaFalsiSolver0.doSolve();
    assertEquals(0.0, regulaFalsiSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"public double getStartValue() {
    return searchStart;
}","public void test0613() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    pegasusSolver0.solve(8, univariateRealFunction0, (-1.504961346353674E-8), 2608.0, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals(1303.999999992475, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test0614() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    pegasusSolver0.solve(8, univariateRealFunction0, (-1.504961346353674E-8), 2608.0, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals(8.784354577073827E-9, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test0715() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    pegasusSolver0.solve(3333, (UnivariateRealFunction) sigmoid0, (-2993.2715265), 549.77032, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals((-1221.75060325), pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test0716() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Sigmoid sigmoid0 = new Sigmoid((-2.2250738585072014E-308), 3333);
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    pegasusSolver0.solve(3333, (UnivariateRealFunction) sigmoid0, (-2993.2715265), 549.77032, allowedSolution0);
    double double0 = pegasusSolver0.doSolve();
    assertEquals((-702.9609497129845), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test0817() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-69.934811), (-69.934811));
    Atanh atanh0 = new Atanh();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        illinoisSolver0.solve(1, (UnivariateRealFunction) atanh0, (-2621.940926377), (-269.5762), allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (1) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test0918() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-4.8559), (-4.8559));
    Cbrt cbrt0 = new Cbrt();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(5, (UnivariateRealFunction) cbrt0, (-4.8559), (-465.9968625720741), 1331.339230942915, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [-4.856, -465.997]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1019() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver();
    Floor floor0 = new Floor();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        regulaFalsiSolver0.solve(2979, (UnivariateRealFunction) floor0, 359.7455671164, (double) 2979, (double) 2979, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [359.746, 2,979], values: [359, 2,979]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1120() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    // Undeclared exception!
    try {
        pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, 1.0E-6, 3128.7, 3128.7, (AllowedSolution) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseSecantSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1221() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    // Undeclared exception!
    try {
        pegasusSolver0.solve((-3237), (UnivariateRealFunction) gaussian0, 6.4281638347818415E-6, 1.9868161777724352E-8, 1055.616);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (-3,237) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1322() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Floor floor0 = new Floor();
    // Undeclared exception!
    try {
        pegasusSolver0.solve(793, (UnivariateRealFunction) floor0, (double) 793, (-0.12502530217170715), (double) 793);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [793, -0.125]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test1423() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.0), (-1.0));
    // Undeclared exception!
    try {
        illinoisSolver0.solve(1023, (UnivariateRealFunction) null, (-2407.914897403), (-2407.728119), (-1.0));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1524() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2714.955898046835, 2714.955898046835);
    // Undeclared exception!
    try {
        pegasusSolver0.doSolve();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1625() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver(2281.1891362530178);
    Asin asin0 = new Asin();
    regulaFalsiSolver0.setup(2144871013, asin0, 2144871013, 44.79549384710194, 44.79549384710194);
    // Undeclared exception!
    try {
        regulaFalsiSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [2,144,871,013, 44.795]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // If one of the bounds is the exact root, return it. Since these are
    // not under-approximations or over-approximations, we can return them
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // If the new approximation is the exact root, return it. Since
        // this is not an under-approximation or an over-approximation,
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // If the function value of the last approximation is too small,
        // given the function value accuracy, then we can't get closer to
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // If the current interval is within the given accuracies, we
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","public void test1726() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07738), (-360.07738));
    Sinc sinc0 = new Sinc();
    pegasusSolver0.setup(5, sinc0, (-2979.801839635637), 1.0E-15, (-2.705217036836349));
    // Undeclared exception!
    try {
        pegasusSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [-2,979.802, 0], values: [0, 1]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test1827() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(5.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1828() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(4.195388262479115, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test1929() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(1.0E-6, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1930() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(4.195388262479115, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2031() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, 1.0E-6, 2725.29567932, 2725.29567932, allowedSolution0);
    assertEquals(1.0E-6, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2032() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, 1.0E-6, 2725.29567932, 2725.29567932, allowedSolution0);
    assertEquals(1.0E-6, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2133() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2714.955898046835, 2714.955898046835);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 0.7784825085259628, 952.6424587944366, 952.6424587944366, allowedSolution0);
    assertEquals(0.7784825085259628, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2134() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2714.955898046835, 2714.955898046835);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 0.7784825085259628, 952.6424587944366, 952.6424587944366, allowedSolution0);
    assertEquals(952.6424587944366, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2235() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, (double) 7, 2725.29567932, allowedSolution0);
    assertEquals(7.0, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test2236() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, (double) 7, 2725.29567932, allowedSolution0);
    assertEquals(2714.716537644605, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2337() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07738), 3128.7, 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2.705217036836349), 951.92584075, 951.92584075, allowedSolution0);
    assertEquals(951.92584075, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2338() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07738), 3128.7, 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2.705217036836349), 951.92584075, 951.92584075, allowedSolution0);
    assertEquals(951.92584075, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2439() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462), 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2.705217036836349), 951.92584075, 951.92584075, allowedSolution0);
    assertEquals(951.92584075, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2440() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462), 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, (-2.705217036836349), 951.92584075, 951.92584075, allowedSolution0);
    assertEquals(951.9025740608109, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2541() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(18, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 18, (double) 18, allowedSolution0);
    assertEquals(1.0E-6, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2542() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), (-360.07737924462));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = pegasusSolver0.solve(18, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 18, (double) 18, allowedSolution0);
    assertEquals(15.707963267948978, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test2643() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(8, univariateRealFunction0, (-808.9), 1024.0, 1055.616);
    assertEquals(1024.0, pegasusSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test2644() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0);
    Gaussian gaussian0 = new Gaussian(0.0, 2719.82);
    UnivariateRealFunction univariateRealFunction0 = gaussian0.derivative();
    double double0 = pegasusSolver0.solve(8, univariateRealFunction0, (-808.9), 1024.0, 1055.616);
    assertEquals(6.4281638347818415E-6, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test2745() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver();
    Signum signum0 = new Signum();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = regulaFalsiSolver0.solve(1074, (UnivariateRealFunction) signum0, (-1352.308), (double) 1074, allowedSolution0);
    assertEquals((-139.154), regulaFalsiSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test2746() throws Throwable {
    RegulaFalsiSolver regulaFalsiSolver0 = new RegulaFalsiSolver();
    Signum signum0 = new Signum();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = regulaFalsiSolver0.solve(1074, (UnivariateRealFunction) signum0, (-1352.308), (double) 1074, allowedSolution0);
    assertEquals((-2.07577828822484E-7), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, FUNC f, double min, double max) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min));
}","public void test2847() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-2814.358572557852), (-1240.9191091528942));
    Sinh sinh0 = new Sinh();
    // Undeclared exception!
    try {
        illinoisSolver0.solve(1255, (UnivariateRealFunction) sinh0, (-2814.358572557852), 2426.81716056);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (1,255) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2948() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07738), (-360.07738));
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = pegasusSolver0.solve(13, (UnivariateRealFunction) sinc0, (-2.705217036836349), 951.92584075, 951.92584075, allowedSolution0);
    assertEquals(951.9025740377073, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test3049() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, (double) 7, 2725.29567932, allowedSolution0);
    assertEquals(7.0, pegasusSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3050() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(2725.29567932, 2725.29567932);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(7, (UnivariateRealFunction) sinc0, (double) 7, 2725.29567932, allowedSolution0);
    assertEquals(2714.716537644605, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test3151() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(5.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test3152() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 1.0E-6, (double) 5, (double) 5, allowedSolution0);
    assertEquals(1.0E-6, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3253() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Sinc sinc0 = new Sinc();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(5, (UnivariateRealFunction) sinc0, 3128.7, 0.0, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [3,128.7, 0]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getStartValue() {
    return searchStart;
}","public void test3354() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Floor floor0 = new Floor();
    double double0 = pegasusSolver0.solve(793, (UnivariateRealFunction) floor0, (double) 793, 1.0E-6, (double) 793);
    assertEquals(793.0, pegasusSolver0.getStartValue(), 0.01);
}","/**
 * @return the initial guess.
 */"
"@Override
public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue) {
    return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);
}","public void test3355() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver((-360.07737924462), 2725.29567932, 3128.7);
    Floor floor0 = new Floor();
    double double0 = pegasusSolver0.solve(793, (UnivariateRealFunction) floor0, (double) 793, 1.0E-6, (double) 793);
    assertEquals(1.0E-6, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMax() {
    return searchMax;
}","public void test3456() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966));
    Identity identity0 = new Identity();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = illinoisSolver0.solve(2462, (UnivariateRealFunction) identity0, (-1.5707963267948966), 2594214.935144661, allowedSolution0);
    assertEquals(2594214.935144661, illinoisSolver0.getMax(), 0.01);
}","/**
 * @return the higher end of the search interval.
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3457() throws Throwable {
    IllinoisSolver illinoisSolver0 = new IllinoisSolver((-1.5707963267948966), (-1.5707963267948966));
    Identity identity0 = new Identity();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = illinoisSolver0.solve(2462, (UnivariateRealFunction) identity0, (-1.5707963267948966), 2594214.935144661, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final AllowedSolution allowedSolution) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);
}","public void test3558() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver(0.0, 0.0, 0.0);
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve(0, (UnivariateRealFunction) null, (double) 0, (-1645.0), allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(final int maxEval, final UnivariateRealFunction f, final double min, final double max, final double startValue, final AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test3659() throws Throwable {
    PegasusSolver pegasusSolver0 = new PegasusSolver();
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    try {
        pegasusSolver0.solve((-2943), (UnivariateRealFunction) gaussian0, (-2246.38), (-532.00254439), (-219.1901488425366), allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (-2,943) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
