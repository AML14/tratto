focal_method,test_prefix,docstring
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test00() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    int[] intArray0 = new int[4];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    EuclideanIntegerPoint euclideanIntegerPoint1 = new EuclideanIntegerPoint(intArray0);
    cluster0.addPoint(euclideanIntegerPoint1);
    cluster0.addPoint(euclideanIntegerPoint0);
    // Undeclared exception!
    try {
        kMeansPlusPlusClusterer0.cluster(list0, 1001, (-149));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 0, Size: 0
        //
        verifyException(""java.util.ArrayList"", e);
    }
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test11() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    int[] intArray0 = new int[0];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    cluster0.addPoint(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    cluster0.addPoint(euclideanIntegerPoint0);
    cluster0.addPoint(euclideanIntegerPoint0);
    // Undeclared exception!
    try {
        kMeansPlusPlusClusterer0.cluster(list0, 1312, 2);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 0, Size: 0
        //
        verifyException(""java.util.ArrayList"", e);
    }
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test33() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>((EuclideanIntegerPoint) null);
    cluster0.addPoint((EuclideanIntegerPoint) null);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    // Undeclared exception!
    try {
        kMeansPlusPlusClusterer0.cluster(list0, 0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer"", e);
    }
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test44() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    int[] intArray0 = new int[4];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    int[] intArray1 = new int[7];
    EuclideanIntegerPoint euclideanIntegerPoint1 = new EuclideanIntegerPoint(intArray1);
    cluster0.addPoint(euclideanIntegerPoint1);
    cluster0.addPoint(euclideanIntegerPoint0);
    // Undeclared exception!
    try {
        kMeansPlusPlusClusterer0.cluster(list0, 0, (-2568));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test55() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    int[] intArray0 = new int[4];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    cluster0.addPoint(euclideanIntegerPoint0);
    // Undeclared exception!
    kMeansPlusPlusClusterer0.cluster(list0, 1796, (-149));
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test77() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0);
    int[] intArray0 = new int[0];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    cluster0.addPoint(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    cluster0.addPoint(euclideanIntegerPoint0);
    kMeansPlusPlusClusterer0.cluster(list0, 2, 2);
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
"public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) {
    // create the initial clusters
    List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
    assignPointsToClusters(clusters, points);
    // iterate through updating the centers until we're done
    final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
    for (int count = 0; count < max; count++) {
        boolean clusteringChanged = false;
        List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
        for (final Cluster<T> cluster : clusters) {
            final T newCenter;
            if (cluster.getPoints().isEmpty()) {
                switch(emptyStrategy) {
                    case LARGEST_VARIANCE:
                        newCenter = getPointFromLargestVarianceCluster(clusters);
                        break;
                    case LARGEST_POINTS_NUMBER:
                        newCenter = getPointFromLargestNumberCluster(clusters);
                        break;
                    case FARTHEST_POINT:
                        newCenter = getFarthestPoint(clusters);
                        break;
                    default:
                        throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
                }
                clusteringChanged = true;
            } else {
                newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
                if (!newCenter.equals(cluster.getCenter())) {
                    clusteringChanged = true;
                }
            }
            newClusters.add(new Cluster<T>(newCenter));
        }
        if (!clusteringChanged) {
            return clusters;
        }
        assignPointsToClusters(newClusters, points);
        clusters = newClusters;
    }
    return clusters;
}","public void test88() throws Throwable {
    MockRandom mockRandom0 = new MockRandom((-546L));
    KMeansPlusPlusClusterer.EmptyClusterStrategy kMeansPlusPlusClusterer_EmptyClusterStrategy0 = KMeansPlusPlusClusterer.EmptyClusterStrategy.ERROR;
    KMeansPlusPlusClusterer<EuclideanIntegerPoint> kMeansPlusPlusClusterer0 = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(mockRandom0, kMeansPlusPlusClusterer_EmptyClusterStrategy0);
    int[] intArray0 = new int[6];
    EuclideanIntegerPoint euclideanIntegerPoint0 = new EuclideanIntegerPoint(intArray0);
    Cluster<EuclideanIntegerPoint> cluster0 = new Cluster<EuclideanIntegerPoint>(euclideanIntegerPoint0);
    List<EuclideanIntegerPoint> list0 = cluster0.getPoints();
    // Undeclared exception!
    try {
        kMeansPlusPlusClusterer0.cluster(list0, (-850), 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Runs the K-means++ clustering algorithm.
 *
 * @param points the points to cluster
 * @param k the number of clusters to split the data into
 * @param maxIterations the maximum number of iterations to run the algorithm
 *     for.  If negative, no maximum will be used
 * @return a list of clusters containing the points
 */"
