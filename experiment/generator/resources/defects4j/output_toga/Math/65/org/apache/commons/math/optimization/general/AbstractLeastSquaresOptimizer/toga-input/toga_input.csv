focal_method,test_prefix,docstring
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test000() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((MultivariateMatrixFunction) null).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn((double[]) null).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = new double[9];
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0, doubleArray1, doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test011() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = new double[1];
    try {
        levenbergMarquardtOptimizer0.optimize((DifferentiableMultivariateVectorialFunction) null, doubleArray0, doubleArray1, doubleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // dimensions mismatch 7 != 1
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test022() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[8];
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0, doubleArray1, doubleArray1);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // dimensions mismatch 5 != 8
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {
    if (rows <= cols) {
        throw new OptimizationException(LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);
    }
    double[] errors = new double[cols];
    final double c = Math.sqrt(getChiSquare() / (rows - cols));
    double[][] covar = getCovariances();
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test033() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cols = 0;
    levenbergMarquardtOptimizer0.cols = 36;
    try {
        levenbergMarquardtOptimizer0.guessParametersErrors();
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // no degrees of freedom (0 measurements, 36 parameters)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Guess the errors in optimized parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @return errors in optimized parameters
 * @exception FunctionEvaluationException if the function jacobian cannot b evaluated
 * @exception OptimizationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test044() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cost = (-527.9837694436);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test045() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cost = (-527.9837694436);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}","public void test046() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cost = (-527.9837694436);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */"
"public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {
    if (rows <= cols) {
        throw new OptimizationException(LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);
    }
    double[] errors = new double[cols];
    final double c = Math.sqrt(getChiSquare() / (rows - cols));
    double[][] covar = getCovariances();
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test057() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 100;
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 100;
    levenbergMarquardtOptimizer0.residualsWeights = doubleArray0;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.guessParametersErrors();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Guess the errors in optimized parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @return errors in optimized parameters
 * @exception FunctionEvaluationException if the function jacobian cannot b evaluated
 * @exception OptimizationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {
    if (rows <= cols) {
        throw new OptimizationException(LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);
    }
    double[] errors = new double[cols];
    final double c = Math.sqrt(getChiSquare() / (rows - cols));
    double[][] covar = getCovariances();
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test068() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 100;
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 2;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.guessParametersErrors();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Guess the errors in optimized parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @return errors in optimized parameters
 * @exception FunctionEvaluationException if the function jacobian cannot b evaluated
 * @exception OptimizationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test079() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = (-208);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test0710() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = (-208);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}","public void test0711() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = (-208);
    double double0 = levenbergMarquardtOptimizer0.getChiSquare();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test0812() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cost = (double) 124;
    double double0 = gaussNewtonOptimizer0.getRMS();
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test0813() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cost = (double) 124;
    double double0 = gaussNewtonOptimizer0.getRMS();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test0814() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cost = (double) 124;
    double double0 = gaussNewtonOptimizer0.getRMS();
    assertEquals(Integer.MAX_VALUE, gaussNewtonOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test0915() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[5];
    levenbergMarquardtOptimizer0.residualsWeights = doubleArray0;
    doubleArray0[0] = (double) 100;
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 100;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.getRMS();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test1016() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[1];
    doubleArray1[0] = (double) 100;
    levenbergMarquardtOptimizer0.residualsWeights = doubleArray1;
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 100;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.getRMS();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test1117() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[5];
    levenbergMarquardtOptimizer0.cost = 1.0;
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 1684;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.getRMS();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1218() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    doReturn((double[][]) null).when(multivariateMatrixFunction0).value(any(double[].class));
    double[] doubleArray0 = new double[1];
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(doubleArray0).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    double[] doubleArray1 = new double[1];
    doubleArray1[0] = (double) 100;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray1, doubleArray1, doubleArray1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1319() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    double[][] doubleArray0 = new double[4][1];
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = (double) 100;
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((MultivariateMatrixFunction) null).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn((double[]) null).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    double[] doubleArray2 = new double[4];
    // Undeclared exception!
    try {
        gaussNewtonOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray2, doubleArray2, doubleArray2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1420() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    double[] doubleArray0 = new double[4];
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(doubleArray0).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    double[] doubleArray1 = new double[7];
    try {
        gaussNewtonOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray1, doubleArray1, doubleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // dimensions mismatch 4 != 7
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1521() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    double[] doubleArray0 = new double[9];
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(doubleArray0).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    double[] doubleArray1 = new double[5];
    try {
        gaussNewtonOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray1, doubleArray1, doubleArray1);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // dimensions mismatch 9 != 5
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // tests for convergence.
            if (checker != null) {
                // we use the vectorial convergence checker
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            } else {
                // we use the Levenberg-Marquardt specific convergence parameters
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            }
            // tests for termination and stringent tolerances
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}","public void test1622() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxEvaluations(1);
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.doOptimize();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1723() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    double[][] doubleArray0 = new double[4][1];
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    doReturn(doubleArray0).when(multivariateMatrixFunction0).value(any(double[].class));
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = (double) 100;
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(doubleArray1).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    // Undeclared exception!
    try {
        gaussNewtonOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray1, doubleArray1, doubleArray1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1824() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[1];
    levenbergMarquardtOptimizer0.residualsWeights = doubleArray0;
    double[][] doubleArray1 = new double[3][6];
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    doReturn((double[][]) null).when(multivariateMatrixFunction0).value(any(double[].class));
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(levenbergMarquardtOptimizer0.residualsWeights).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0, doubleArray0, doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test1925() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[][] doubleArray0 = new double[2][1];
    double[] doubleArray1 = new double[4];
    doubleArray0[0] = doubleArray1;
    double[] doubleArray2 = new double[1];
    MultivariateMatrixFunction multivariateMatrixFunction0 = mock(MultivariateMatrixFunction.class, new ViolatedAssumptionAnswer());
    doReturn(doubleArray0).when(multivariateMatrixFunction0).value(any(double[].class));
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn(multivariateMatrixFunction0).when(differentiableMultivariateVectorialFunction0).jacobian();
    doReturn(doubleArray1).when(differentiableMultivariateVectorialFunction0).value(any(double[].class));
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0[0], doubleArray0[0], doubleArray2);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // dimensions mismatch 2 != 4
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test2026() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((MultivariateMatrixFunction) null).when(differentiableMultivariateVectorialFunction0).jacobian();
    gaussNewtonOptimizer0.setMaxIterations((-2261));
    double[] doubleArray0 = new double[0];
    try {
        gaussNewtonOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0, doubleArray0, doubleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // maximal number of iterations (-2,261) exceeded
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2127() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxIterations(1);
    levenbergMarquardtOptimizer0.incrementIterationsCounter();
    assertEquals(1, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test2228() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cols = 105;
    int int0 = levenbergMarquardtOptimizer0.getJacobianEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2229() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cols = 105;
    int int0 = levenbergMarquardtOptimizer0.getJacobianEvaluations();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2230() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.cols = 105;
    int int0 = levenbergMarquardtOptimizer0.getJacobianEvaluations();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test2331() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.rows = (-1989);
    int int0 = gaussNewtonOptimizer0.getJacobianEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2332() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.rows = (-1989);
    int int0 = gaussNewtonOptimizer0.getJacobianEvaluations();
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2333() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.rows = (-1989);
    int int0 = gaussNewtonOptimizer0.getJacobianEvaluations();
    assertEquals(Integer.MAX_VALUE, gaussNewtonOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2434() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cols = 124;
    int int0 = gaussNewtonOptimizer0.getEvaluations();
    assertEquals(Integer.MAX_VALUE, gaussNewtonOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2435() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cols = 124;
    int int0 = gaussNewtonOptimizer0.getEvaluations();
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getEvaluations() {
    return objectiveEvaluations;
}","public void test2436() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cols = 124;
    int int0 = gaussNewtonOptimizer0.getEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2537() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = 35;
    int int0 = levenbergMarquardtOptimizer0.getEvaluations();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getEvaluations() {
    return objectiveEvaluations;
}","public void test2538() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = 35;
    int int0 = levenbergMarquardtOptimizer0.getEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2539() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = 35;
    int int0 = levenbergMarquardtOptimizer0.getEvaluations();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test2640() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    assertEquals(Double.NaN, gaussNewtonOptimizer0.getRMS(), 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","public void test2641() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    gaussNewtonOptimizer0.rows = (-586);
    double double0 = gaussNewtonOptimizer0.getRMS();
    assertEquals(-0.0, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2742() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2743() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.setMaxIterations(0);
    int int0 = gaussNewtonOptimizer0.getMaxIterations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test2844() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxIterations((-587));
    int int0 = levenbergMarquardtOptimizer0.getMaxIterations();
    assertEquals((-587), int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2945() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test2946() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxEvaluations(0);
    int int0 = levenbergMarquardtOptimizer0.getMaxEvaluations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test3047() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxEvaluations((-414));
    int int0 = levenbergMarquardtOptimizer0.getMaxEvaluations();
    assertEquals((-414), int0);
}","/**
 * {@inheritDoc}
 */"
"public int getIterations() {
    return iterations;
}","public void test3148() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.incrementIterationsCounter();
    int int0 = levenbergMarquardtOptimizer0.getIterations();
    assertEquals(1, int0);
}","/**
 * {@inheritDoc}
 */"
"public VectorialConvergenceChecker getConvergenceChecker() {
    return checker;
}","public void test3249() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    VectorialConvergenceChecker vectorialConvergenceChecker0 = gaussNewtonOptimizer0.getConvergenceChecker();
    assertNotNull(vectorialConvergenceChecker0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test3250() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    VectorialConvergenceChecker vectorialConvergenceChecker0 = gaussNewtonOptimizer0.getConvergenceChecker();
    assertEquals(Integer.MAX_VALUE, gaussNewtonOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test3251() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    VectorialConvergenceChecker vectorialConvergenceChecker0 = gaussNewtonOptimizer0.getConvergenceChecker();
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"protected void updateResidualsAndCost() throws FunctionEvaluationException {
    if (++objectiveEvaluations > maxEvaluations) {
        throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations), point);
    }
    objective = function.value(point);
    if (objective.length != rows) {
        throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);
    }
    cost = 0;
    int index = 0;
    for (int i = 0; i < rows; i++) {
        final double residual = targetValues[i] - objective[i];
        residuals[i] = residual;
        cost += residualsWeights[i] * residual * residual;
        index += cols;
    }
    cost = Math.sqrt(cost);
}","public void test3352() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.updateResidualsAndCost();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Update the residuals array and cost function value.
 * @exception FunctionEvaluationException if the function cannot be evaluated
 * or its dimension doesn't match problem dimension or maximal number of
 * of evaluations is exceeded
 */"
"protected void updateJacobian() throws FunctionEvaluationException {
    ++jacobianEvaluations;
    jacobian = jF.value(point);
    if (jacobian.length != rows) {
        throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);
    }
    for (int i = 0; i < rows; i++) {
        final double[] ji = jacobian[i];
        final double factor = -Math.sqrt(residualsWeights[i]);
        for (int j = 0; j < cols; ++j) {
            ji[j] *= factor;
        }
    }
}","public void test3453() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    // Undeclared exception!
    try {
        gaussNewtonOptimizer0.updateJacobian();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Update the jacobian matrix.
 * @exception FunctionEvaluationException if the function jacobian
 * cannot be evaluated or its dimension doesn't match problem dimension
 */"
"protected void incrementIterationsCounter() throws OptimizationException {
    if (++iterations > maxIterations) {
        throw new OptimizationException(new MaxIterationsExceededException(maxIterations));
    }
}","public void test3554() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    gaussNewtonOptimizer0.setMaxIterations(0);
    try {
        gaussNewtonOptimizer0.incrementIterationsCounter();
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // maximal number of iterations (0) exceeded
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Increment the iterations counter by 1.
 * @exception OptimizationException if the maximal number
 * of iterations is exceeded
 */"
"public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < rows; ++k) {
                sum += jacobian[k][i] * jacobian[k][j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        RealMatrix inverse = new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();
        return inverse.getData();
    } catch (InvalidMatrixException ime) {
        throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);
    }
}","public void test3655() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    // Undeclared exception!
    try {
        gaussNewtonOptimizer0.getCovariances();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Get the covariance matrix of optimized parameters.
 * @return covariance matrix
 * @exception FunctionEvaluationException if the function jacobian cannot
 * be evaluated
 * @exception OptimizationException if the covariance matrix
 * cannot be computed (singular problem)
 */"
"public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}","public void test3756() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    double[] doubleArray0 = new double[9];
    levenbergMarquardtOptimizer0.residuals = doubleArray0;
    levenbergMarquardtOptimizer0.rows = 100;
    levenbergMarquardtOptimizer0.residualsWeights = doubleArray0;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.getChiSquare();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 9
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test3857() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    SimpleVectorialValueChecker simpleVectorialValueChecker0 = new SimpleVectorialValueChecker();
    levenbergMarquardtOptimizer0.setConvergenceChecker(simpleVectorialValueChecker0);
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test3858() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    SimpleVectorialValueChecker simpleVectorialValueChecker0 = new SimpleVectorialValueChecker();
    levenbergMarquardtOptimizer0.setConvergenceChecker(simpleVectorialValueChecker0);
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {
    if (rows <= cols) {
        throw new OptimizationException(LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);
    }
    double[] errors = new double[cols];
    final double c = Math.sqrt(getChiSquare() / (rows - cols));
    double[][] covar = getCovariances();
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test3959() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    try {
        levenbergMarquardtOptimizer0.guessParametersErrors();
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // no degrees of freedom (0 measurements, 0 parameters)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Guess the errors in optimized parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @return errors in optimized parameters
 * @exception FunctionEvaluationException if the function jacobian cannot b evaluated
 * @exception OptimizationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException {
    if (rows <= cols) {
        throw new OptimizationException(LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);
    }
    double[] errors = new double[cols];
    final double c = Math.sqrt(getChiSquare() / (rows - cols));
    double[][] covar = getCovariances();
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test4060() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(true);
    gaussNewtonOptimizer0.cols = (-878);
    // Undeclared exception!
    try {
        gaussNewtonOptimizer0.guessParametersErrors();
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Guess the errors in optimized parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @return errors in optimized parameters
 * @exception FunctionEvaluationException if the function jacobian cannot b evaluated
 * @exception OptimizationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}","public void test4161() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.rows = 164;
    // Undeclared exception!
    try {
        levenbergMarquardtOptimizer0.getChiSquare();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */"
"public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (target.length != weights.length) {
        throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);
    }
    // reset counters
    iterations = 0;
    objectiveEvaluations = 0;
    jacobianEvaluations = 0;
    // store least squares problem characteristics
    function = f;
    jF = f.jacobian();
    targetValues = target.clone();
    residualsWeights = weights.clone();
    this.point = startPoint.clone();
    this.residuals = new double[target.length];
    // arrays shared with the other private methods
    rows = target.length;
    cols = point.length;
    jacobian = new double[rows][cols];
    cost = Double.POSITIVE_INFINITY;
    return doOptimize();
}","public void test4262() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.setMaxEvaluations((-2026));
    DifferentiableMultivariateVectorialFunction differentiableMultivariateVectorialFunction0 = mock(DifferentiableMultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((MultivariateMatrixFunction) null).when(differentiableMultivariateVectorialFunction0).jacobian();
    double[] doubleArray0 = new double[8];
    try {
        levenbergMarquardtOptimizer0.optimize(differentiableMultivariateVectorialFunction0, doubleArray0, doubleArray0, doubleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // maximal number of evaluations (-2,026) exceeded
        //
        verifyException(""org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test4363() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.getConvergenceChecker();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test4364() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    levenbergMarquardtOptimizer0.getConvergenceChecker();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test4465() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    int int0 = levenbergMarquardtOptimizer0.getMaxIterations();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test4466() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    int int0 = levenbergMarquardtOptimizer0.getMaxIterations();
    assertEquals(1000, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test4567() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    int int0 = levenbergMarquardtOptimizer0.getIterations();
    assertEquals(1000, levenbergMarquardtOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test4568() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    int int0 = levenbergMarquardtOptimizer0.getIterations();
    assertEquals(Integer.MAX_VALUE, levenbergMarquardtOptimizer0.getMaxEvaluations());
}","/**
 * {@inheritDoc}
 */"
"public int getIterations() {
    return iterations;
}","public void test4569() throws Throwable {
    LevenbergMarquardtOptimizer levenbergMarquardtOptimizer0 = new LevenbergMarquardtOptimizer();
    int int0 = levenbergMarquardtOptimizer0.getIterations();
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public int getMaxIterations() {
    return maxIterations;
}","public void test4670() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    int int0 = gaussNewtonOptimizer0.getMaxEvaluations();
    assertEquals(100, gaussNewtonOptimizer0.getMaxIterations());
}","/**
 * {@inheritDoc}
 */"
"public int getMaxEvaluations() {
    return maxEvaluations;
}","public void test4671() throws Throwable {
    GaussNewtonOptimizer gaussNewtonOptimizer0 = new GaussNewtonOptimizer(false);
    int int0 = gaussNewtonOptimizer0.getMaxEvaluations();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * {@inheritDoc}
 */"
