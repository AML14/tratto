focal_method,test_prefix,docstring
"public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType, double[] startPoint, double[] lower, double[] upper) {
    // Checks.
    final int dim = startPoint.length;
    if (lower != null) {
        if (lower.length != dim) {
            throw new DimensionMismatchException(lower.length, dim);
        }
        for (int i = 0; i < dim; i++) {
            final double v = startPoint[i];
            final double lo = lower[i];
            if (v < lo) {
                throw new NumberIsTooSmallException(v, lo, true);
            }
        }
    }
    if (upper != null) {
        if (upper.length != dim) {
            throw new DimensionMismatchException(upper.length, dim);
        }
        for (int i = 0; i < dim; i++) {
            final double v = startPoint[i];
            final double hi = upper[i];
            if (v > hi) {
                throw new NumberIsTooLargeException(v, hi, true);
            }
        }
    }
    // Initialization.
    if (lower == null) {
        lowerBound = new double[dim];
        for (int i = 0; i < dim; i++) {
            lowerBound[i] = Double.NEGATIVE_INFINITY;
        }
    } else {
        lowerBound = lower.clone();
    }
    if (upper == null) {
        upperBound = new double[dim];
        for (int i = 0; i < dim; i++) {
            upperBound[i] = Double.POSITIVE_INFINITY;
        }
    } else {
        upperBound = upper.clone();
    }
    // Base class method performs the non bound-specific initializations.
    return super.optimize(maxEval, f, goalType, startPoint);
}","public void test000() throws Throwable {
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer();
    double[][] doubleArray0 = new double[1][3];
    double[] doubleArray1 = new double[1];
    UnitSphereRandomVectorGenerator unitSphereRandomVectorGenerator0 = new UnitSphereRandomVectorGenerator(47, cMAESOptimizer0.DEFAULT_RANDOMGENERATOR);
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction0 = new MicrosphereInterpolatingFunction(doubleArray0, doubleArray1, 30000, 0, unitSphereRandomVectorGenerator0);
    GoalType goalType0 = GoalType.MINIMIZE;
    double[] doubleArray2 = new double[1];
    doubleArray2[0] = (double) 47;
    // Undeclared exception!
    try {
        cMAESOptimizer0.optimize((-576), (MultivariateFunction) microsphereInterpolatingFunction0, goalType0, doubleArray1, doubleArray1, doubleArray2);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (-576) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public CMAESOptimizer(int lambda) {
    this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);
}","public void test011() throws Throwable {
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer((-2198));
    assertEquals(0.0, CMAESOptimizer.DEFAULT_STOPFITNESS, 0.01);
}","/**
 * @param lambda Population size.
 */"
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = fitfun.encode(getStartPoint());
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    // -------------------- Generation Loop --------------------------------
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        RealMatrix arz = randn1(dimension, lambda);
        RealMatrix arx = zeros(dimension, lambda);
        double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        RealMatrix xold = xmean;
        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        RealMatrix zmean = bestArz.multiply(weights);
        boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz, xold);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));
        double bestFitness = fitness[arindex[0]];
        double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // handle termination criteria
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        double historyBest = min(fitnessHistory);
        double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","public void test022() throws Throwable {
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer();
    // Undeclared exception!
    try {
        cMAESOptimizer0.doOptimize();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType, double[] startPoint, double[] lower, double[] upper) {
    // Checks.
    final int dim = startPoint.length;
    if (lower != null) {
        if (lower.length != dim) {
            throw new DimensionMismatchException(lower.length, dim);
        }
        for (int i = 0; i < dim; i++) {
            final double v = startPoint[i];
            final double lo = lower[i];
            if (v < lo) {
                throw new NumberIsTooSmallException(v, lo, true);
            }
        }
    }
    if (upper != null) {
        if (upper.length != dim) {
            throw new DimensionMismatchException(upper.length, dim);
        }
        for (int i = 0; i < dim; i++) {
            final double v = startPoint[i];
            final double hi = upper[i];
            if (v > hi) {
                throw new NumberIsTooLargeException(v, hi, true);
            }
        }
    }
    // Initialization.
    if (lower == null) {
        lowerBound = new double[dim];
        for (int i = 0; i < dim; i++) {
            lowerBound[i] = Double.NEGATIVE_INFINITY;
        }
    } else {
        lowerBound = lower.clone();
    }
    if (upper == null) {
        upperBound = new double[dim];
        for (int i = 0; i < dim; i++) {
            upperBound[i] = Double.POSITIVE_INFINITY;
        }
    } else {
        upperBound = upper.clone();
    }
    // Base class method performs the non bound-specific initializations.
    return super.optimize(maxEval, f, goalType, startPoint);
}","public void test033() throws Throwable {
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer();
    cMAESOptimizer0.getEvaluations();
    cMAESOptimizer0.getMaxEvaluations();
    cMAESOptimizer0.getStatisticsMeanHistory();
    cMAESOptimizer0.getStatisticsMeanHistory();
    double[][] doubleArray0 = new double[1][3];
    double[] doubleArray1 = new double[1];
    UnitSphereRandomVectorGenerator unitSphereRandomVectorGenerator0 = new UnitSphereRandomVectorGenerator(47, cMAESOptimizer0.DEFAULT_RANDOMGENERATOR);
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction0 = new MicrosphereInterpolatingFunction(doubleArray0, doubleArray1, 30000, 0, unitSphereRandomVectorGenerator0);
    double[] doubleArray2 = new double[1];
    doubleArray2[0] = (double) 47;
    doubleArray1[0] = (double) 0;
    doubleArray0[0] = doubleArray2;
    UnitSphereRandomVectorGenerator unitSphereRandomVectorGenerator1 = new UnitSphereRandomVectorGenerator(0, cMAESOptimizer0.DEFAULT_RANDOMGENERATOR);
    unitSphereRandomVectorGenerator1.nextVector();
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction1 = new MicrosphereInterpolatingFunction(doubleArray0, doubleArray2, 2628, 0, unitSphereRandomVectorGenerator1);
    GoalType goalType0 = GoalType.MINIMIZE;
    // Undeclared exception!
    cMAESOptimizer0.optimize(2628, (MultivariateFunction) microsphereInterpolatingFunction1, goalType0, doubleArray2, doubleArray1, doubleArray2);
}","/**
 * {@inheritDoc}
 */"
"public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) {
    super(checker);
    this.lambda = lambda;
    this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();
    this.maxIterations = maxIterations;
    this.stopFitness = stopFitness;
    this.isActiveCMA = isActiveCMA;
    this.diagonalOnly = diagonalOnly;
    this.checkFeasableCount = checkFeasableCount;
    this.random = random;
    this.generateStatistics = generateStatistics;
}","public void test044() throws Throwable {
    Well44497a well44497a0 = new Well44497a();
    SimplePointChecker<PointValuePair> simplePointChecker0 = new SimplePointChecker<PointValuePair>(0.0, (-2157.173657120076));
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer((-633066204), (double[]) null, 0, (-633066204), true, (-961), (-633066204), well44497a0, true, simplePointChecker0);
    assertEquals(0.0, CMAESOptimizer.DEFAULT_STOPFITNESS, 0.01);
}","/**
 * @param lambda Population size.
 * @param inputSigma Initial search volume; sigma of offspring objective variables.
 * @param maxIterations Maximal number of iterations.
 * @param stopFitness Whether to stop if objective function value is smaller than
 * {@code stopFitness}.
 * @param isActiveCMA Chooses the covariance matrix update method.
 * @param diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.
 * @param checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.
 * @param random Random generator.
 * @param generateStatistics Whether statistic data is collected.
 * @param checker Convergence checker.
 */"
"public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics, ConvergenceChecker<PointValuePair> checker) {
    super(checker);
    this.lambda = lambda;
    this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();
    this.maxIterations = maxIterations;
    this.stopFitness = stopFitness;
    this.isActiveCMA = isActiveCMA;
    this.diagonalOnly = diagonalOnly;
    this.checkFeasableCount = checkFeasableCount;
    this.random = random;
    this.generateStatistics = generateStatistics;
}","public void test055() throws Throwable {
    double[] doubleArray0 = new double[0];
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer(2, doubleArray0, 2, 2, true, 0, 2, (RandomGenerator) null, true, (ConvergenceChecker<PointValuePair>) null);
    assertEquals(0, CMAESOptimizer.DEFAULT_CHECKFEASABLECOUNT);
}","/**
 * @param lambda Population size.
 * @param inputSigma Initial search volume; sigma of offspring objective variables.
 * @param maxIterations Maximal number of iterations.
 * @param stopFitness Whether to stop if objective function value is smaller than
 * {@code stopFitness}.
 * @param isActiveCMA Chooses the covariance matrix update method.
 * @param diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.
 * @param checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.
 * @param random Random generator.
 * @param generateStatistics Whether statistic data is collected.
 * @param checker Convergence checker.
 */"
"@Deprecated
public CMAESOptimizer(int lambda, double[] inputSigma, int maxIterations, double stopFitness, boolean isActiveCMA, int diagonalOnly, int checkFeasableCount, RandomGenerator random, boolean generateStatistics) {
    this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA, diagonalOnly, checkFeasableCount, random, generateStatistics, new SimpleValueChecker());
}","public void test066() throws Throwable {
    Well19937a well19937a0 = new Well19937a();
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer((-1796), (double[]) null, (-1796), (-1796), false, 0, 62, well19937a0, true);
    assertEquals(0, CMAESOptimizer.DEFAULT_CHECKFEASABLECOUNT);
}","/**
 * @param lambda Population size.
 * @param inputSigma Initial search volume; sigma of offspring objective variables.
 * @param maxIterations Maximal number of iterations.
 * @param stopFitness Whether to stop if objective function value is smaller than
 * {@code stopFitness}.
 * @param isActiveCMA Chooses the covariance matrix update method.
 * @param diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.
 * @param checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.
 * @param random Random generator.
 * @param generateStatistics Whether statistic data is collected.
 * @deprecated See {@link SimpleValueChecker#SimpleValueChecker()}
 */"
"@Override
public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType, double[] startPoint) {
    return optimize(maxEval, f, goalType, startPoint, null, null);
}","public void test077() throws Throwable {
    double[] doubleArray0 = new double[3];
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer();
    double[][] doubleArray1 = new double[3][8];
    doubleArray1[0] = doubleArray0;
    doubleArray1[1] = doubleArray0;
    doubleArray1[2] = doubleArray0;
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction0 = new MicrosphereInterpolatingFunction(doubleArray1, doubleArray0, 0, 0, (UnitSphereRandomVectorGenerator) null);
    GoalType goalType0 = GoalType.MAXIMIZE;
    // Undeclared exception!
    cMAESOptimizer0.optimize(1187, microsphereInterpolatingFunction0, goalType0, doubleArray0);
}","/**
 * {@inheritDoc}
 */"
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = fitfun.encode(getStartPoint());
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    // -------------------- Generation Loop --------------------------------
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        RealMatrix arz = randn1(dimension, lambda);
        RealMatrix arx = zeros(dimension, lambda);
        double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        RealMatrix xold = xmean;
        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        RealMatrix zmean = bestArz.multiply(weights);
        boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz, xold);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));
        double bestFitness = fitness[arindex[0]];
        double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // handle termination criteria
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        double historyBest = min(fitnessHistory);
        double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","public void test088() throws Throwable {
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer((-28));
    double[][] doubleArray0 = new double[1][3];
    double[] doubleArray1 = new double[1];
    doubleArray0[0] = doubleArray1;
    UnitSphereRandomVectorGenerator unitSphereRandomVectorGenerator0 = new UnitSphereRandomVectorGenerator(0, cMAESOptimizer0.DEFAULT_RANDOMGENERATOR);
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction0 = new MicrosphereInterpolatingFunction(doubleArray0, doubleArray1, 2628, 0, unitSphereRandomVectorGenerator0);
    GoalType goalType0 = GoalType.MAXIMIZE;
    PointValuePair pointValuePair0 = cMAESOptimizer0.optimize(2628, (MultivariateFunction) microsphereInterpolatingFunction0, goalType0, doubleArray1, doubleArray1, doubleArray1);
    PointValuePair pointValuePair1 = cMAESOptimizer0.doOptimize();
    assertNotSame(pointValuePair1, pointValuePair0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType, double[] startPoint) {
    return optimize(maxEval, f, goalType, startPoint, null, null);
}","public void test1010() throws Throwable {
    double[] doubleArray0 = new double[3];
    CMAESOptimizer cMAESOptimizer0 = new CMAESOptimizer(1187, doubleArray0);
    double[][] doubleArray1 = new double[3][8];
    doubleArray1[0] = doubleArray0;
    doubleArray1[1] = doubleArray0;
    doubleArray1[2] = doubleArray0;
    MicrosphereInterpolatingFunction microsphereInterpolatingFunction0 = new MicrosphereInterpolatingFunction(doubleArray1, doubleArray0, 0, 0, (UnitSphereRandomVectorGenerator) null);
    GoalType goalType0 = GoalType.MAXIMIZE;
    // Undeclared exception!
    cMAESOptimizer0.optimize(1187, microsphereInterpolatingFunction0, goalType0, doubleArray0);
}","/**
 * {@inheritDoc}
 */"
