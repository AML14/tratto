focal_method,test_prefix,docstring
"public Fraction divide(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw MathRuntimeException.createArithmeticException(""the fraction to divide by must not be zero: {0}/{1}"", fraction.numerator, fraction.denominator);
    }
    return multiply(fraction.reciprocal());
}","public void test000() throws Throwable {
    Fraction fraction0 = new Fraction(0.0);
    // Undeclared exception!
    try {
        fraction0.divide(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // the fraction to divide by must not be zero: 0/1
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test011() throws Throwable {
    Fraction fraction0 = new Fraction(1797.67598);
    Fraction fraction1 = fraction0.divide(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test012() throws Throwable {
    Fraction fraction0 = new Fraction(1797.67598);
    Fraction fraction1 = fraction0.divide(fraction0);
    assertEquals(1.0F, fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test023() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test024() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(fraction1.equals((Object) fraction0));
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test025() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(0.5, fraction1.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test026() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(1, fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test037() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1, 1);
    Fraction fraction1 = fraction0.negate();
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public int getNumerator() {
    return numerator;
}","public void test038() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1, 1);
    Fraction fraction1 = fraction0.negate();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals((-1), fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test039() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1, 1);
    Fraction fraction1 = fraction0.negate();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(1, fraction0.intValue());
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int getNumerator() {
    return numerator;
}","public void test0410() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = Fraction.ZERO;
    Fraction fraction2 = fraction0.subtract(fraction1);
    assertEquals(1, fraction2.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int getNumerator() {
    return numerator;
}","public void test0512() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    Fraction fraction1 = fraction0.reciprocal();
    assertEquals(1, fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test0513() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    Fraction fraction1 = fraction0.reciprocal();
    assertEquals(0.0, fraction1.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test0614() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.reciprocal();
    assertTrue(fraction1.equals((Object) fraction0));
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test0715() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    long long0 = fraction1.longValue();
    assertEquals(0.5, fraction1.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test0716() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    long long0 = fraction1.longValue();
    assertEquals(2, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public long longValue() {
    return (long) doubleValue();
}","public void test0717() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    long long0 = fraction1.longValue();
    assertEquals(0L, long0);
}","/**
 * Gets the fraction as a <tt>long</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public long longValue() {
    return (long) doubleValue();
}","public void test0818() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    long long0 = fraction0.longValue();
    assertEquals((-1L), long0);
}","/**
 * Gets the fraction as a <tt>long</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test0919() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    int int0 = fraction0.intValue();
    assertEquals(1, int0);
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test1020() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    int int0 = fraction0.intValue();
    assertEquals((-1), int0);
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int getNumerator() {
    return numerator;
}","public void test1121() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.getNumerator();
    assertEquals(0, int0);
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int getNumerator() {
    return numerator;
}","public void test1222() throws Throwable {
    Fraction fraction0 = Fraction.TWO;
    Fraction fraction1 = fraction0.negate();
    int int0 = fraction1.getNumerator();
    assertEquals((-2), int0);
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test1223() throws Throwable {
    Fraction fraction0 = Fraction.TWO;
    Fraction fraction1 = fraction0.negate();
    int int0 = fraction1.getNumerator();
    assertEquals((-2.0F), fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test1324() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    int int0 = fraction0.getDenominator();
    assertEquals(1, int0);
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test1425() throws Throwable {
    Fraction fraction0 = new Fraction(0.0, 2079.4, 0);
    float float0 = fraction0.floatValue();
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test1526() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.abs();
    float float0 = fraction1.floatValue();
    assertEquals(1.0F, float0, 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test1527() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.abs();
    float float0 = fraction1.floatValue();
    assertEquals(1, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test1628() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    double double0 = fraction0.doubleValue();
    assertEquals(1.0, double0, 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test1729() throws Throwable {
    Fraction fraction0 = new Fraction(9, (-922));
    double double0 = fraction0.doubleValue();
    assertEquals(922, fraction0.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test1730() throws Throwable {
    Fraction fraction0 = new Fraction(9, (-922));
    double double0 = fraction0.doubleValue();
    assertEquals((-0.009761388286334056), double0, 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test1831() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.TWO.divide(fraction0);
    assertEquals((-2), fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int getNumerator() {
    return numerator;
}","public void test1932() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = fraction0.ZERO.add(fraction0);
    assertEquals(1, fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test1933() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = fraction0.ZERO.add(fraction0);
    assertEquals(Integer.MAX_VALUE, fraction1.intValue());
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test2034() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = fraction0.abs();
    assertEquals(Integer.MAX_VALUE, fraction1.intValue());
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int getNumerator() {
    return numerator;
}","public void test2035() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = fraction0.abs();
    assertEquals(1, fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test2136() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-1073741824), 5);
    Fraction fraction1 = fraction0.abs();
    assertEquals(2.147483648E8, fraction1.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test2137() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-1073741824), 5);
    Fraction fraction1 = fraction0.abs();
    assertEquals((-1073741824), fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test2238() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    // Undeclared exception!
    try {
        fraction0.subtract(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // / by zero
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test2339() throws Throwable {
    Fraction fraction0 = new Fraction((-2147483647), 97);
    // Undeclared exception!
    try {
        fraction0.ONE.subtract(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public Fraction reciprocal() {
    return new Fraction(denominator, numerator);
}","public void test2440() throws Throwable {
    Fraction fraction0 = Fraction.TWO;
    Fraction fraction1 = fraction0.subtract(fraction0);
    // Undeclared exception!
    try {
        fraction1.reciprocal();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero denominator in fraction 1/0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Return the multiplicative inverse of this fraction.
 * @return the reciprocal fraction
 */"
"public Fraction multiply(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = MathUtils.gcd(numerator, fraction.denominator);
    int d2 = MathUtils.gcd(fraction.numerator, denominator);
    return getReducedFraction(MathUtils.mulAndCheck(numerator / d1, fraction.numerator / d2), MathUtils.mulAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test2541() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(613654404, (-3857));
    // Undeclared exception!
    try {
        fraction0.multiply(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction divide(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw MathRuntimeException.createArithmeticException(""the fraction to divide by must not be zero: {0}/{1}"", fraction.numerator, fraction.denominator);
    }
    return multiply(fraction.reciprocal());
}","public void test2642() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    Fraction fraction1 = new Fraction((-2032.329579254536));
    Fraction fraction2 = fraction0.subtract(fraction1);
    Fraction fraction3 = fraction0.ONE.divide(fraction1);
    // Undeclared exception!
    try {
        fraction3.divide(fraction2);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}","public void test2743() throws Throwable {
    Fraction fraction0 = new Fraction((-557.952506913556), (-1473));
    // Undeclared exception!
    try {
        fraction0.compareTo((Fraction) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test2844() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    Fraction fraction1 = Fraction.ONE;
    // Undeclared exception!
    try {
        fraction0.add(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero denominator in fraction 1/0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test2945() throws Throwable {
    Fraction fraction0 = new Fraction(569.819967);
    // Undeclared exception!
    try {
        fraction0.add((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test3046() throws Throwable {
    Fraction fraction0 = new Fraction(2088600, 1);
    Fraction fraction1 = fraction0.reciprocal();
    // Undeclared exception!
    try {
        fraction1.add(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", numerator, denominator);
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", numerator, denominator);
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = MathUtils.gcd(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test3147() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction(1, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero denominator in fraction 1/0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public long longValue() {
    return (long) doubleValue();
}","public void test3248() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.ZERO.multiply(fraction0);
    assertEquals(0L, fraction1.longValue());
}","/**
 * Gets the fraction as a <tt>long</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public Fraction negate() {
    if (numerator == Integer.MIN_VALUE) {
        throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", numerator, denominator);
    }
    return new Fraction(-numerator, denominator);
}","public void test3349() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(Integer.MIN_VALUE, 55);
    // Undeclared exception!
    try {
        fraction0.negate();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -2,147,483,648/55, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Return the additive inverse of this fraction.
 * @return the negation of this fraction.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test3450() throws Throwable {
    Fraction fraction0 = new Fraction((-261), (-261));
    assertEquals(1.0, fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test3451() throws Throwable {
    Fraction fraction0 = new Fraction((-261), (-261));
    assertEquals(1, fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public Fraction(int num, int den) {
    super();
    if (den == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", num, den);
    }
    if (den < 0) {
        if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", num, den);
        }
        num = -num;
        den = -den;
    }
    // reduce numerator and denominator by greatest common denominator.
    int d = MathUtils.gcd(num, den);
    if (d > 1) {
        num /= d;
        den /= d;
    }
    // move sign to numerator.
    if (den < 0) {
        num *= -1;
        den *= -1;
    }
    this.numerator = num;
    this.denominator = den;
}","public void test3552() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction(185, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero denominator in fraction 185/0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a fraction given the numerator and denominator.  The fraction is
 * reduced to lowest terms.
 * @param num the numerator.
 * @param den the denominator.
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test3653() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    int int0 = fraction0.getDenominator();
    assertEquals(Float.POSITIVE_INFINITY, fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test3654() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    int int0 = fraction0.getDenominator();
    assertEquals(0, int0);
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test3755() throws Throwable {
    Fraction fraction0 = new Fraction(0.0);
    double double0 = fraction0.doubleValue();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test3856() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    int int0 = fraction0.getNumerator();
    assertEquals(0, fraction0.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public int getNumerator() {
    return numerator;
}","public void test3857() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN, 37, 37);
    int int0 = fraction0.getNumerator();
    assertEquals(1, int0);
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", numerator, denominator);
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", numerator, denominator);
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = MathUtils.gcd(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test3958() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction(Integer.MIN_VALUE, (-2114));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -2,147,483,648/-2,114, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", numerator, denominator);
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", numerator, denominator);
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = MathUtils.gcd(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test4059() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction((-221), Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -221/-2,147,483,648, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test4160() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-3468), Integer.MIN_VALUE);
    assertEquals(1.6149133443832397E-6, fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test4161() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-3468), Integer.MIN_VALUE);
    assertEquals(536870912, fraction0.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test4262() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2);
    assertEquals(0.0F, fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public Fraction multiply(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = MathUtils.gcd(numerator, fraction.denominator);
    int d2 = MathUtils.gcd(fraction.numerator, denominator);
    return getReducedFraction(MathUtils.mulAndCheck(numerator / d1, fraction.numerator / d2), MathUtils.mulAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test4363() throws Throwable {
    Fraction fraction0 = new Fraction(Double.NaN);
    // Undeclared exception!
    try {
        fraction0.ONE.multiply(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero denominator in fraction 1/0
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction divide(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw MathRuntimeException.createArithmeticException(""the fraction to divide by must not be zero: {0}/{1}"", fraction.numerator, fraction.denominator);
    }
    return multiply(fraction.reciprocal());
}","public void test4464() throws Throwable {
    Fraction fraction0 = Fraction.MINUS_ONE;
    Fraction fraction1 = fraction0.ZERO.abs();
    // Undeclared exception!
    try {
        fraction0.MINUS_ONE.divide(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // the fraction to divide by must not be zero: 0/1
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction divide(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw MathRuntimeException.createArithmeticException(""the fraction to divide by must not be zero: {0}/{1}"", fraction.numerator, fraction.denominator);
    }
    return multiply(fraction.reciprocal());
}","public void test4565() throws Throwable {
    Fraction fraction0 = new Fraction(473.4698288);
    // Undeclared exception!
    try {
        fraction0.ONE.divide((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test4666() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(613654404, (-3857));
    Fraction fraction1 = fraction0.negate();
    Fraction fraction2 = fraction0.add(fraction1);
    Fraction fraction3 = fraction0.multiply(fraction2);
    assertEquals(0.0, fraction2.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test4667() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(613654404, (-3857));
    Fraction fraction1 = fraction0.negate();
    Fraction fraction2 = fraction0.add(fraction1);
    Fraction fraction3 = fraction0.multiply(fraction2);
    assertEquals((-613654404), fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test4668() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(613654404, (-3857));
    Fraction fraction1 = fraction0.negate();
    Fraction fraction2 = fraction0.add(fraction1);
    Fraction fraction3 = fraction0.multiply(fraction2);
    assertEquals(0.0, fraction3.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test4769() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ZERO.divide(fraction0);
    assertEquals(0.0F, fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public Fraction multiply(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = MathUtils.gcd(numerator, fraction.denominator);
    int d2 = MathUtils.gcd(fraction.numerator, denominator);
    return getReducedFraction(MathUtils.mulAndCheck(numerator / d1, fraction.numerator / d2), MathUtils.mulAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test4871() throws Throwable {
    Fraction fraction0 = new Fraction(1.0);
    // Undeclared exception!
    try {
        fraction0.MINUS_ONE.multiply((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test4972() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ONE.multiply(fraction0);
    assertEquals((-2090.0), fraction1.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test5073() throws Throwable {
    Fraction fraction0 = new Fraction((-1994091957), 100);
    Fraction fraction1 = new Fraction((-379.15983));
    // Undeclared exception!
    try {
        fraction0.subtract(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow, numerator too large after multiply: -60,818,648,251
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test5174() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    assertEquals((-2090.0), fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test5175() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = new Fraction((-2089.562449831285));
    Fraction fraction2 = fraction0.MINUS_ONE.add(fraction1);
    Fraction fraction3 = fraction2.add(fraction1);
    assertEquals((-5187535), fraction3.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test5176() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = new Fraction((-2089.562449831285));
    Fraction fraction2 = fraction0.MINUS_ONE.add(fraction1);
    Fraction fraction3 = fraction2.add(fraction1);
    assertEquals((-2090), fraction2.intValue());
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public int getNumerator() {
    return numerator;
}","public void test5277() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ZERO.negate();
    Fraction fraction2 = fraction1.add(fraction0);
    assertEquals((-2090), fraction2.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test5278() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ZERO.negate();
    Fraction fraction2 = fraction1.add(fraction0);
    assertSame(fraction2, fraction0);
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test5279() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ZERO.negate();
    Fraction fraction2 = fraction1.add(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test5380() throws Throwable {
    Fraction fraction0 = new Fraction((-391.221), (-1076));
    // Undeclared exception!
    try {
        fraction0.subtract((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public Fraction abs() {
    Fraction ret;
    if (numerator >= 0) {
        ret = this;
    } else {
        ret = negate();
    }
    return ret;
}","public void test5481() throws Throwable {
    Fraction fraction0 = new Fraction(Integer.MIN_VALUE);
    // Undeclared exception!
    try {
        fraction0.abs();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -2,147,483,648/1, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Returns the absolute value of this fraction.
 * @return the absolute value.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5582() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction1.equals(fraction0);
    assertFalse(fraction0.equals((Object) fraction1));
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test5583() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction1.equals(fraction0);
    assertEquals(0.5F, fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test5584() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction1.equals(fraction0);
    assertEquals(1, fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5585() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.reciprocal();
    boolean boolean0 = fraction1.equals(fraction0);
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5686() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    Fraction fraction1 = fraction0.negate();
    boolean boolean0 = fraction1.equals(fraction0);
    assertTrue(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5787() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1252, (-2444));
    Fraction fraction1 = Fraction.ONE;
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public int getNumerator() {
    return numerator;
}","public void test5788() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1252, (-2444));
    Fraction fraction1 = Fraction.ONE;
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals((-313), fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test5789() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1252, (-2444));
    Fraction fraction1 = Fraction.ONE;
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals((-0.5122749590834698), fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5890() throws Throwable {
    Fraction fraction0 = new Fraction((-1.0));
    boolean boolean0 = fraction0.equals((Object) null);
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test5891() throws Throwable {
    Fraction fraction0 = new Fraction((-1.0));
    boolean boolean0 = fraction0.equals((Object) null);
    assertEquals((-1), fraction0.intValue());
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test5992() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    boolean boolean0 = fraction0.equals(fraction0);
    assertTrue(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test6093() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    boolean boolean0 = fraction0.equals("""");
    assertEquals((-2090.0), fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            // since fractions are always in lowest terms, numerators and
            // denominators can be compared directly for equality.
            Fraction rhs = (Fraction) other;
            ret = (numerator == rhs.numerator) && (denominator == rhs.denominator);
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","public void test6094() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    boolean boolean0 = fraction0.equals("""");
    assertFalse(boolean0);
}","/**
 * Test for the equality of two fractions.  If the lowest term
 * numerator and denominators are the same for both fractions, the two
 * fractions are considered to be equal.
 * @param other fraction to test for equality to this fraction
 * @return true if two fractions are equal, false if object is
 *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal
 *         to this fraction instance.
 */"
"public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}","public void test6195() throws Throwable {
    Fraction fraction0 = Fraction.TWO;
    Fraction fraction1 = Fraction.ZERO;
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(1, int0);
}","/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test6196() throws Throwable {
    Fraction fraction0 = Fraction.TWO;
    Fraction fraction1 = Fraction.ZERO;
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(2.0F, fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}","public void test6297() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.compareTo(fraction0);
    assertEquals(0, int0);
}","/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */"
"public double doubleValue() {
    return (double) numerator / (double) denominator;
}","public void test6298() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.compareTo(fraction0);
    assertEquals(0.0, fraction0.doubleValue(), 0.01);
}","/**
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>double</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test6399() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ONE.abs();
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(1, fraction1.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}","public void test63100() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ONE.abs();
    int int0 = fraction0.compareTo(fraction1);
    assertEquals((-1), int0);
}","/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test63101() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.ONE.abs();
    int int0 = fraction0.compareTo(fraction1);
    assertEquals((-2090.0F), fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public Fraction(int num, int den) {
    super();
    if (den == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", num, den);
    }
    if (den < 0) {
        if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", num, den);
        }
        num = -num;
        den = -den;
    }
    // reduce numerator and denominator by greatest common denominator.
    int d = MathUtils.gcd(num, den);
    if (d > 1) {
        num /= d;
        den /= d;
    }
    // move sign to numerator.
    if (den < 0) {
        num *= -1;
        den *= -1;
    }
    this.numerator = num;
    this.denominator = den;
}","public void test64102() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction((-3468), Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -3,468/-2,147,483,648, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a fraction given the numerator and denominator.  The fraction is
 * reduced to lowest terms.
 * @param num the numerator.
 * @param den the denominator.
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public Fraction(int num, int den) {
    super();
    if (den == 0) {
        throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"", num, den);
    }
    if (den < 0) {
        if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {
            throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"", num, den);
        }
        num = -num;
        den = -den;
    }
    // reduce numerator and denominator by greatest common denominator.
    int d = MathUtils.gcd(num, den);
    if (d > 1) {
        num /= d;
        den /= d;
    }
    // move sign to numerator.
    if (den < 0) {
        num *= -1;
        den *= -1;
    }
    this.numerator = num;
    this.denominator = den;
}","public void test65103() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow in fraction -2,147,483,648/-2,147,483,648, cannot negate
        //
        verifyException(""org.apache.commons.math.MathRuntimeException"", e);
    }
}","/**
 * Create a fraction given the numerator and denominator.  The fraction is
 * reduced to lowest terms.
 * @param num the numerator.
 * @param den the denominator.
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {
    this(value, epsilon, Integer.MAX_VALUE, maxIterations);
}","public void test66104() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction((-24.016514532197593), (-2147483645), (-2147483645));
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // Unable to convert -24.017 to fraction after -2,147,483,645 iterations
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * Create a fraction given the double value and maximum error allowed.
 * <p>
 * References:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">
 * Continued Fraction</a> equations (11) and (22)-(26)</li>
 * </ul>
 * </p>
 * @param value the double value to convert to a fraction.
 * @param epsilon maximum error allowed.  The resulting fraction is within
 *        <code>epsilon</code> of <code>value</code>, in absolute terms.
 * @param maxIterations maximum number of convergents
 * @throws FractionConversionException if the continued fraction failed to
 *         converge.
 */"
"public Fraction(double value, int maxDenominator) throws FractionConversionException {
    this(value, 0, maxDenominator, 100);
}","public void test67105() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction(0.0, 37);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // Overflow trying to convert 0 to fraction (1/9,223,372,036,854,775,807)
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * Create a fraction given the double value and maximum denominator.
 * <p>
 * References:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">
 * Continued Fraction</a> equations (11) and (22)-(26)</li>
 * </ul>
 * </p>
 * @param value the double value to convert to a fraction.
 * @param maxDenominator The maximum allowed value for denominator
 * @throws FractionConversionException if the continued fraction failed to
 *         converge
 */"
"public Fraction(double value, double epsilon, int maxIterations) throws FractionConversionException {
    this(value, epsilon, Integer.MAX_VALUE, maxIterations);
}","public void test68106() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction(37, 0, 0);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // Overflow trying to convert 37 to fraction (9,223,372,036,854,775,772/9,223,372,036,854,775,807)
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * Create a fraction given the double value and maximum error allowed.
 * <p>
 * References:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">
 * Continued Fraction</a> equations (11) and (22)-(26)</li>
 * </ul>
 * </p>
 * @param value the double value to convert to a fraction.
 * @param epsilon maximum error allowed.  The resulting fraction is within
 *        <code>epsilon</code> of <code>value</code>, in absolute terms.
 * @param maxIterations maximum number of convergents
 * @throws FractionConversionException if the continued fraction failed to
 *         converge.
 */"
"public Fraction(double value) throws FractionConversionException {
    this(value, 1.0e-5, 100);
}","public void test69107() throws Throwable {
    Fraction fraction0 = null;
    try {
        fraction0 = new Fraction(Double.POSITIVE_INFINITY);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // Overflow trying to convert \u221E to fraction (9,223,372,036,854,775,807/1)
        //
        verifyException(""org.apache.commons.math.fraction.Fraction"", e);
    }
}","/**
 * Create a fraction given the double value.
 * @param value the double value to convert to a fraction.
 * @throws FractionConversionException if the continued fraction failed to
 *         converge.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test70108() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.intValue();
    assertEquals(0.0F, fraction0.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int intValue() {
    return (int) doubleValue();
}","public void test70109() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.intValue();
    assertEquals(0, int0);
}","/**
 * Gets the fraction as an <tt>int</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test71110() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    float float0 = fraction0.floatValue();
    assertEquals((-2090.0F), float0, 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test72111() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.MINUS_ONE.subtract(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public int getDenominator() {
    return denominator;
}","public void test72112() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.MINUS_ONE.subtract(fraction0);
    assertEquals(1, fraction0.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test72113() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    Fraction fraction1 = fraction0.MINUS_ONE.subtract(fraction0);
    assertEquals(2089.0F, fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getNumerator() {
    return numerator;
}","public void test73114() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    fraction0.hashCode();
    assertEquals((-2090), fraction0.getNumerator());
}","/**
 * Access the numerator.
 * @return the numerator.
 */"
"public int getDenominator() {
    return denominator;
}","public void test73115() throws Throwable {
    Fraction fraction0 = new Fraction((-2089.562449831285), 1);
    fraction0.hashCode();
    assertEquals(1, fraction0.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public float floatValue() {
    return (float) doubleValue();
}","public void test74116() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.add(fraction0);
    assertEquals(3.0F, fraction1.floatValue(), 0.01F);
}","/**
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * @return the fraction as a <tt>float</tt>
 */"
"public int getDenominator() {
    return denominator;
}","public void test74117() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.TWO.add(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * Access the denominator.
 * @return the denominator.
 */"
"public long longValue() {
    return (long) doubleValue();
}","public void test75118() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    long long0 = fraction0.longValue();
    assertEquals(1L, long0);
}","/**
 * Gets the fraction as a <tt>long</tt>. This returns the whole number part
 * of the fraction.
 * @return the whole number fraction part
 */"
