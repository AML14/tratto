focal_method,test_prefix,docstring
"public OpenMapRealVector(double[] values) {
    this(values, DEFAULT_ZERO_TOLERANCE);
}","public void test000() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertNotNull(openMapRealVector0);
}","/**
 * Create from a double array.
 * Only non-zero entries will be stored
 * @param values The set of values to create from
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test004() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test005() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertEquals(1.0E-12, openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test006() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertEquals(2, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealMatrix outerproduct(OpenMapRealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    OpenMapRealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        Iterator iter2 = v.getEntries().iterator();
        while (iter2.hasNext()) {
            iter2.advance();
            res.setEntry(iter.key(), iter2.key(), iter.value() * iter2.value());
        }
    }
    return res;
}","public void test007() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertNotNull(openMapRealMatrix0);
}","/**
 * Optimized method to compute the outer product.
 * @param v The vector to comput the outer product on
 * @return The outer product of <code>this</code> and <code>v</code>
 * @throws IllegalArgumentException If the dimensions don't match
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0011() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test0012() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(1.0E-12, openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test0013() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(2, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return rows;
}","public void test0014() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(2, openMapRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return columns;
}","public void test0015() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(2, openMapRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test0016() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0020() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test0021() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(1.0E-12, openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test0022() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(2, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return rows;
}","public void test0023() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(2, openMapRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return columns;
}","public void test0024() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(2, openMapRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test0025() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return eigenvectors[i].copy();
}","public void test0026() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 0.333;
    doubleArray0[1] = 1.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.333);
    try {
        eigenDecompositionImpl0.getEigenvector(15);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 15
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test0128() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test0135() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    assertEquals(Double.NaN, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        if (eigenvectors == null) {
            findEigenVectors();
        }
        final int m = eigenvectors.length;
        cachedV = MatrixUtils.createRealMatrix(m, m);
        for (int k = 0; k < m; ++k) {
            cachedV.setColumnVector(k, eigenvectors[k]);
        }
    }
    // return the cached matrix
    return cachedV;
}","public void test0136() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    RealMatrix realMatrix0 = eigenDecompositionImpl0.getV();
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test0143() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    RealMatrix realMatrix0 = eigenDecompositionImpl0.getV();
    assertEquals(Double.NaN, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"int getRowDimension();","public void test0144() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    RealMatrix realMatrix0 = eigenDecompositionImpl0.getV();
    assertEquals(5, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test0145() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    RealMatrix realMatrix0 = eigenDecompositionImpl0.getV();
    assertEquals(5, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test0248() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public int getDimension() {
    return data.length;
}","public void test0250() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0251() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0252() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0253() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0254() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test0255() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test0256() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test0257() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public int getDimension() {
    return data.length;
}","public void test0259() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0260() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0261() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0262() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0263() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test0264() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test0265() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0266() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test0267() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(2665.15341351, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0268() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0269() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(2530.9224576627626, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0270() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(4.239921250304E10, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test0271() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test0272() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test0273() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public int getDimension() {
    return data.length;
}","public void test0275() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0276() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0277() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0278() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0279() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test0280() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test0281() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0282() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test0283() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(2665.15341351, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0284() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0285() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(2530.9224576627626, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0286() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(4.239921250304E10, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test0287() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test0288() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test0291() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test0292() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test0293() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public int getDimension() {
    return data.length;
}","public void test0295() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test0296() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test0297() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test0298() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test0299() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test02100() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test02101() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test02102() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test02103() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(2665.15341351, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test02104() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test02105() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(2530.9224576627626, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test02106() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(4.239921250304E10, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test02107() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test02108() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test02109() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[1] = 0.563;
    doubleArray0[3] = 137.40041351;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test03110() throws Throwable {
    double[] doubleArray0 = new double[0];
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray0, 0.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test04111() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04114() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04115() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04116() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04117() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04118() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04119() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test04120() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04122() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04124() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04125() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04126() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04127() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04128() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04129() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04130() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(5051.73, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04131() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(5051.73, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04132() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04133() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(40413.84, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04134() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04135() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test04136() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04138() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04139() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04141() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04142() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04143() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04144() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04145() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04146() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04147() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(5051.73, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04148() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(5051.73, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04149() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04150() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(40413.84, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04151() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04152() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test04153() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test04154() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test04157() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04159() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04160() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04162() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04163() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04164() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04165() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04166() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04167() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04168() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(5051.73, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04169() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(5051.73, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04170() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04171() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(40413.84, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04172() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04173() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test04174() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test04175() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test04176() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test04177() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(2.5519975992899995E7, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04179() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test04180() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04182() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04183() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04184() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04185() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04186() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04187() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test04188() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(5051.73, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test04189() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(5051.73, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test04190() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test04191() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(40413.84, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test04192() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test04193() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test04194() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test04195() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test04196() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test05200() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-244.0);
    doubleArray0[1] = (-244.0);
    doubleArray0[2] = 1602954.1504873172;
    doubleArray0[3] = (-7.34662659124574E-10);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    doubleArray1[3] = (-7.34662659124574E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test05207() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-244.0);
    doubleArray0[1] = (-244.0);
    doubleArray0[2] = 1602954.1504873172;
    doubleArray0[3] = (-7.34662659124574E-10);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    doubleArray1[3] = (-7.34662659124574E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertEquals(7.840365373841919E-12, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test05208() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-244.0);
    doubleArray0[1] = (-244.0);
    doubleArray0[2] = 1602954.1504873172;
    doubleArray0[3] = (-7.34662659124574E-10);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    doubleArray1[3] = (-7.34662659124574E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(7.840365373841919E-12, double0, 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test05215() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (-244.0);
    doubleArray0[1] = (-244.0);
    doubleArray0[2] = 1602954.1504873172;
    doubleArray0[3] = (-7.34662659124574E-10);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 2.2250738585072014E-308;
    doubleArray1[3] = (-7.34662659124574E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(7.840365373841919E-12, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public OpenMapRealVector(double[] values, double epsilon) {
    virtualSize = values.length;
    entries = new OpenIntToDoubleHashMap(0.0);
    this.epsilon = epsilon;
    for (int key = 0; key < values.length; key++) {
        double value = values[key];
        if (!isZero(value)) {
            entries.put(key, value);
        }
    }
}","public void test06218() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    assertNotNull(openMapRealVector0);
}","/**
 * Create from a double array, specifying zero tolerance.
 * Only non-zero entries will be stored
 * @param values The set of values to create from
 * @param epsilon The tolerance for having a value considered zero
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test06222() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    assertEquals((-1124.0), openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test06223() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    assertEquals(4, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test06224() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"public OpenMapRealMatrix outerproduct(OpenMapRealVector v) throws IllegalArgumentException {
    checkVectorDimensions(v.getDimension());
    OpenMapRealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        Iterator iter2 = v.getEntries().iterator();
        while (iter2.hasNext()) {
            iter2.advance();
            res.setEntry(iter.key(), iter2.key(), iter.value() * iter2.value());
        }
    }
    return res;
}","public void test06225() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertNotNull(openMapRealMatrix0);
}","/**
 * Optimized method to compute the outer product.
 * @param v The vector to comput the outer product on
 * @return The outer product of <code>this</code> and <code>v</code>
 * @throws IllegalArgumentException If the dimensions don't match
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test06229() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals((-1124.0), openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test06230() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(4, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test06231() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public int getColumnDimension() {
    return columns;
}","public void test06232() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(4, openMapRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return rows;
}","public void test06233() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    assertEquals(4, openMapRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test06234() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test06238() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals((-1124.0), openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test06239() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals(4, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test06240() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public int getColumnDimension() {
    return columns;
}","public void test06241() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals(4, openMapRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return rows;
}","public void test06242() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals(4, openMapRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test06243() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    assertEquals((-1.1398480496731867E-8), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test06244() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals((-1.1398480496731867E-8), double0, 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getEpsilon() {
    return epsilon;
}","public void test06248() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals((-1124.0), openMapRealVector0.getEpsilon(), 0.01);
}","/**
 * Get the tolerance for having a value considered zero.
 * @return The test range for testing if a value is zero
 */"
"public int getDimension() {
    return virtualSize;
}","public void test06249() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(4, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparcity() {
    return (double) entries.size() / (double) getDimension();
}","public void test06250() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(1.0, openMapRealVector0.getSparcity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 */"
"@Override
public int getColumnDimension() {
    return columns;
}","public void test06251() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(4, openMapRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return rows;
}","public void test06252() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(4, openMapRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test06253() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 636.63454613219;
    doubleArray0[2] = (-900.97647);
    doubleArray0[3] = (-1124.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1124.0));
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 689.1547033442881);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals((-1.1398480496731867E-8), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test07254() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07256() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07257() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07258() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07259() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07260() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07261() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test07262() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test07263() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07265() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07266() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07267() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07268() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07269() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07270() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07271() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07272() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07273() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07274() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07275() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07276() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test07277() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test07278() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test07279() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07281() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07282() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07283() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07284() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07285() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07286() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07287() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07288() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07289() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07290() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07291() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07292() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"int getRowDimension();","public void test07293() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test07294() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(25, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test07297() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test07298() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test07299() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07301() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07302() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07303() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07304() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07305() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07306() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test07307() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test07308() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test07309() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test07310() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test07311() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test07312() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"int getRowDimension();","public void test07313() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test07314() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(25, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test07315() throws Throwable {
    double[] doubleArray0 = new double[25];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test08316() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08319() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08320() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08321() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08322() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08323() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08324() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test08325() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test08327() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08329() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08330() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08331() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08332() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08333() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08334() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08335() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08336() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08337() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08338() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08339() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08340() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test08341() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test08343() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test08344() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08346() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08347() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08348() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08349() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08350() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08351() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08352() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08353() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08354() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08355() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08356() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08357() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test08358() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test08359() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test08362() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test08364() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test08365() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08367() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08368() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08369() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08370() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08371() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08372() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test08373() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test08374() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test08375() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test08376() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test08377() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test08378() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test08379() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test08380() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test08381() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test08382() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    try {
        eigenDecompositionImpl0.getRealEigenvalue((-1979));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1979
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public Array2DRowRealMatrix(final double[][] d, final boolean copyArray) throws IllegalArgumentException, NullPointerException {
    if (copyArray) {
        copyIn(d);
    } else {
        if (d == null) {
            throw new NullPointerException();
        }
        final int nRows = d.length;
        if (nRows == 0) {
            throw MathRuntimeException.createIllegalArgumentException(""matrix must have at least one row"");
        }
        final int nCols = d[0].length;
        if (nCols == 0) {
            throw MathRuntimeException.createIllegalArgumentException(""matrix must have at least one column"");
        }
        for (int r = 1; r < nRows; r++) {
            if (d[r].length != nCols) {
                throw MathRuntimeException.createIllegalArgumentException(""some rows have length {0} while others have length {1}"", nCols, d[r].length);
            }
        }
        data = d;
    }
}","public void test09383() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Create a new RealMatrix using the input array as the underlying
 * data array.
 * <p>If an array is built specially in order to be embedded in a
 * RealMatrix and not used directly, the <code>copyArray</code> may be
 * set to <code>false</code. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</p>
 * @param d data for new matrix
 * @param copyArray if true, the input array will be copied, otherwise
 * it will be referenced
 * @throws IllegalArgumentException if <code>d</code> is not rectangular
 *  (not all rows have the same length) or empty
 * @throws NullPointerException if <code>d</code> is null
 * @see #Array2DRowRealMatrix(double[][])
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test09385() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test09386() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    assertEquals(1, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test09387() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.5);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test09389() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.5);
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test09390() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.5);
    assertEquals(1, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test09391() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.5);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getImagEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return imagEigenvalues[i];
}","public void test09392() throws Throwable {
    double[][] doubleArray0 = new double[1][1];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0, false);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.5);
    try {
        eigenDecompositionImpl0.getImagEigenvalue((-829));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -829
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test11455() throws Throwable {
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl((double[]) null, (double[]) null, 1294.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public Array2DRowRealMatrix(final double[] v) {
    final int nRows = v.length;
    data = new double[nRows][1];
    for (int row = 0; row < nRows; row++) {
        data[row][0] = v[row];
    }
}","public void test12456() throws Throwable {
    double[] doubleArray0 = new double[5];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Create a new (column) RealMatrix using <code>v</code> as the
 * data for the unique column of the <code>v.length x 1</code> matrix
 * created.
 * <p>The input array is copied, not referenced.</p>
 *
 * @param v column vector holding data for new matrix
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test12459() throws Throwable {
    double[] doubleArray0 = new double[5];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertEquals(5, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test12460() throws Throwable {
    double[] doubleArray0 = new double[5];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test12461() throws Throwable {
    double[] doubleArray0 = new double[5];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 0.0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // a 5x1 matrix was provided instead of a square matrix
        //
        verifyException(""org.apache.commons.math.linear.TriDiagonalTransformer"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) throws IllegalArgumentException {
    super(rowDimension, columnDimension);
    data = new double[rowDimension][columnDimension];
}","public void test13462() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Create a new RealMatrix with the supplied row and column dimensions.
 *
 * @param rowDimension  the number of rows in the new matrix
 * @param columnDimension  the number of columns in the new matrix
 * @throws IllegalArgumentException if row or column dimension is not
 *  positive
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test13463() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    assertEquals(3991, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test13464() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    assertEquals(3991, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix getRowMatrix(final int row) throws MatrixIndexException {
    MatrixUtils.checkRowIndex(this, row);
    final int nCols = getColumnDimension();
    final RealMatrix out = createMatrix(1, nCols);
    for (int i = 0; i < nCols; ++i) {
        out.setEntry(0, i, getEntry(row, i));
    }
    return out;
}","public void test13465() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test13467() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    assertEquals(3991, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test13468() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    assertEquals(3991, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test13469() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    assertEquals(1, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test13470() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    assertEquals(3991, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test13473() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(3991, 3991);
    RealMatrix realMatrix0 = array2DRowRealMatrix0.getRowMatrix(0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 3991);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // no entry at indices (1, 0) in a 1x3,991 matrix
        //
        verifyException(""org.apache.commons.math.linear.Array2DRowRealMatrix"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test14474() throws Throwable {
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl((RealMatrix) null, 2028.36210992623);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public Array2DRowRealMatrix() {
}","public void test15475() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Creates a matrix with no data
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test15476() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    assertEquals(0, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test15477() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    assertEquals(0, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test15478() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix();
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-603.0));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.linear.TriDiagonalTransformer"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public Array2DRowRealMatrix(final double[] v) {
    final int nRows = v.length;
    data = new double[nRows][1];
    for (int row = 0; row < nRows; row++) {
        data[row][0] = v[row];
    }
}","public void test16479() throws Throwable {
    double[] doubleArray0 = new double[0];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Create a new (column) RealMatrix using <code>v</code> as the
 * data for the unique column of the <code>v.length x 1</code> matrix
 * created.
 * <p>The input array is copied, not referenced.</p>
 *
 * @param v column vector holding data for new matrix
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test16482() throws Throwable {
    double[] doubleArray0 = new double[0];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertEquals(0, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test16483() throws Throwable {
    double[] doubleArray0 = new double[0];
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 2.0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test17485() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test17492() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public DecompositionSolver getSolver() {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);
}","public void test17493() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    DecompositionSolver decompositionSolver0 = eigenDecompositionImpl0.getSolver();
    assertNotNull(decompositionSolver0);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test17500() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    DecompositionSolver decompositionSolver0 = eigenDecompositionImpl0.getSolver();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"boolean isNonSingular();","public void test17501() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    DecompositionSolver decompositionSolver0 = eigenDecompositionImpl0.getSolver();
    assertFalse(decompositionSolver0.isNonSingular());
}","/**
 * Check if the decomposed matrix is non-singular.
 * @return true if the decomposed matrix is non-singular
 */"
"public Array2DRowRealMatrix(final double[] v) {
    final int nRows = v.length;
    data = new double[nRows][1];
    for (int row = 0; row < nRows; row++) {
        data[row][0] = v[row];
    }
}","public void test18504() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertNotNull(array2DRowRealMatrix0);
}","/**
 * Create a new (column) RealMatrix using <code>v</code> as the
 * data for the unique column of the <code>v.length x 1</code> matrix
 * created.
 * <p>The input array is copied, not referenced.</p>
 *
 * @param v column vector holding data for new matrix
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test18507() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertEquals(1, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test18508() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test18509() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test18512() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    assertEquals(1, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test18513() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test18514() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    assertEquals(2219.6592927939664, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealVector getEigenvector(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    if (eigenvectors == null) {
        findEigenVectors();
    }
    return eigenvectors[i].copy();
}","public void test18515() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertNotNull(realVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getRowDimension() {
    return (data == null) ? 0 : data.length;
}","public void test18518() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1, array2DRowRealMatrix0.getRowDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public int getColumnDimension() {
    return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
}","public void test18519() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1, array2DRowRealMatrix0.getColumnDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test18520() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(2219.6592927939664, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"double getNorm();","public void test18521() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1.0, realVector0.getNorm(), 0.01);
}","/**
 * Returns the L<sub>2</sub> norm of the vector.
 * <p>The L<sub>2</sub> norm is the root of the sum of
 * the squared elements.</p>
 * @return norm
 * @see #getL1Norm()
 * @see #getLInfNorm()
 * @see #getDistance(RealVector)
 */"
"boolean isInfinite();","public void test18522() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertFalse(realVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"boolean isNaN();","public void test18523() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertFalse(realVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"int getDimension();","public void test18524() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1, realVector0.getDimension());
}","/**
 * Returns the size of the vector.
 * @return size
 */"
"double getLInfNorm();","public void test18525() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1.0, realVector0.getLInfNorm(), 0.01);
}","/**
 * Returns the L<sub>&infin;</sub> norm of the vector.
 * <p>The L<sub>&infin;</sub> norm is the max of the absolute
 * values of elements.</p>
 * @return norm
 * @see #getNorm()
 * @see #getL1Norm()
 * @see #getLInfDistance(RealVector)
 */"
"double getL1Norm();","public void test18526() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2219.6592927939664;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, (-197.0));
    RealVector realVector0 = eigenDecompositionImpl0.getEigenvector(0);
    assertEquals(1.0, realVector0.getL1Norm(), 0.01);
}","/**
 * Returns the L<sub>1</sub> norm of the vector.
 * <p>The L<sub>1</sub> norm is the sum of the absolute
 * values of elements.</p>
 * @return norm
 * @see #getNorm()
 * @see #getLInfNorm()
 * @see #getL1Distance(RealVector)
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test19528() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[2] = 1602954.1504873172;
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = (-244.0);
    doubleArray1[1] = (-244.0);
    doubleArray1[2] = (-7.3466E-10);
    doubleArray1[3] = (-7.3466E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test19535() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[2] = 1602954.1504873172;
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = (-244.0);
    doubleArray1[1] = (-244.0);
    doubleArray1[2] = (-7.3466E-10);
    doubleArray1[3] = (-7.3466E-10);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
    assertEquals(5.1507661571531585E-8, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(int size) {
    data = new double[size];
}","public void test20536() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a (size)-length vector of zeros.
 * @param size size of the vector
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20537() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20538() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20539() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test20540() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20541() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20542() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test20543() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test20545() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20547() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20548() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20549() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test20550() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20551() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20552() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20553() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test20554() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20555() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20556() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(5929.085455134931, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20557() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(3401.329942533145, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20558() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(18296.63112915865, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test20559() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test20561() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test20562() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20564() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20565() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20566() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test20567() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20568() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20569() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20570() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test20571() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20572() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20573() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(5929.085455134931, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20574() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(3401.329942533145, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20575() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(18296.63112915865, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test20576() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test20577() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test20580() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test20582() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test20583() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20585() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20586() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20587() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test20588() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20589() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20590() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test20591() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test20592() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test20593() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test20594() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(5929.085455134931, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test20595() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(3401.329942533145, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test20596() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(18296.63112915865, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test20597() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test20598() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test20599() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = 2012.2780641248314;
    doubleArray0[0] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test21600() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21603() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21604() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21605() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test21606() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21607() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21608() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test21609() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test21611() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21613() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21614() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21615() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test21616() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21617() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21618() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21619() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21620() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6279.048308431346, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test21621() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21622() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21623() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21624() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(11495.7273910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test21625() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test21627() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test21628() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21630() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21631() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21632() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test21633() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21634() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21635() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21636() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21637() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6279.048308431346, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test21638() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21639() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21640() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21641() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(11495.7273910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test21642() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test21643() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test21646() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test21648() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test21649() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21651() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21652() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21653() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test21654() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21655() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21656() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test21657() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test21658() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6279.048308431346, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test21659() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test21660() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test21661() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test21662() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(11495.7273910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getRowDimension();","public void test21663() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getColumnDimension();","public void test21664() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test21665() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(1.80800278215138E-39, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test22666() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22669() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22670() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22671() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22672() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22673() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22674() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test22675() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test22677() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22679() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22680() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22681() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22682() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22683() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22684() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22685() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22686() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6288.237712536678, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22687() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(11520.554954931531, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22688() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22689() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22690() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test22691() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test22693() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test22694() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22696() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22697() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22698() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22699() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22700() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22701() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22702() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22703() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6288.237712536678, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22704() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(11520.554954931531, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22705() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22706() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22707() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test22708() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test22709() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test22712() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test22714() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test22715() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22717() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22718() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22719() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22720() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22721() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22722() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test22723() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test22724() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6288.237712536678, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test22725() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(11520.554954931531, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test22726() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test22727() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test22728() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test22729() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test22730() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test22731() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals((-2.023388392116581E-41), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws InvalidMatrixException {
    this.main = main.clone();
    this.secondary = secondary.clone();
    transformer = null;
    // pre-compute some elements
    squaredSecondary = new double[secondary.length];
    for (int i = 0; i < squaredSecondary.length; ++i) {
        final double s = secondary[i];
        squaredSecondary[i] = s * s;
    }
    this.splitTolerance = splitTolerance;
    decompose();
}","public void test23733() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[1] = (-740.078604);
    doubleArray0[2] = 1602954.1504873172;
    doubleArray0[3] = (-7.34662659124574E-10);
    doubleArray0[4] = 2.2250738585072014E-308;
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, (-1.0));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        //
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.
 * @param main the main diagonal of the matrix (will be copied)
 * @param secondary the secondary diagonal of the matrix (will be copied)
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test24734() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24737() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24738() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24739() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24740() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24741() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test24742() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test24743() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test24745() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24747() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24748() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24749() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24750() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24751() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test24752() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24753() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(5843.458740639993, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24754() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(9189.980154844014, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24755() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(80905.16134965987, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24756() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test24757() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24758() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test24759() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test24761() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test24762() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24764() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24765() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24766() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24767() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24768() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test24769() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24770() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(5843.458740639993, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24771() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(9189.980154844014, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24772() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(80905.16134965987, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24773() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test24774() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24775() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"int getColumnDimension();","public void test24776() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test24777() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test24780() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test24782() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test24783() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24785() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24786() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24787() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24788() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24789() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test24790() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test24791() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(5843.458740639993, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test24792() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(9189.980154844014, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test24793() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(80905.16134965987, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test24794() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public int getDimension() {
    return data.length;
}","public void test24795() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test24796() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"int getColumnDimension();","public void test24797() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test24798() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test24799() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5058.765168707483);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = 0.563;
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals((-4.165635853403461E-45), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public ArrayRealVector(double[] d, int pos, int size) {
    if (d.length < pos + size) {
        throw MathRuntimeException.createIllegalArgumentException(""position {0} and size {1} don't fit to the size of the input array {2}"", pos, size, d.length);
    }
    data = new double[size];
    System.arraycopy(d, pos, data, 0, size);
}","public void test25800() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertNotNull(arrayRealVector0);
}","/**
 * Construct a vector from part of a array.
 * @param d array of doubles.
 * @param pos position of first entry
 * @param size number of entries to copy
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25803() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25804() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25805() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25806() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25807() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25808() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public ArrayRealVector(ArrayRealVector v1, double[] v2) {
    data = new double[v1.data.length + v2.length];
    System.arraycopy(v1.data, 0, data, 0, v1.data.length);
    System.arraycopy(v2, 0, data, v1.data.length, v2.length);
}","public void test25809() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertNotNull(arrayRealVector1);
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 first vector (will be put in front of the new vector)
 * @param v2 second vector (will be put at back of the new vector)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test25811() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25813() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25814() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25815() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25816() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25817() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25818() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25819() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25820() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25821() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25822() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25823() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(3729.13819356625, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25824() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    assertEquals(6443.9973910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
    checkVectorDimensions(v.length);
    final int m = data.length;
    final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
    for (int i = 0; i < data.length; i++) {
        for (int j = 0; j < data.length; j++) {
            out.setEntry(i, j, data[i] * v[j]);
        }
    }
    return out;
}","public void test25825() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertNotNull(realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test25827() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test25828() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25830() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25831() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25832() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25833() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25834() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25835() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25836() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25837() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25838() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25839() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25840() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(3729.13819356625, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25841() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6443.9973910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test25842() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test25843() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test25846() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertNotNull(eigenDecompositionImpl0);
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test25848() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.equals((Object) arrayRealVector1));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other == null) {
        return false;
    }
    try {
        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    } catch (ClassCastException ex) {
        // ignore exception
        return false;
    }
}","public void test25849() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.equals((Object) arrayRealVector0));
}","/**
 * Test for the equality of two real vectors.
 * <p>
 * If all coordinates of two real vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two real vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * real vector are equal to <code>Double.NaN</code>, the real vector is equal to
 * a vector with all <code>Double.NaN</code> coordinates.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false if
 *         object is null, not an instance of RealVector, or
 *         not equal to this RealVector instance
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25851() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25852() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25853() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25854() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0, arrayRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25855() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector0.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25856() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, arrayRealVector0.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return data.length;
}","public void test25857() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, arrayRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    if (isNaN()) {
        return false;
    }
    for (double v : data) {
        if (Double.isInfinite(v)) {
            return true;
        }
    }
    return false;
}","public void test25858() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isInfinite());
}","/**
 * Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 * @return  true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise
 */"
"public boolean isNaN() {
    for (double v : data) {
        if (Double.isNaN(v)) {
            return true;
        }
    }
    return false;
}","public void test25859() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertFalse(arrayRealVector1.isNaN());
}","/**
 * Returns true if any coordinate of this vector is NaN; false otherwise
 * @return  true if any coordinate of this vector is NaN; false otherwise
 */"
"public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","public void test25860() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(80870.08, arrayRealVector1.getLInfNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","public void test25861() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(3729.13819356625, arrayRealVector1.getNorm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","public void test25862() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6443.9973910101, arrayRealVector1.getL1Norm(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"int getColumnDimension();","public void test25863() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"int getRowDimension();","public void test25864() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(6, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test25865() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[2] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test26866() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 0.563;
    doubleArray0[4] = 0.563;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test27867() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = (-3888.38364524087);
    doubleArray0[4] = (-2338.1729687950015);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals((-2.467857120364707E-37), eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test28868() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    assertEquals(-0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test29869() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    doubleArray1[1] = (-244.0);
    doubleArray1[2] = 2.2250738585072014E-308;
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test30870() throws Throwable {
    double[] doubleArray0 = new double[25];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    doubleArray0[3] = 137.40041351;
    doubleArray0[4] = (-2313.34540487357);
    doubleArray0[5] = 1466.0615726265294;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.563);
    assertEquals(-0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test31871() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 2527.19;
    doubleArray0[2] = (-5051.73);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // cannot solve degree 3 equation
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test32872() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(15);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.5);
    eigenDecompositionImpl0.getV();
    eigenDecompositionImpl0.getSolver();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test33873() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = new double[4];
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(doubleArray0, doubleArray1, 2.2250738585072014E-308);
    double double0 = eigenDecompositionImpl0.getDeterminant();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test34874() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(15);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.5);
    eigenDecompositionImpl0.getV();
    eigenDecompositionImpl0.getEigenvector(9);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test35875() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    eigenDecompositionImpl0.getV();
    RealMatrix realMatrix1 = eigenDecompositionImpl0.getVT();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealMatrix getVT() throws InvalidMatrixException {
    if (cachedVt == null) {
        if (eigenvectors == null) {
            findEigenVectors();
        }
        final int m = eigenvectors.length;
        cachedVt = MatrixUtils.createRealMatrix(m, m);
        for (int k = 0; k < m; ++k) {
            cachedVt.setRowVector(k, eigenvectors[k]);
        }
    }
    // return the cached matrix
    return cachedVt;
}","public void test36877() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(15);
    OpenMapRealMatrix openMapRealMatrix0 = openMapRealVector0.outerproduct(openMapRealVector0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(openMapRealMatrix0, 0.5);
    RealMatrix realMatrix0 = eigenDecompositionImpl0.getVT();
    RealMatrix realMatrix1 = eigenDecompositionImpl0.getVT();
    assertSame(realMatrix1, realMatrix0);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test39880() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    eigenDecompositionImpl0.getV();
    eigenDecompositionImpl0.getV();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public EigenDecompositionImpl(final RealMatrix matrix, final double splitTolerance) throws InvalidMatrixException {
    if (isSymmetric(matrix)) {
        this.splitTolerance = splitTolerance;
        transformToTridiagonal(matrix);
        decompose();
    } else {
        // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported
        // see issue https://issues.apache.org/jira/browse/MATH-235
        throw new InvalidMatrixException(""eigen decomposition of assymetric matrices not supported yet"");
    }
}","public void test40881() throws Throwable {
    double[][] doubleArray0 = new double[2][4];
    double[] doubleArray1 = new double[18];
    doubleArray1[0] = 1.7989122232364704E-8;
    doubleArray0[0] = doubleArray1;
    doubleArray0[1] = doubleArray1;
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = null;
    try {
        eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 3009.08573);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // eigen decomposition of assymetric matrices not supported yet
        //
        verifyException(""org.apache.commons.math.linear.EigenDecompositionImpl"", e);
    }
}","/**
 * Calculates the eigen decomposition of the given symmetric matrix.
 * @param matrix The <strong>symmetric</strong> matrix to decompose.
 * @param splitTolerance tolerance on the off-diagonal elements relative to the
 * geometric mean to split the tridiagonal matrix (a suggested value is
 * {@link MathUtils#SAFE_MIN})
 * @exception InvalidMatrixException (wrapping a {@link
 * org.apache.commons.math.ConvergenceException} if algorithm fails to converge
 */"
"public double[] getRealEigenvalues() throws InvalidMatrixException {
    return realEigenvalues.clone();
}","public void test41882() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double[] doubleArray1 = eigenDecompositionImpl0.getRealEigenvalues();
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getRealEigenvalue(final int i) throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
    return realEigenvalues[i];
}","public void test42883() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    double double0 = eigenDecompositionImpl0.getRealEigenvalue(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test43884() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    eigenDecompositionImpl0.getImagEigenvalue(0);
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public double getDeterminant() {
    double determinant = 1;
    for (double lambda : realEigenvalues) {
        determinant *= lambda;
    }
    return determinant;
}","public void test44885() throws Throwable {
    double[] doubleArray0 = new double[6];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, 0, 0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    RealMatrix realMatrix0 = arrayRealVector1.outerProduct(doubleArray0);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(realMatrix0, 0.0);
    eigenDecompositionImpl0.getImagEigenvalues();
    assertEquals(0.0, eigenDecompositionImpl0.getDeterminant(), 0.01);
}","/**
 * Return the determinant of the matrix
 * @return determinant of the matrix
 */"
"public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        if (eigenvectors == null) {
            findEigenVectors();
        }
        final int m = eigenvectors.length;
        cachedV = MatrixUtils.createRealMatrix(m, m);
        for (int k = 0; k < m; ++k) {
            cachedV.setColumnVector(k, eigenvectors[k]);
        }
    }
    // return the cached matrix
    return cachedV;
}","public void test45886() throws Throwable {
    Array2DRowRealMatrix array2DRowRealMatrix0 = new Array2DRowRealMatrix(52, 52);
    EigenDecompositionImpl eigenDecompositionImpl0 = new EigenDecompositionImpl(array2DRowRealMatrix0, 4.186838380410498E-10);
    // Undeclared exception!
    eigenDecompositionImpl0.getV();
}","/**
 * {@inheritDoc}
 */"
