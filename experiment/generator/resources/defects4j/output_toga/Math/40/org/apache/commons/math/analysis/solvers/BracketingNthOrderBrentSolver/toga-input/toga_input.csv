focal_method,test_prefix,docstring
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test000() throws Throwable {
    Log10 log10_0 = new Log10();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(948.8898, 0, 5);
    bracketingNthOrderBrentSolver0.solve(5, (UnivariateFunction) log10_0, (-2.185293416871393E-12), (double) 5, (double) 0, allowedSolution0);
}","/**
 * {@inheritDoc}
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test011() throws Throwable {
    Log10 log10_0 = new Log10();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    UnivariateFunction univariateFunction0 = log10_0.derivative();
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(948.8898, 1759, 5);
    bracketingNthOrderBrentSolver0.solve(1759, univariateFunction0, (-3314.8624839745), (double) 1759, 948.8898, allowedSolution0);
    bracketingNthOrderBrentSolver0.doSolve();
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test022() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-1.0), 1630);
    Inverse inverse0 = new Inverse();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    // Undeclared exception!
    bracketingNthOrderBrentSolver0.solve(1630, (UnivariateFunction) inverse0, (-1.0), 2125.439409557961, allowedSolution0);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test033() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.5, 0.5, 2);
    Sigmoid sigmoid0 = new Sigmoid(2, 0);
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(0, (UnivariateFunction) sigmoid0, (double) 0, 4524.565, allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test044() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.37036033754146), (-336.37036033754146), 870);
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(870, (UnivariateFunction) gaussian0, 1.0E-15, (-1.0), allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [0, -0.5]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test055() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Minus minus0 = new Minus();
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(0, (UnivariateFunction) minus0, (-2921.193336343551), 3.910525597437617E-5, (-1387.77948), allowedSolution0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (0) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test066() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(5, (UnivariateFunction) sinc0, 5595.40184475436, 4190.499975821219, 0.0, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [5,595.402, 0]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test077() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(5, (UnivariateFunction) null, (double) 5, 1.6390891075134277, (double) 80212818, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test088() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // endpoints do not specify an interval: [0, 0]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test099() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.0, 386.18255718, (-3862.0), 1707);
    Sqrt sqrt0 = new Sqrt();
    bracketingNthOrderBrentSolver0.setup(5, sqrt0, 1162.05718041954, 386.18255718, Double.NaN);
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.doSolve();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [1,162.057, 386.183], values: [34.089, 19.652]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1010() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-1.0), 1485);
    Asinh asinh0 = new Asinh();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(1485, (UnivariateFunction) asinh0, (-1.0), 2125.439409557961, allowedSolution0);
    assertEquals(1485, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1011() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-1.0), 1485);
    Asinh asinh0 = new Asinh();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(1485, (UnivariateFunction) asinh0, (-1.0), 2125.439409557961, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1112() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Log10 log10_0 = new Log10();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(1759, (UnivariateFunction) log10_0, 0.0, (double) 1759, allowedSolution0);
    assertEquals(0.999999955087079, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1213() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.37036033754146), (-336.37036033754146), 870);
    Atanh atanh0 = new Atanh();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(1939, (UnivariateFunction) atanh0, (-1.0), 1.0E-15, allowedSolution0);
    assertEquals(5.551115123125783E-17, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1214() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.37036033754146), (-336.37036033754146), 870);
    Atanh atanh0 = new Atanh();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(1939, (UnivariateFunction) atanh0, (-1.0), 1.0E-15, allowedSolution0);
    assertEquals(870, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1315() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870, 870);
    Gaussian gaussian0 = new Gaussian();
    UnivariateFunction univariateFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, univariateFunction0, (-1.0), 1.0E-15, allowedSolution0);
    assertEquals(1.0E-15, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1316() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870, 870);
    Gaussian gaussian0 = new Gaussian();
    UnivariateFunction univariateFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, univariateFunction0, (-1.0), 1.0E-15, allowedSolution0);
    assertEquals(870, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1417() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    bracketingNthOrderBrentSolver0.solve(3065, (UnivariateFunction) sinc0, (double) 3065, 5595.40184475436);
    double double0 = bracketingNthOrderBrentSolver0.doSolve();
    assertEquals(5, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test1418() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    bracketingNthOrderBrentSolver0.solve(3065, (UnivariateFunction) sinc0, (double) 3065, 5595.40184475436);
    double double0 = bracketingNthOrderBrentSolver0.doSolve();
    assertEquals(5043.000000000013, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test1519() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(80212818, (UnivariateFunction) sinc0, (-3136.0), (double) 5, (-2042.9861249047), allowedSolution0);
    assertEquals((-3111.0000000001737), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1520() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    AllowedSolution allowedSolution0 = AllowedSolution.LEFT_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(80212818, (UnivariateFunction) sinc0, (-3136.0), (double) 5, (-2042.9861249047), allowedSolution0);
    assertEquals(5, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public double solve(int maxEval, FUNC f, double min, double max) {
    return solve(maxEval, f, min, max, min + 0.5 * (max - min));
}","public void test1621() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    double double0 = bracketingNthOrderBrentSolver0.solve(3068, (UnivariateFunction) sinc0, (double) 3068, 5595.40184475436);
    assertEquals(3076.9999999991105, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1622() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    double double0 = bracketingNthOrderBrentSolver0.solve(3068, (UnivariateFunction) sinc0, (double) 3068, 5595.40184475436);
    assertEquals(5, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1723() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.37036033754146), (-336.37036033754146), 870);
    Gaussian gaussian0 = new Gaussian();
    UnivariateFunction univariateFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.ABOVE_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, univariateFunction0, (-1.0), 1.0E-15, allowedSolution0);
    assertEquals((-5.551115123125783E-17), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test1824() throws Throwable {
    Log10 log10_0 = new Log10();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(948.8898, 1759, 5);
    bracketingNthOrderBrentSolver0.solve(5, (UnivariateFunction) log10_0, (-2.185293416871393E-12), (double) 5, 1.0E-15, allowedSolution0);
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.doSolve();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // illegal state: maximal count (5) exceeded: evaluations
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test1925() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870);
    Gaussian gaussian0 = new Gaussian();
    UnivariateFunction univariateFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, univariateFunction0, (-1.0), 0.0, allowedSolution0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test1926() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870);
    Gaussian gaussian0 = new Gaussian();
    UnivariateFunction univariateFunction0 = gaussian0.derivative();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, univariateFunction0, (-1.0), 0.0, allowedSolution0);
    assertEquals(870, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test2027() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.0, 0.0, 0.0, 1707);
    Sqrt sqrt0 = new Sqrt();
    bracketingNthOrderBrentSolver0.setup(5, sqrt0, 0, 0.0, Double.NaN);
    double double0 = bracketingNthOrderBrentSolver0.doSolve();
    assertEquals(1707, bracketingNthOrderBrentSolver0.getMaximalOrder());
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
"@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // the guessed root is not strictly inside of the tightest bracketing interval
                // the guessed root is either not strictly inside the interval or it
                // is a NaN (which occurs when some sampling points share the same y)
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we have found an exact root, since it is not an approximation
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        //(by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}","public void test2028() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.0, 0.0, 0.0, 1707);
    Sqrt sqrt0 = new Sqrt();
    bracketingNthOrderBrentSolver0.setup(5, sqrt0, 0, 0.0, Double.NaN);
    double double0 = bracketingNthOrderBrentSolver0.doSolve();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getMin() {
    return searchMin;
}","public void test2129() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870);
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, (UnivariateFunction) gaussian0, (-336.4448868689607), (double) 870, allowedSolution0);
    assertEquals((-336.4448868689607), bracketingNthOrderBrentSolver0.getMin(), 0.01);
}","/**
 * @return the lower end of the search interval.
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test2130() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-336.4448868689607), (-336.4448868689607), 870);
    Gaussian gaussian0 = new Gaussian();
    AllowedSolution allowedSolution0 = AllowedSolution.BELOW_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(870, (UnivariateFunction) gaussian0, (-336.4448868689607), (double) 870, allowedSolution0);
    assertEquals(266.7775565655196, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final double functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException {
    super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);
    if (maximalOrder < 2) {
        throw new NumberIsTooSmallException(maximalOrder, 2, true);
    }
    this.maximalOrder = maximalOrder;
    this.allowed = AllowedSolution.ANY_SIDE;
}","public void test2231() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = null;
    try {
        bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.0, (-176), 2553.8937608706196, (-176));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -176 is smaller than the minimum (2)
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"", e);
    }
}","/**
 * Construct a solver.
 *
 * @param relativeAccuracy Relative accuracy.
 * @param absoluteAccuracy Absolute accuracy.
 * @param functionValueAccuracy Function value accuracy.
 * @param maximalOrder maximal order.
 * @exception NumberIsTooSmallException if maximal order is lower than 2
 */"
"public BracketingNthOrderBrentSolver(final double relativeAccuracy, final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {
    super(relativeAccuracy, absoluteAccuracy);
    if (maximalOrder < 2) {
        throw new NumberIsTooSmallException(maximalOrder, 2, true);
    }
    this.maximalOrder = maximalOrder;
    this.allowed = AllowedSolution.ANY_SIDE;
}","public void test2332() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = null;
    try {
        bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(733.043805, (-713.8371), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 is smaller than the minimum (2)
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"", e);
    }
}","/**
 * Construct a solver.
 *
 * @param relativeAccuracy Relative accuracy.
 * @param absoluteAccuracy Absolute accuracy.
 * @param maximalOrder maximal order.
 * @exception NumberIsTooSmallException if maximal order is lower than 2
 */"
"public BracketingNthOrderBrentSolver(final double absoluteAccuracy, final int maximalOrder) throws NumberIsTooSmallException {
    super(absoluteAccuracy);
    if (maximalOrder < 2) {
        throw new NumberIsTooSmallException(maximalOrder, 2, true);
    }
    this.maximalOrder = maximalOrder;
    this.allowed = AllowedSolution.ANY_SIDE;
}","public void test2433() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = null;
    try {
        bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver((-792), (-792));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -792 is smaller than the minimum (2)
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"", e);
    }
}","/**
 * Construct a solver.
 *
 * @param absoluteAccuracy Absolute accuracy.
 * @param maximalOrder maximal order.
 * @exception NumberIsTooSmallException if maximal order is lower than 2
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, double startValue, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max, startValue);
}","public void test2534() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    Sinc sinc0 = new Sinc(true);
    AllowedSolution allowedSolution0 = AllowedSolution.RIGHT_SIDE;
    double double0 = bracketingNthOrderBrentSolver0.solve(80212818, (UnivariateFunction) sinc0, (-3136.0), (double) 5, (-2042.9861249047), allowedSolution0);
    assertEquals((-3110.999999997229), double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double solve(int maxEval, UnivariateFunction f, double min, double max, AllowedSolution allowedSolution) {
    this.allowed = allowedSolution;
    return super.solve(maxEval, f, min, max);
}","public void test2635() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver(0.0, 0.0, 0.0, 1707);
    Sqrt sqrt0 = new Sqrt();
    AllowedSolution allowedSolution0 = AllowedSolution.ANY_SIDE;
    // Undeclared exception!
    try {
        bracketingNthOrderBrentSolver0.solve(3, (UnivariateFunction) sqrt0, 1567.703073, 2791.57857089207, allowedSolution0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // function values at endpoints do not have different signs, endpoints: [1,567.703, 2,791.579], values: [39.594, 52.835]
        //
        verifyException(""org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getMaximalOrder() {
    return maximalOrder;
}","public void test2736() throws Throwable {
    BracketingNthOrderBrentSolver bracketingNthOrderBrentSolver0 = new BracketingNthOrderBrentSolver();
    int int0 = bracketingNthOrderBrentSolver0.getMaximalOrder();
    assertEquals(5, int0);
}","/**
 * Get the maximal order.
 * @return maximal order
 */"
