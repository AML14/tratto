focal_method,test_prefix,docstring
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test000() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.valueOf(1.0);
    Complex complex2 = complex0.multiply(complex1);
    Complex complex3 = Complex.valueOf(1.0);
    complex3.I.add(1.0);
    complex0.NaN.nthRoot(2501);
    Complex complex4 = complex2.ONE.pow(complex0);
    complex4.conjugate();
    complex4.ONE.getField();
    Complex.valueOf(1.0);
    Complex complex5 = complex4.asin();
    complex5.log();
    complex1.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test011() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex2.tan();
    complex3.subtract(complex2);
    double double0 = complex3.abs();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public Complex tanh() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","public void test012() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex2.tan();
    complex3.subtract(complex2);
    double double0 = complex3.abs();
    Complex complex4 = complex3.tanh();
    assertSame(complex4, complex3);
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + i) = NaN + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test023() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    assertFalse(complex1.isInfinite());
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public double getReal() {
    return real;
}","public void test024() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    assertEquals(0.5403023058681398, complex1.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test025() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    assertEquals(0.0, complex1.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test026() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    Complex complex2 = complex0.NaN.tan();
    Complex complex3 = complex0.add(1.0);
    Complex complex4 = complex0.subtract(0.0);
    complex4.INF.cosh();
    Complex complex5 = complex4.cos();
    assertTrue(complex4.equals((Object) complex3));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex cos() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary), -FastMath.sin(real) * MathUtils.sinh(imaginary));
}","public void test027() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    Complex complex2 = complex0.NaN.tan();
    Complex complex3 = complex0.add(1.0);
    Complex complex4 = complex0.subtract(0.0);
    complex4.INF.cosh();
    Complex complex5 = complex4.cos();
    assertNotSame(complex5, complex2);
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 *   cos(&plusmn;INFINITY + i) = NaN + NaN i
 *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the cosine of this complex number.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test028() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    Complex complex2 = complex0.NaN.tan();
    Complex complex3 = complex0.add(1.0);
    Complex complex4 = complex0.subtract(0.0);
    complex4.INF.cosh();
    Complex complex5 = complex4.cos();
    assertTrue(complex0.equals((Object) complex4));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test029() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    Complex complex2 = complex0.NaN.tan();
    Complex complex3 = complex0.add(1.0);
    Complex complex4 = complex0.subtract(0.0);
    complex4.INF.cosh();
    Complex complex5 = complex4.cos();
    assertTrue(complex4.isInfinite());
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0210() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.cosh();
    Complex complex2 = complex0.NaN.tan();
    Complex complex3 = complex0.add(1.0);
    Complex complex4 = complex0.subtract(0.0);
    complex4.INF.cosh();
    Complex complex5 = complex4.cos();
    assertTrue(complex5.equals((Object) complex2));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public double getReal() {
    return real;
}","public void test0311() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    assertEquals(0.3465735902799727, complex6.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test0312() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    assertEquals(-0.0, complex14.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getReal() {
    return real;
}","public void test0313() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    assertEquals(-0.0, complex14.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test0314() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    assertSame(complex9, complex5);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0315() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    assertTrue(complex22.equals((Object) complex11));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test0316() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    assertEquals(0.0, complex22.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test0317() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    assertNotSame(complex23, complex11);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0318() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    String string0 = complex8.toString();
    assertFalse(complex8.equals((Object) complex4));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0319() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    String string0 = complex8.toString();
    assertTrue(complex0.equals((Object) complex15));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0320() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    String string0 = complex8.toString();
    assertFalse(complex8.equals((Object) complex18));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test0321() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    String string0 = complex8.toString();
    assertEquals(""(Infinity, NaN)"", string0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0322() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = complex0.multiply(0.0);
    Complex complex2 = complex1.ZERO.conjugate();
    complex2.I.createComplex((-618.01996014), 0.0);
    Complex complex3 = complex0.NaN.exp();
    Complex complex4 = complex1.INF.divide(0.0);
    Complex complex5 = complex1.divide(0.0);
    Complex complex6 = complex0.log();
    Complex complex7 = complex1.sin();
    Complex complex8 = complex0.INF.sqrt();
    Complex complex9 = complex0.NaN.tan();
    complex7.I.getArgument();
    complex5.atan();
    Complex complex10 = complex5.conjugate();
    Complex complex11 = complex0.INF.multiply(complex3);
    Complex complex12 = complex10.INF.cosh();
    Complex complex13 = complex12.I.pow(1.0);
    Complex complex14 = complex7.negate();
    complex7.getImaginary();
    Complex complex15 = complex7.add(complex0);
    Complex complex16 = complex1.log();
    Complex complex17 = complex12.multiply(0.0);
    Complex complex18 = complex17.I.pow(1.5707963267948966);
    Complex complex19 = Complex.valueOf(4734.7381062603);
    complex19.INF.exp();
    Complex complex20 = complex9.divide(1.0);
    Complex complex21 = complex19.multiply(1.0);
    complex20.equals(complex21);
    complex9.multiply(complex13);
    Complex complex22 = complex21.tanh();
    Complex complex23 = complex22.INF.pow(complex16);
    String string0 = complex8.toString();
    assertTrue(complex8.equals((Object) complex17));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test0423() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.ONE.add(5265.00324922752);
    Complex complex1 = Complex.valueOf(1772.2415, 1772.2415);
    Complex complex2 = Complex.NaN;
    Complex complex3 = complex2.divide(complex0);
    complex1.ZERO.log();
    complex3.INF.negate();
    Complex complex4 = complex3.divide(complex0);
    complex4.ONE.add(complex1);
    complex0.subtract(complex2);
    complex0.conjugate();
    Complex complex5 = complex2.atan();
    complex5.ZERO.getArgument();
    complex5.ONE.sin();
    complex4.getField();
    complex4.tan();
    complex4.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test0524() throws Throwable {
    Complex complex0 = new Complex(928.4931335996077);
    Complex complex1 = Complex.valueOf(928.4931335996077);
    complex1.readResolve();
    complex1.readResolve();
    complex1.NaN.exp();
    Complex complex2 = complex1.I.divide(complex0);
    Complex complex3 = complex2.ONE.asin();
    complex3.createComplex(928.4931335996077, (-1093.25));
    complex2.ONE.hashCode();
    complex0.hashCode();
    complex1.subtract(complex0);
    Complex complex4 = complex0.multiply(459.55744);
    Complex.valueOf((-347.808928076401), (-347.808928076401));
    complex4.abs();
    complex4.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test0625() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.readResolve();
    complex0.nthRoot(1223);
    complex0.getReal();
    Complex complex1 = complex0.I.multiply(2597.767982);
    Complex complex2 = complex1.INF.add(complex0);
    Complex complex3 = complex2.ONE.atan();
    complex3.ZERO.nthRoot(17);
    Complex complex4 = complex0.acos();
    Complex complex5 = complex4.ONE.tan();
    Complex complex6 = complex5.INF.add(complex4);
    complex5.I.toString();
    Complex complex7 = complex4.ONE.sqrt();
    complex7.INF.atan();
    Complex complex8 = complex7.NaN.pow((double) 1223);
    Complex complex9 = complex7.ZERO.cosh();
    complex7.ZERO.getField();
    complex0.getImaginary();
    Complex complex10 = complex4.divide(complex0);
    Complex.valueOf((double) 1223, 0.0);
    complex10.getArgument();
    complex10.pow(complex3);
    complex8.getReal();
    Complex complex11 = Complex.ONE;
    complex11.NaN.exp();
    complex1.pow(complex11);
    complex6.multiply((-2.082121537131544));
    complex6.tan();
    complex9.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test0726() throws Throwable {
    Complex complex0 = Complex.valueOf(1.0, 1655.21305);
    Complex complex1 = complex0.NaN.createComplex(1.0, 1.0);
    Complex complex2 = complex1.ZERO.atan();
    complex1.ZERO.getArgument();
    Complex complex3 = Complex.valueOf(3859.182206032, 1.0);
    Complex complex4 = complex0.multiply(1.0);
    complex2.hashCode();
    Complex complex5 = complex0.sqrt();
    complex5.INF.add(0.0);
    Complex complex6 = complex4.I.divide(complex3);
    complex6.ZERO.getArgument();
    complex5.ONE.hashCode();
    complex5.getReal();
    Complex complex7 = complex4.negate();
    complex5.ZERO.subtract(1.0);
    Complex complex8 = Complex.valueOf(1.0, -0.0);
    complex2.tan();
    complex5.getArgument();
    Complex complex9 = Complex.valueOf(1.0, 0.0);
    complex8.pow(1986.200292018337);
    complex4.nthRoot(3109);
    complex9.getArgument();
    complex7.hashCode();
    complex0.toString();
}","/**
 * {@inheritDoc}
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test0827() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    Complex complex1 = complex0.createComplex(0.0, (-1.0));
    Complex complex2 = complex1.tanh();
    complex0.NaN.getArgument();
    Complex complex3 = Complex.valueOf(Double.NaN, 0.0);
    complex3.ZERO.createComplex(0.0, 1.0);
    complex3.multiply((-1.0));
    complex2.I.abs();
    Complex complex4 = complex1.acos();
    Complex complex5 = complex0.ZERO.acos();
    complex2.hashCode();
    Complex complex6 = complex1.sinh();
    Complex complex7 = complex6.add(0.0);
    Complex complex8 = complex7.INF.sinh();
    Complex.valueOf(1.0, Double.NaN);
    Complex complex9 = complex1.sinh();
    complex4.abs();
    Complex complex10 = complex4.tanh();
    complex10.I.add(complex0);
    Complex complex11 = complex4.exp();
    complex11.INF.abs();
    complex9.negate();
    complex9.tan();
    complex7.sin();
    complex8.toString();
    complex5.abs();
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        // return isZero ? NaN : INF; // See MATH-657
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test0928() throws Throwable {
    Complex complex0 = new Complex((-2304.035705716513), (-319.5240611725));
    complex0.divide((-319.5240611725));
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test1029() throws Throwable {
    Complex complex0 = new Complex(1.0);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.ZERO.pow(complex1);
    Complex complex3 = complex2.ONE.log();
    complex0.ONE.divide(complex1);
    Complex complex4 = complex0.NaN.tan();
    complex4.ONE.tanh();
    complex0.abs();
    Complex complex5 = complex1.cosh();
    complex5.add(complex3);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test1130() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.ZERO.asin();
    complex1.abs();
    Complex complex2 = Complex.valueOf(1294.1774039);
    Complex complex3 = complex0.createComplex(1055.1760992392, 1055.1760992392);
    Complex complex4 = complex0.subtract((-453.688402));
    Complex complex5 = complex4.ZERO.pow(complex2);
    Object object0 = new Object();
    complex4.equals(object0);
    Complex complex6 = complex4.sqrt1z();
    complex5.NaN.sin();
    Complex complex7 = complex6.I.divide(complex2);
    complex3.getField();
    Complex complex8 = complex3.cos();
    Complex complex9 = complex5.divide((-453.688402));
    complex9.NaN.divide(complex4);
    complex0.INF.tan();
    complex3.INF.atan();
    Complex.valueOf(0.0);
    complex0.divide(complex2);
    Complex complex10 = complex3.multiply(1055.1760992392);
    complex10.INF.asin();
    complex8.toString();
    complex8.cosh();
    complex7.sqrt1z();
    complex1.pow((-1.0));
    complex5.toString();
    complex3.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test1231() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.ZERO.atan();
    complex0.readResolve();
    Complex complex2 = complex0.I.asin();
    complex2.ZERO.divide(complex1);
    Complex complex3 = complex0.atan();
    complex1.multiply((-3007.6));
    complex3.cosh();
    complex2.toString();
}","/**
 * {@inheritDoc}
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test1332() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.ONE;
    Complex complex2 = complex0.add(complex1);
    complex2.NaN.hashCode();
    complex0.getImaginary();
    complex0.ONE.add(complex1);
    complex1.NaN.getArgument();
    Complex complex3 = new Complex(Double.NaN, Double.NaN);
    complex0.NaN.subtract(complex3);
    Complex complex4 = complex2.pow(complex3);
    complex2.readResolve();
    complex3.getImaginary();
    complex4.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public double getReal() {
    return real;
}","public void test1433() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 671.3094465196);
    Complex complex1 = complex0.NaN.negate();
    Complex complex2 = complex0.NaN.conjugate();
    complex0.getImaginary();
    complex0.abs();
    complex1.INF.pow((-1240.1536142814514));
    complex2.ZERO.atan();
    Complex complex3 = complex2.subtract(complex1);
    complex3.readResolve();
    complex2.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test1534() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.INF.abs();
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex1.NaN.add((-4935.6723));
    Complex complex3 = complex1.ZERO.subtract(1704.3733911);
    complex2.INF.abs();
    Complex complex4 = complex3.INF.cos();
    complex4.ONE.tan();
    Complex complex5 = complex1.conjugate();
    complex0.ZERO.subtract(complex2);
    complex0.toString();
    complex3.abs();
    complex5.hashCode();
    Complex complex6 = complex5.negate();
    complex6.NaN.negate();
    complex5.hashCode();
    complex6.getReal();
    complex4.add(Double.NaN);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test1635() throws Throwable {
    Complex complex0 = new Complex(0.3333333134651184, 2.0);
    Complex complex1 = complex0.sqrt1z();
    complex1.ZERO.getArgument();
    Complex complex2 = complex1.sqrt1z();
    complex1.I.atan();
    complex2.getArgument();
    Complex complex3 = complex1.multiply(1.0);
    complex3.I.sqrt1z();
    Complex complex4 = complex3.tanh();
    complex3.equals(complex4);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test1736() throws Throwable {
    Complex complex0 = Complex.ZERO;
    try {
        complex0.INF.subtract((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        // return isZero ? NaN : INF; // See MATH-657
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test1837() throws Throwable {
    Complex complex0 = new Complex((-2289.0505632029985), (-36.04));
    Complex complex1 = new Complex(630.736923883764, (-2289.0505632029985));
    complex1.I.negate();
    complex1.NaN.divide(complex0);
    complex1.NaN.toString();
    Complex complex2 = complex0.subtract(complex1);
    complex2.isInfinite();
    complex2.divide(1.0);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"@Override
public int hashCode() {
    if (isNaN) {
        return 7;
    }
    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));
}","public void test1938() throws Throwable {
    Complex complex0 = new Complex(0.041666663879186654, 0.041666663879186654);
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex0.ZERO.subtract(complex1);
    Complex complex3 = complex2.exp();
    complex1.NaN.add(complex0);
    Complex complex4 = complex0.I.cos();
    Complex complex5 = complex4.conjugate();
    Complex complex6 = Complex.valueOf((-1.0));
    complex6.ZERO.acos();
    complex1.I.divide((-1.0));
    complex1.ZERO.getArgument();
    Complex complex7 = complex1.INF.tanh();
    complex7.INF.tan();
    complex0.readResolve();
    Complex complex8 = complex0.cosh();
    complex2.NaN.negate();
    complex2.INF.getArgument();
    Complex complex9 = complex8.I.sinh();
    Complex.valueOf((-1.0));
    complex1.add(2807.984);
    complex0.INF.divide(complex8);
    complex5.add(1.2958646899018938E-9);
    complex3.acos();
    complex9.hashCode();
}","/**
 * Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.
 *
 * @return a hash code value for this object.
 */"
"public Complex pow(double x) {
    return this.log().multiply(x).exp();
}","public void test2039() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.I.atan();
    complex1.divide(complex0);
    Complex complex2 = complex0.ZERO.multiply(complex1);
    Complex.valueOf(558.826502192676, 558.826502192676);
    Complex complex3 = complex0.divide(3398.0);
    Complex complex4 = Complex.valueOf((-333.47), (-333.47));
    complex3.createComplex(3398.0, 0.11764700710773468);
    complex3.getArgument();
    complex2.sqrt();
    complex2.pow(0.0);
    complex4.pow(1.0);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code>this<sup>x</sup></code>.
 * @see #pow(Complex)
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test2140() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.NaN.createComplex(Double.NaN, (-564.689));
    Complex complex1 = complex0.I.pow(1123.5432165985771);
    Complex complex2 = complex1.ZERO.tanh();
    Complex complex3 = complex1.INF.sqrt1z();
    Complex complex4 = complex0.sqrt();
    complex4.I.readResolve();
    complex0.getImaginary();
    complex4.getArgument();
    complex0.getField();
    Complex complex5 = complex0.conjugate();
    complex5.ZERO.getField();
    Complex.valueOf(Double.NaN, (-564.689));
    complex5.add(1123.5432165985771);
    complex4.sqrt();
    complex4.atan();
    complex3.getField();
    complex2.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test2241() throws Throwable {
    Complex complex0 = new Complex(1.0, 1.0);
    Complex complex1 = Complex.NaN;
    complex1.INF.toString();
    complex0.INF.divide(complex1);
    complex0.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test2342() throws Throwable {
    Complex complex0 = new Complex(1.0);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex1.ONE.sqrt();
    Complex.valueOf(0.49999999999999994);
    Complex complex3 = complex0.INF.conjugate();
    complex0.add((-525.9438461004012));
    complex0.equals(complex1);
    Complex complex4 = complex3.tanh();
    complex0.NaN.subtract(1.0);
    complex3.getImaginary();
    Complex complex5 = Complex.valueOf(Double.NaN);
    Complex complex6 = complex5.add(complex4);
    complex6.conjugate();
    Complex complex7 = complex1.ZERO.cosh();
    complex7.cosh();
    complex7.ZERO.toString();
    Complex complex8 = complex3.tanh();
    complex8.add(complex5);
    complex1.sin();
    complex1.getReal();
    Complex complex9 = complex4.subtract(complex5);
    Complex.valueOf((-525.9438461004012));
    complex9.abs();
    complex8.tan();
    Complex.valueOf(Double.NaN, Double.NaN);
    complex2.isInfinite();
    complex8.multiply(0.0);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public static Complex valueOf(double realPart) {
    if (Double.isNaN(realPart)) {
        return NaN;
    }
    return new Complex(realPart);
}","public void test2443() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0);
    Complex complex1 = complex0.add((-1384.5897272));
    Complex complex2 = Complex.valueOf(0.0, 0.0);
    complex2.readResolve();
    complex0.ZERO.tanh();
    complex0.getImaginary();
    Complex complex3 = complex0.cos();
    Complex complex4 = complex3.ONE.tanh();
    Complex complex5 = complex0.atan();
    complex5.NaN.abs();
    Complex complex6 = complex4.divide(complex1);
    Complex complex7 = complex3.INF.add((-3515.79));
    Complex complex8 = complex3.I.asin();
    Complex complex9 = complex8.ONE.cos();
    complex9.I.negate();
    Complex complex10 = complex0.multiply(complex3);
    complex10.getArgument();
    Complex complex11 = complex0.divide(complex7);
    Complex complex12 = complex0.divide(0.0);
    complex12.ONE.pow(complex5);
    complex12.NaN.divide(complex4);
    complex11.I.log();
    Complex complex13 = complex0.ZERO.divide(complex5);
    Complex complex14 = complex13.I.add(1067.523246575);
    Complex complex15 = complex14.NaN.sqrt1z();
    complex11.isInfinite();
    complex5.isInfinite();
    Complex complex16 = complex7.sqrt();
    complex15.NaN.multiply(complex16);
    complex6.toString();
    complex15.createComplex(6.283185307179586, 1067.523246575);
    Complex.valueOf(0.0);
}","/**
 * Create a complex number given only the real part.
 *
 * @param realPart Real part.
 * @return a Complex instance.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test2544() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0);
    Complex complex1 = complex0.I.divide((-4225.05308651376));
    Complex complex2 = complex0.atan();
    Complex complex3 = complex0.sqrt();
    Complex complex4 = complex2.atan();
    complex3.getArgument();
    complex4.ONE.toString();
    complex1.ONE.hashCode();
    complex3.toString();
    Complex complex5 = Complex.valueOf((-4225.05308651376));
    Complex complex6 = complex1.divide(0.0);
    complex6.conjugate();
    complex4.divide(complex0);
    complex5.conjugate();
    complex5.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public double getReal() {
    return real;
}","public void test2645() throws Throwable {
    Complex complex0 = Complex.valueOf((-739.0));
    Complex complex1 = complex0.ONE.conjugate();
    Complex complex2 = complex0.subtract((-13.95));
    complex2.NaN.abs();
    complex0.ZERO.asin();
    Complex complex3 = complex2.pow(complex0);
    Complex complex4 = complex3.ONE.exp();
    Complex complex5 = complex0.ZERO.add(complex2);
    complex5.ZERO.cos();
    complex1.I.negate();
    complex0.tanh();
    complex1.abs();
    complex0.sinh();
    Complex complex6 = complex1.tanh();
    complex6.divide(complex2);
    Complex complex7 = complex4.conjugate();
    complex7.conjugate();
    complex6.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test2746() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.acos();
    complex1.I.readResolve();
    Complex complex2 = complex0.conjugate();
    complex2.I.exp();
    Complex complex3 = complex1.add(complex0);
    Complex complex4 = complex0.NaN.sqrt1z();
    Complex complex5 = complex0.multiply(1.0);
    Complex complex6 = complex5.divide((-2983.168584589799));
    complex0.getImaginary();
    complex6.divide(complex5);
    complex5.getArgument();
    complex0.getImaginary();
    complex6.negate();
    Object object0 = complex3.readResolve();
    complex4.equals(object0);
    Complex.valueOf(0.0);
    Complex complex7 = new Complex((-2175.92756), (-2983.168584589799));
    complex3.equals(complex7);
    complex1.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test2847() throws Throwable {
    Complex complex0 = Complex.valueOf(1.9699272335463627E-8, 1.9699272335463627E-8);
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex1.sinh();
    complex0.pow(complex1);
    Complex complex3 = complex1.log();
    Complex complex4 = complex2.negate();
    Complex complex5 = complex3.sin();
    complex2.NaN.sqrt();
    complex2.readResolve();
    Complex complex6 = complex0.exp();
    complex6.ONE.multiply(2.0);
    Complex complex7 = complex4.pow(0.0);
    complex7.asin();
    complex5.toString();
}","/**
 * {@inheritDoc}
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        // return isZero ? NaN : INF; // See MATH-657
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test2948() throws Throwable {
    Complex complex0 = Complex.valueOf(1.0);
    complex0.abs();
    Complex complex1 = complex0.sinh();
    Complex complex2 = complex1.NaN.pow(1.0);
    complex1.INF.toString();
    Complex complex3 = complex0.multiply(1.0);
    Complex complex4 = complex2.NaN.asin();
    Complex complex5 = complex2.cos();
    Complex complex6 = complex5.NaN.cosh();
    complex1.abs();
    complex3.ZERO.tan();
    Complex complex7 = complex0.pow(1.0);
    complex7.ONE.exp();
    complex7.I.acos();
    complex2.ONE.readResolve();
    complex5.add((-920.35809));
    complex1.atan();
    complex3.divide(1.0);
    complex3.getArgument();
    complex4.hashCode();
    complex6.divide(407.95183982683);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test3049() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.INF.sqrt();
    Complex complex2 = complex1.log();
    Complex.valueOf((double) 2540, (double) 2540);
    complex0.I.conjugate();
    complex1.ZERO.nthRoot(2540);
    complex0.getField();
    Complex complex3 = complex0.add(complex1);
    complex1.isNaN();
    complex0.INF.negate();
    Complex complex4 = complex0.divide(complex3);
    complex4.getImaginary();
    complex2.getArgument();
    complex4.multiply((-1546.4158));
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.isZero) {
        // return isZero ? NaN : INF; // See MATH-657
        return isZero ? NaN : INF;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test3150() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.25);
    complex0.getField();
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex1.ONE.sin();
    complex1.INF.getField();
    complex1.nthRoot(2770);
    Complex complex3 = Complex.valueOf(1.570796251296997, (double) 2770);
    complex1.sqrt1z();
    Complex complex4 = complex2.NaN.subtract(complex0);
    complex3.sinh();
    complex2.readResolve();
    complex4.subtract((-473.25324));
    complex3.conjugate();
    Complex.valueOf((-473.25324), (-473.25324));
    Complex complex5 = complex3.add((double) 2770);
    Complex complex6 = Complex.ZERO;
    complex5.divide(complex6);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test3251() throws Throwable {
    Complex complex0 = Complex.valueOf(0.16666666666666666, 0.16666666666666666);
    Complex complex1 = complex0.NaN.conjugate();
    complex1.I.createComplex(1.0, 0.16666666666666666);
    Complex complex2 = complex0.INF.negate();
    Complex.valueOf(1.0, 0.16666666666666666);
    complex2.ONE.multiply(complex0);
    Complex complex3 = complex2.ONE.sqrt();
    Complex complex4 = Complex.valueOf((-2135.0));
    complex4.I.add((-2135.0));
    complex0.abs();
    complex0.toString();
    complex0.getReal();
    complex0.hashCode();
    complex4.getImaginary();
    complex0.pow((-2135.0));
    complex3.multiply(1.0);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test3352() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.pow((-1580.0526));
    Complex complex2 = complex1.ZERO.sin();
    Complex complex3 = complex2.NaN.sqrt();
    complex1.hashCode();
    Complex complex4 = complex0.exp();
    complex4.NaN.multiply((-1580.0526));
    complex4.INF.abs();
    Complex complex5 = complex0.negate();
    complex0.subtract(2024.5786127379486);
    Complex.valueOf(2.0, 4328.89478421);
    complex3.tan();
    complex2.isNaN();
    complex2.readResolve();
    complex5.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public static Complex valueOf(double realPart) {
    if (Double.isNaN(realPart)) {
        return NaN;
    }
    return new Complex(realPart);
}","public void test3453() throws Throwable {
    Complex complex0 = Complex.valueOf((-2098.980137684341));
    Complex complex1 = Complex.valueOf(0.0, (-1884.806573799));
    Complex complex2 = complex0.createComplex(3160.071260027, (-2098.980137684341));
    complex2.NaN.tanh();
    Complex complex3 = complex2.ZERO.divide(3160.071260027);
    Complex complex4 = complex3.NaN.tanh();
    Complex complex5 = Complex.ONE;
    complex5.I.readResolve();
    Complex complex6 = complex2.NaN.add(complex5);
    complex6.sin();
    Complex complex7 = complex2.ZERO.acos();
    Complex complex8 = complex7.ZERO.log();
    complex0.getReal();
    complex3.INF.nthRoot(1073741824);
    complex1.getImaginary();
    Complex complex9 = complex0.sqrt();
    complex3.getArgument();
    complex5.conjugate();
    complex4.acos();
    complex2.INF.pow(complex4);
    complex8.negate();
    complex3.divide(complex9);
    Complex.valueOf(0.0);
}","/**
 * Create a complex number given only the real part.
 *
 * @param realPart Real part.
 * @return a Complex instance.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test3554() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.ONE.acos();
    complex1.INF.divide((-448.3463));
    Complex complex2 = complex0.asin();
    Complex complex3 = complex2.INF.atan();
    complex3.I.exp();
    Complex complex4 = Complex.valueOf(770.0);
    Complex complex5 = complex4.I.asin();
    complex0.getField();
    complex3.getArgument();
    complex1.multiply(complex5);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
