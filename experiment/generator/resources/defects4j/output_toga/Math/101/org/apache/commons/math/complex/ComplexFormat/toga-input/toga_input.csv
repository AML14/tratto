focal_method,test_prefix,docstring
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test000() throws Throwable {
    Locale locale0 = Locale.PRC;
    NumberFormat numberFormat0 = NumberFormat.getInstance(locale0);
    ComplexFormat complexFormat0 = new ComplexFormat(""4;*g7VZ+41P/"", numberFormat0);
    try {
        complexFormat0.parse(""Ug>0X'ASH!O"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Unparseable complex number: \""Ug>0X'ASH!O\""
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test035() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Complex complex0 = complexFormat0.parse(""(NaN) - 3,737.92i"");
    assertEquals((-3737.92), complex0.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part
 */"
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test036() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Complex complex0 = complexFormat0.parse(""(NaN) - 3,737.92i"");
    assertNotNull(complex0);
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
"public double abs() {
    if (isNaN()) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (Math.abs(real) < Math.abs(imaginary)) {
        if (imaginary == 0.0) {
            return Math.abs(real);
        }
        double q = real / imaginary;
        return (Math.abs(imaginary) * Math.sqrt(1 + q * q));
    } else {
        if (real == 0.0) {
            return Math.abs(imaginary);
        }
        double q = imaginary / real;
        return (Math.abs(real) * Math.sqrt(1 + q * q));
    }
}","public void test047() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Complex complex0 = complexFormat0.parse(""-529.25"");
    assertEquals(529.25, complex0.abs(), 0.01);
}","/**
 * Return the absolute value of this complex number.
 * <p>
 * Returns <code>NaN</code> if either real or imaginary part is
 * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if
 * neither part is <code>NaN</code>, but at least one part takes an infinite
 * value.</p>
 *
 * @return the absolute value
 */"
"public double getReal() {
    return real;
}","public void test048() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Complex complex0 = complexFormat0.parse(""-529.25"");
    assertEquals((-529.25), complex0.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part
 */"
"public NumberFormat getRealFormat() {
    return realFormat;
}","public void test0711() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
    ComplexFormat complexFormat0 = new ComplexFormat(numberFormat0);
    NumberFormat numberFormat1 = complexFormat0.getRealFormat();
    assertSame(numberFormat1, numberFormat0);
}","/**
 * Access the realFormat.
 * @return the realFormat.
 */"
"public NumberFormat getImaginaryFormat() {
    return imaginaryFormat;
}","public void test0913() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
    ComplexFormat complexFormat0 = new ComplexFormat(numberFormat0, numberFormat0);
    numberFormat0.setMaximumIntegerDigits((-3646));
    NumberFormat numberFormat1 = complexFormat0.getImaginaryFormat();
    assertSame(numberFormat1, numberFormat0);
}","/**
 * Access the imaginaryFormat.
 * @return the imaginaryFormat.
 */"
"public Object parseObject(String source, ParsePosition pos) {
    return parse(source, pos);
}","public void test1116() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    ParsePosition parsePosition0 = new ParsePosition((-859));
    // Undeclared exception!
    try {
        complexFormat0.parseObject(""org.apache.commons.math.complex.Complex"", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parses a string to produce a object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed object.
 * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)
 */"
"public Object parseObject(String source, ParsePosition pos) {
    return parse(source, pos);
}","public void test1217() throws Throwable {
    DecimalFormat decimalFormat0 = new DecimalFormat();
    ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0);
    // Undeclared exception!
    try {
        complexFormat0.parseObject(""gh9~[{+lL"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed object.
 * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)
 */"
"public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}","public void test1318() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    ParsePosition parsePosition0 = new ParsePosition((-3316));
    // Undeclared exception!
    try {
        complexFormat0.parse("""", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */"
"public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
            // no sign
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}","public void test1419() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    ParsePosition parsePosition0 = new ParsePosition((-3226));
    // Undeclared exception!
    try {
        complexFormat0.parse((String) null, parsePosition0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */"
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test1520() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getCurrencyInstance();
    ComplexFormat complexFormat0 = new ComplexFormat(""&5%nG*9%D1/z|4?}@s"", numberFormat0, numberFormat0);
    // Undeclared exception!
    try {
        complexFormat0.parse((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
"public static ComplexFormat getInstance(Locale locale) {
    NumberFormat f = getDefaultNumberFormat(locale);
    return new ComplexFormat(f);
}","public void test1621() throws Throwable {
    // Undeclared exception!
    try {
        ComplexFormat.getInstance((Locale) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns the default complex format for the given locale.
 * @param locale the specific locale used by the format.
 * @return the complex format specific to the given locale.
 */"
"public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos) {
    pos.setBeginIndex(0);
    pos.setEndIndex(0);
    // format real
    double re = complex.getReal();
    formatDouble(re, getRealFormat(), toAppendTo, pos);
    // format sign and imaginary
    double im = complex.getImaginary();
    if (im < 0.0) {
        toAppendTo.append("" - "");
        formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);
        toAppendTo.append(getImaginaryCharacter());
    } else if (im > 0.0 || Double.isNaN(im)) {
        toAppendTo.append("" + "");
        formatDouble(im, getImaginaryFormat(), toAppendTo, pos);
        toAppendTo.append(getImaginaryCharacter());
    }
    return toAppendTo;
}","public void test1722() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    Complex complex0 = Complex.NaN;
    // Undeclared exception!
    try {
        complexFormat0.format(complex0, (StringBuffer) null, (FieldPosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Formats a {@link Complex} object to produce a string.
 *
 * @param complex the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 */"
"public StringBuffer format(Complex complex, StringBuffer toAppendTo, FieldPosition pos) {
    pos.setBeginIndex(0);
    pos.setEndIndex(0);
    // format real
    double re = complex.getReal();
    formatDouble(re, getRealFormat(), toAppendTo, pos);
    // format sign and imaginary
    double im = complex.getImaginary();
    if (im < 0.0) {
        toAppendTo.append("" - "");
        formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);
        toAppendTo.append(getImaginaryCharacter());
    } else if (im > 0.0 || Double.isNaN(im)) {
        toAppendTo.append("" + "");
        formatDouble(im, getImaginaryFormat(), toAppendTo, pos);
        toAppendTo.append(getImaginaryCharacter());
    }
    return toAppendTo;
}","public void test1823() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    ChoiceFormat choiceFormat0 = new ChoiceFormat(""h?WLEFGe0z"");
    Complex complex0 = new Complex(3136.2983512706714, 3136.2983512706714);
    StringBuffer stringBuffer0 = new StringBuffer();
    FieldPosition fieldPosition0 = new FieldPosition(0);
    complexFormat0.setImaginaryFormat(choiceFormat0);
    // Undeclared exception!
    try {
        complexFormat0.format(complex0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""java.text.ChoiceFormat"", e);
    }
}","/**
 * Formats a {@link Complex} object to produce a string.
 *
 * @param complex the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 */"
"public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    StringBuffer ret = null;
    if (obj instanceof Complex) {
        ret = format((Complex) obj, toAppendTo, pos);
    } else if (obj instanceof Number) {
        ret = format(new Complex(((Number) obj).doubleValue(), 0.0), toAppendTo, pos);
    } else {
        throw new IllegalArgumentException(""Cannot format given Object as a Date"");
    }
    return ret;
}","public void test1924() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Double double0 = new Double(1660.47863057913);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""O _^|oLX&p;8bwmno"");
    // Undeclared exception!
    try {
        complexFormat0.format((Object) double0, stringBuffer0, (FieldPosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Formats a object to produce a string.  <code>obj</code> must be either a
 * {@link Complex} object or a {@link Number} object.  Any other type of
 * object will result in an {@link IllegalArgumentException} being thrown.
 *
 * @param obj the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)
 * @throws IllegalArgumentException is <code>obj</code> is not a valid type.
 */"
"public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    StringBuffer ret = null;
    if (obj instanceof Complex) {
        ret = format((Complex) obj, toAppendTo, pos);
    } else if (obj instanceof Number) {
        ret = format(new Complex(((Number) obj).doubleValue(), 0.0), toAppendTo, pos);
    } else {
        throw new IllegalArgumentException(""Cannot format given Object as a Date"");
    }
    return ret;
}","public void test2025() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    Locale locale0 = Locale.JAPAN;
    StringBuffer stringBuffer0 = new StringBuffer();
    FieldPosition fieldPosition0 = new FieldPosition((Format.Field) null);
    // Undeclared exception!
    try {
        complexFormat0.format((Object) locale0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot format given Object as a Date
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Formats a object to produce a string.  <code>obj</code> must be either a
 * {@link Complex} object or a {@link Number} object.  Any other type of
 * object will result in an {@link IllegalArgumentException} being thrown.
 *
 * @param obj the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)
 * @throws IllegalArgumentException is <code>obj</code> is not a valid type.
 */"
"public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {
    this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);
}","public void test2126() throws Throwable {
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat((NumberFormat) null, (NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryFormat can not be null.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom number format for the real part and a
 * custom number format for the imaginary part.
 * @param realFormat the custom format for the real part.
 * @param imaginaryFormat the custom format for the imaginary part.
 */"
"public ComplexFormat(NumberFormat format) {
    this(DEFAULT_IMAGINARY_CHARACTER, format);
}","public void test2227() throws Throwable {
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat((NumberFormat) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom number format for both real and
 * imaginary parts.
 * @param format the custom format for both real and imaginary parts.
 */"
"public ComplexFormat(String imaginaryCharacter, NumberFormat format) {
    this(imaginaryCharacter, format, (NumberFormat) format.clone());
}","public void test2328() throws Throwable {
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat(""!e, 'qd$o6Ef/"", (NumberFormat) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom imaginary character, and a custom number
 * format for both real and imaginary parts.
 * @param imaginaryCharacter The custom imaginary character.
 * @param format the custom format for both real and imaginary parts.
 */"
"public ComplexFormat(String imaginaryCharacter, NumberFormat format) {
    this(imaginaryCharacter, format, (NumberFormat) format.clone());
}","public void test2429() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getCurrencyInstance();
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat("""", numberFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryCharacter must be a non-empty string.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom imaginary character, and a custom number
 * format for both real and imaginary parts.
 * @param imaginaryCharacter The custom imaginary character.
 * @param format the custom format for both real and imaginary parts.
 */"
"public ComplexFormat(String imaginaryCharacter) {
    this(imaginaryCharacter, getDefaultNumberFormat());
}","public void test2530() throws Throwable {
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryCharacter must be a non-empty string.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom imaginary character, and the default
 * number format for both real and imaginary parts.
 * @param imaginaryCharacter The custom imaginary character.
 */"
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test2631() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    complexFormat0.setImaginaryCharacter(""imaginaryFormat can not be null."");
    // Undeclared exception!
    try {
        complexFormat0.parse(""(Infinity) + (Infinity)i"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
"public double abs() {
    if (isNaN()) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (Math.abs(real) < Math.abs(imaginary)) {
        if (imaginary == 0.0) {
            return Math.abs(real);
        }
        double q = real / imaginary;
        return (Math.abs(imaginary) * Math.sqrt(1 + q * q));
    } else {
        if (real == 0.0) {
            return Math.abs(imaginary);
        }
        double q = imaginary / real;
        return (Math.abs(real) * Math.sqrt(1 + q * q));
    }
}","public void test2732() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    ParsePosition parsePosition0 = new ParsePosition(0);
    Complex complex0 = complexFormat0.parse(""0"", parsePosition0);
    assertEquals(0.0, complex0.abs(), 0.01);
}","/**
 * Return the absolute value of this complex number.
 * <p>
 * Returns <code>NaN</code> if either real or imaginary part is
 * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if
 * neither part is <code>NaN</code>, but at least one part takes an infinite
 * value.</p>
 *
 * @return the absolute value
 */"
"public String getImaginaryCharacter() {
    return imaginaryCharacter;
}","public void test3444() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    String string0 = complexFormat0.getImaginaryCharacter();
    assertEquals(""i"", string0);
}","/**
 * Access the imaginaryCharacter.
 * @return the imaginaryCharacter.
 */"
"public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat) {
    super();
    setImaginaryCharacter(imaginaryCharacter);
    setImaginaryFormat(imaginaryFormat);
    setRealFormat(realFormat);
}","public void test3545() throws Throwable {
    ComplexFormat complexFormat0 = null;
    try {
        complexFormat0 = new ComplexFormat(""org.apache.commons.math.complex.Complex"", (NumberFormat) null, (NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryFormat can not be null.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Create an instance with a custom imaginary character, a custom number
 * format for the real part, and a custom number format for the imaginary
 * part.
 * @param imaginaryCharacter The custom imaginary character.
 * @param realFormat the custom format for the real part.
 * @param imaginaryFormat the custom format for the imaginary part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test3646() throws Throwable {
    NumberFormat numberFormat0 = NumberFormat.getNumberInstance();
    ComplexFormat complexFormat0 = new ComplexFormat(""0"", numberFormat0);
    Complex complex0 = complexFormat0.parse(""0"");
    assertEquals(0.0, complex0.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part
 */"
"public NumberFormat getImaginaryFormat() {
    return imaginaryFormat;
}","public void test3747() throws Throwable {
    DecimalFormat decimalFormat0 = new DecimalFormat(""imaginaryFormat can not be null."");
    ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0);
    NumberFormat numberFormat0 = complexFormat0.getImaginaryFormat();
    assertNotSame(numberFormat0, decimalFormat0);
}","/**
 * Access the imaginaryFormat.
 * @return the imaginaryFormat.
 */"
"public void setRealFormat(NumberFormat realFormat) {
    if (realFormat == null) {
        throw new IllegalArgumentException(""realFormat can not be null."");
    }
    this.realFormat = realFormat;
}","public void test3848() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat(""Inexact result from rounding"");
    // Undeclared exception!
    try {
        complexFormat0.setRealFormat((NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // realFormat can not be null.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Modify the realFormat.
 * @param realFormat The new realFormat value.
 * @throws IllegalArgumentException if <code>realFormat</code> is
 *         <code>null</code>.
 */"
"public void setImaginaryFormat(NumberFormat imaginaryFormat) {
    if (imaginaryFormat == null) {
        throw new IllegalArgumentException(""imaginaryFormat can not be null."");
    }
    this.imaginaryFormat = imaginaryFormat;
}","public void test3949() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    // Undeclared exception!
    try {
        complexFormat0.setImaginaryFormat((NumberFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryFormat can not be null.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Modify the imaginaryFormat.
 * @param imaginaryFormat The new imaginaryFormat value.
 * @throws IllegalArgumentException if <code>imaginaryFormat</code> is
 *         <code>null</code>.
 */"
"public void setImaginaryCharacter(String imaginaryCharacter) {
    if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {
        throw new IllegalArgumentException(""imaginaryCharacter must be a non-empty string."");
    }
    this.imaginaryCharacter = imaginaryCharacter;
}","public void test4050() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    // Undeclared exception!
    try {
        complexFormat0.setImaginaryCharacter("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryCharacter must be a non-empty string.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Modify the imaginaryCharacter.
 * @param imaginaryCharacter The new imaginaryCharacter value.
 * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is
 *         <code>null</code> or an empty string.
 */"
"public void setImaginaryCharacter(String imaginaryCharacter) {
    if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {
        throw new IllegalArgumentException(""imaginaryCharacter must be a non-empty string."");
    }
    this.imaginaryCharacter = imaginaryCharacter;
}","public void test4151() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    ComplexFormat complexFormat0 = ComplexFormat.getInstance(locale0);
    // Undeclared exception!
    try {
        complexFormat0.setImaginaryCharacter((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // imaginaryCharacter must be a non-empty string.
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Modify the imaginaryCharacter.
 * @param imaginaryCharacter The new imaginaryCharacter value.
 * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is
 *         <code>null</code> or an empty string.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test4252() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    Complex complex0 = complexFormat0.parse(""(Infinity) + (Infinity)i"");
    assertEquals(Double.POSITIVE_INFINITY, complex0.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part
 */"
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test4454() throws Throwable {
    ComplexFormat complexFormat0 = ComplexFormat.getInstance();
    try {
        complexFormat0.parse(""30-5 v7n="");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Unparseable complex number: \""30-5 v7n=\""
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
"public static String formatComplex(Complex c) {
    return getInstance().format(c);
}","public void test4555() throws Throwable {
    Complex complex0 = Complex.INF;
    String string0 = ComplexFormat.formatComplex(complex0);
    assertEquals(""(Infinity) + (Infinity)i"", string0);
}","/**
 * This static method calls formatComplex() on a default instance of
 * ComplexFormat.
 *
 * @param c Complex object to format
 * @return A formatted number in the form ""Re(c) + Im(c)i""
 */"
"public static String formatComplex(Complex c) {
    return getInstance().format(c);
}","public void test4656() throws Throwable {
    // Undeclared exception!
    try {
        ComplexFormat.formatComplex((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot format given Object as a Date
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * This static method calls formatComplex() on a default instance of
 * ComplexFormat.
 *
 * @param c Complex object to format
 * @return A formatted number in the form ""Re(c) + Im(c)i""
 */"
"public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    StringBuffer ret = null;
    if (obj instanceof Complex) {
        ret = format((Complex) obj, toAppendTo, pos);
    } else if (obj instanceof Number) {
        ret = format(new Complex(((Number) obj).doubleValue(), 0.0), toAppendTo, pos);
    } else {
        throw new IllegalArgumentException(""Cannot format given Object as a Date"");
    }
    return ret;
}","public void test4961() throws Throwable {
    ChoiceFormat choiceFormat0 = new ChoiceFormat("""");
    ComplexFormat complexFormat0 = new ComplexFormat(choiceFormat0, choiceFormat0);
    Integer integer0 = new Integer(28);
    StringBuffer stringBuffer0 = new StringBuffer(""(-Infinity) + (Infinity)i"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 28);
    // Undeclared exception!
    try {
        complexFormat0.format((Object) integer0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""java.text.ChoiceFormat"", e);
    }
}","/**
 * Formats a object to produce a string.  <code>obj</code> must be either a
 * {@link Complex} object or a {@link Number} object.  Any other type of
 * object will result in an {@link IllegalArgumentException} being thrown.
 *
 * @param obj the object to format.
 * @param toAppendTo where the text is to be appended
 * @param pos On input: an alignment field, if desired. On output: the
 *            offsets of the alignment field
 * @return the value passed in as toAppendTo.
 * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)
 * @throws IllegalArgumentException is <code>obj</code> is not a valid type.
 */"
"public Complex parse(String source) throws ParseException {
    ParsePosition parsePosition = new ParsePosition(0);
    Complex result = parse(source, parsePosition);
    if (parsePosition.getIndex() == 0) {
        throw new ParseException(""Unparseable complex number: \"""" + source + ""\"""", parsePosition.getErrorIndex());
    }
    return result;
}","public void test5062() throws Throwable {
    ComplexFormat complexFormat0 = new ComplexFormat();
    try {
        complexFormat0.parse(""1+Bd[NGA]aV@tdN\""3"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Unparseable complex number: \""1+Bd[NGA]aV@tdN\""3\""
        //
        verifyException(""org.apache.commons.math.complex.ComplexFormat"", e);
    }
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @return the parsed {@link Complex} object.
 * @exception ParseException if the beginning of the specified string
 *            cannot be parsed.
 */"
