focal_method,test_prefix,docstring
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","public void test00() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(1426.485128383, 1426.485128383);
    simplexOptimizer0.doOptimize();
}","/**
 * {@inheritDoc}
 */"
"public SimplexOptimizer(double rel, double abs) {
    this(new SimpleValueChecker(rel, abs));
}","public void test11() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(1156.961, 1156.961);
}","/**
 * @param rel Relative threshold.
 * @param abs Absolute threshold.
 */"
"@Override
public PointValuePair optimize(OptimizationData... optData) {
    // Set up base class and perform computation.
    return super.optimize(optData);
}","public void test22() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(0.0, 0.0);
    simplexOptimizer0.optimize((OptimizationData[]) null);
}","/**
 * {@inheritDoc}
 *
 * @param optData Optimization data. In addition to those documented in
 * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])
 * MultivariateOptimizer}, this method will register the following data:
 * <ul>
 *  <li>{@link AbstractSimplex}</li>
 * </ul>
 * @return {@inheritDoc}
 */"
"@Override
protected void parseOptimizationData(OptimizationData... optData) {
    // Allow base class to register its own data.
    super.parseOptimizationData(optData);
    // The existing values (as set by the previous call) are reused if
    // not provided in the argument list.
    for (OptimizationData data : optData) {
        if (data instanceof AbstractSimplex) {
            simplex = (AbstractSimplex) data;
            // If more data must be parsed, this statement _must_ be
            // changed to ""continue"".
            break;
        }
    }
}","public void test33() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer((-1.1689405319304267), (-1.1689405319304267));
    OptimizationData[] optimizationDataArray0 = new OptimizationData[0];
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
}","/**
 * Scans the list of (required and optional) optimization data that
 * characterize the problem.
 *
 * @param optData Optimization data.
 * The following data will be looked for:
 * <ul>
 *  <li>{@link AbstractSimplex}</li>
 * </ul>
 */"
"@Override
protected void parseOptimizationData(OptimizationData... optData) {
    // Allow base class to register its own data.
    super.parseOptimizationData(optData);
    // The existing values (as set by the previous call) are reused if
    // not provided in the argument list.
    for (OptimizationData data : optData) {
        if (data instanceof AbstractSimplex) {
            simplex = (AbstractSimplex) data;
            // If more data must be parsed, this statement _must_ be
            // changed to ""continue"".
            break;
        }
    }
}","public void test44() throws Throwable {
    MultiDirectionalSimplex multiDirectionalSimplex0 = new MultiDirectionalSimplex(8);
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(8, 8);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[8];
    optimizationDataArray0[4] = (OptimizationData) multiDirectionalSimplex0;
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
}","/**
 * Scans the list of (required and optional) optimization data that
 * characterize the problem.
 *
 * @param optData Optimization data.
 * The following data will be looked for:
 * <ul>
 *  <li>{@link AbstractSimplex}</li>
 * </ul>
 */"
"@Override
protected void parseOptimizationData(OptimizationData... optData) {
    // Allow base class to register its own data.
    super.parseOptimizationData(optData);
    // The existing values (as set by the previous call) are reused if
    // not provided in the argument list.
    for (OptimizationData data : optData) {
        if (data instanceof AbstractSimplex) {
            simplex = (AbstractSimplex) data;
            // If more data must be parsed, this statement _must_ be
            // changed to ""continue"".
            break;
        }
    }
}","public void test55() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(90.4603367921, 90.4603367921);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[1];
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
}","/**
 * Scans the list of (required and optional) optimization data that
 * characterize the problem.
 *
 * @param optData Optimization data.
 * The following data will be looked for:
 * <ul>
 *  <li>{@link AbstractSimplex}</li>
 * </ul>
 */"
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","public void test66() throws Throwable {
    MultiDirectionalSimplex multiDirectionalSimplex0 = new MultiDirectionalSimplex(8);
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(8, 8);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[1];
    optimizationDataArray0[0] = (OptimizationData) multiDirectionalSimplex0;
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
    simplexOptimizer0.doOptimize();
}","/**
 * {@inheritDoc}
 */"
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","public void test77() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(1426.485128383, 1426.485128383);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 1426.485128383;
    doubleArray0[1] = 1426.485128383;
    MultiDirectionalSimplex multiDirectionalSimplex0 = new MultiDirectionalSimplex(doubleArray0, 1426.485128383, 1426.485128383);
    InitialGuess initialGuess0 = new InitialGuess(doubleArray0);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[5];
    optimizationDataArray0[1] = (OptimizationData) initialGuess0;
    optimizationDataArray0[3] = (OptimizationData) multiDirectionalSimplex0;
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
    simplexOptimizer0.doOptimize();
}","/**
 * {@inheritDoc}
 */"
"@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","public void test88() throws Throwable {
    SimplexOptimizer simplexOptimizer0 = new SimplexOptimizer(13, 13);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[2];
    SimpleBounds simpleBounds0 = SimpleBounds.unbounded(13);
    optimizationDataArray0[0] = (OptimizationData) simpleBounds0;
    MultiDirectionalSimplex multiDirectionalSimplex0 = new MultiDirectionalSimplex(13);
    optimizationDataArray0[1] = (OptimizationData) multiDirectionalSimplex0;
    simplexOptimizer0.parseOptimizationData(optimizationDataArray0);
    simplexOptimizer0.doOptimize();
}","/**
 * {@inheritDoc}
 */"
