focal_method,test_prefix,docstring
"@Override
public PointValuePair optimize(OptimizationData... optData) throws TooManyEvaluationsException {
    // Set up base class and perform computation.
    return super.optimize(optData);
}","public void test00() throws Throwable {
    NonLinearConjugateGradientOptimizer.Formula nonLinearConjugateGradientOptimizer_Formula0 = NonLinearConjugateGradientOptimizer.Formula.FLETCHER_REEVES;
    NonLinearConjugateGradientOptimizer nonLinearConjugateGradientOptimizer0 = new NonLinearConjugateGradientOptimizer(nonLinearConjugateGradientOptimizer_Formula0, (ConvergenceChecker<PointValuePair>) null);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[1];
    // Undeclared exception!
    try {
        nonLinearConjugateGradientOptimizer0.optimize(optimizationDataArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @param optData Optimization data. In addition to those documented in
 * {@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])
 * GradientMultivariateOptimizer}, this method will register the following data:
 * <ul>
 *  <li>{@link BracketingStep}</li>
 * </ul>
 * @return {@inheritDoc}
 * @throws TooManyEvaluationsException if the maximal number of
 * evaluations (of the objective function) is exceeded.
 */"
"public GoalType getGoalType() {
    return goal;
}","public void test11() throws Throwable {
    NonLinearConjugateGradientOptimizer.Formula nonLinearConjugateGradientOptimizer_Formula0 = NonLinearConjugateGradientOptimizer.Formula.FLETCHER_REEVES;
    SecantSolver secantSolver0 = new SecantSolver();
    NonLinearConjugateGradientOptimizer nonLinearConjugateGradientOptimizer0 = new NonLinearConjugateGradientOptimizer(nonLinearConjugateGradientOptimizer_Formula0, (ConvergenceChecker<PointValuePair>) null, secantSolver0);
    assertNull(nonLinearConjugateGradientOptimizer0.getGoalType());
}","/**
 * @return the optimization type.
 */"
"public GoalType getGoalType() {
    return goal;
}","public void test33() throws Throwable {
    NonLinearConjugateGradientOptimizer.Formula nonLinearConjugateGradientOptimizer_Formula0 = NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE;
    NonLinearConjugateGradientOptimizer nonLinearConjugateGradientOptimizer0 = new NonLinearConjugateGradientOptimizer(nonLinearConjugateGradientOptimizer_Formula0, (ConvergenceChecker<PointValuePair>) null);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[1];
    NonLinearConjugateGradientOptimizer.BracketingStep nonLinearConjugateGradientOptimizer_BracketingStep0 = new NonLinearConjugateGradientOptimizer.BracketingStep(0.0);
    optimizationDataArray0[0] = (OptimizationData) nonLinearConjugateGradientOptimizer_BracketingStep0;
    nonLinearConjugateGradientOptimizer0.parseOptimizationData(optimizationDataArray0);
    assertNull(nonLinearConjugateGradientOptimizer0.getGoalType());
}","/**
 * @return the optimization type.
 */"
"@Override
protected void parseOptimizationData(OptimizationData... optData) {
    // Allow base class to register its own data.
    super.parseOptimizationData(optData);
    // The existing values (as set by the previous call) are reused if
    // not provided in the argument list.
    for (OptimizationData data : optData) {
        if (data instanceof BracketingStep) {
            initialStep = ((BracketingStep) data).getBracketingStep();
            // If more data must be parsed, this statement _must_ be
            // changed to ""continue"".
            break;
        }
    }
    checkParameters();
}","public void test44() throws Throwable {
    NonLinearConjugateGradientOptimizer.Formula nonLinearConjugateGradientOptimizer_Formula0 = NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE;
    NonLinearConjugateGradientOptimizer nonLinearConjugateGradientOptimizer0 = new NonLinearConjugateGradientOptimizer(nonLinearConjugateGradientOptimizer_Formula0, (ConvergenceChecker<PointValuePair>) null);
    OptimizationData[] optimizationDataArray0 = new OptimizationData[1];
    SimpleBounds simpleBounds0 = SimpleBounds.unbounded(1262);
    optimizationDataArray0[0] = (OptimizationData) simpleBounds0;
    // Undeclared exception!
    try {
        nonLinearConjugateGradientOptimizer0.parseOptimizationData(optimizationDataArray0);
        fail(""Expecting exception: MathUnsupportedOperationException"");
    } catch (MathUnsupportedOperationException e) {
        //
        // constraint
        //
        verifyException(""org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer"", e);
    }
}","/**
 * Scans the list of (required and optional) optimization data that
 * characterize the problem.
 *
 * @param optData Optimization data.
 * The following data will be looked for:
 * <ul>
 *  <li>{@link BracketingStep}</li>
 * </ul>
 */"
