focal_method,test_prefix,docstring
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test0000() throws Throwable {
    float float0 = MathUtils.round(Float.NaN, 0, (int) (byte) 1);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test0011() throws Throwable {
    double double0 = MathUtils.scalb((-1.0), (-2590));
    assertEquals((-6.946121092140867E-164), double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test0022() throws Throwable {
    double double0 = MathUtils.nextAfter(4.9E-324, 4.9E-324);
    assertEquals(1.0E-323, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test0033() throws Throwable {
    double double0 = MathUtils.nextAfter(0, 0);
    assertEquals(4.9E-324, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}","public void test0044() throws Throwable {
    int int0 = MathUtils.lcm(471, 471);
    assertEquals(471, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test0055() throws Throwable {
    short short0 = MathUtils.indicator((short) 31);
    assertEquals((short) 1, short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test0066() throws Throwable {
    long long0 = MathUtils.indicator(0L);
    assertEquals(1L, long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test0077() throws Throwable {
    int int0 = MathUtils.indicator(4036);
    assertEquals(1, int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test0088() throws Throwable {
    double double0 = MathUtils.indicator((double) (byte) 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test0099() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) 98);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test01010() throws Throwable {
    int int0 = MathUtils.gcd(0, (-1));
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test01111() throws Throwable {
    double double0 = MathUtils.factorialDouble(21);
    assertEquals(5.109094217170942E19, double0, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test01212() throws Throwable {
    double double0 = MathUtils.factorialDouble((byte) 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}","public void test01313() throws Throwable {
    long long0 = MathUtils.factorial(20);
    assertEquals(2432902008176640000L, long0);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test01415() throws Throwable {
    double[] doubleArray0 = new double[10];
    double[] doubleArray1 = new double[4];
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray1);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test01524() throws Throwable {
    boolean boolean0 = MathUtils.equals(0.5, (-4.9E-324), 16.0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test01625() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) 0, (double) 1, 1.0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test01726() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(67, (-2573));
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test01827() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(0, 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test01928() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(37, 19);
    assertEquals(23.59528305955488, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test02029() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(0, 0);
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test02130() throws Throwable {
    long long0 = MathUtils.subAndCheck(0L, 2432902008176640000L);
    assertEquals((-2432902008176640000L), long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test02231() throws Throwable {
    long long0 = MathUtils.subAndCheck(0L, (-2632L));
    assertEquals(2632L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test02332() throws Throwable {
    long long0 = MathUtils.subAndCheck((long) 471, 758L);
    assertEquals((-287L), long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test02433() throws Throwable {
    int int0 = MathUtils.subAndCheck(0, 0);
    assertEquals(0, int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test02534() throws Throwable {
    int int0 = MathUtils.subAndCheck(298, 0);
    assertEquals(298, int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test02635() throws Throwable {
    double double0 = MathUtils.sinh(1.0);
    assertEquals(1.1752011936438016, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test02736() throws Throwable {
    double double0 = MathUtils.sinh((-3341.17189361));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test02837() throws Throwable {
    float float0 = MathUtils.round((-3058.408F), 5, 5);
    assertEquals((-3058.408F), float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test02938() throws Throwable {
    float float0 = MathUtils.round((-3058.408F), 1);
    assertEquals((-3058.4F), float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test03039() throws Throwable {
    double double0 = MathUtils.round(0.0, 1, (int) (byte) 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test03140() throws Throwable {
    double double0 = MathUtils.round(1772.907094093, 31, 5);
    assertEquals(1772.907094093, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test03241() throws Throwable {
    double double0 = MathUtils.round(0.0, 67);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test03342() throws Throwable {
    double double0 = MathUtils.round((-1780.47166578776), (int) (byte) 0);
    assertEquals((-1780.0), double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);
}","public void test03443() throws Throwable {
    double double0 = MathUtils.normalizeAngle(0.0, (byte) 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);
}","public void test03544() throws Throwable {
    double double0 = MathUtils.normalizeAngle((short) 1, 1511);
    assertEquals(1508.9644737231006, double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test03645() throws Throwable {
    double double0 = MathUtils.nextAfter((-4.9E-324), 1375.0);
    assertEquals(-0.0, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test03746() throws Throwable {
    int int0 = MathUtils.mulAndCheck(0, (-1656));
    assertEquals(0, int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test03847() throws Throwable {
    int int0 = MathUtils.mulAndCheck((int) (short) 10, 20);
    assertEquals(200, int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test03948() throws Throwable {
    double double0 = MathUtils.log(0.0, 758L);
    assertEquals(-0.0, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test04049() throws Throwable {
    double double0 = MathUtils.log(39916800L, 1183.3316670651523);
    assertEquals(0.4042946363416051, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static double log(double base, double x) {
    return Math.log(x) / Math.log(base);
}","public void test04150() throws Throwable {
    double double0 = MathUtils.log(1L, 0.0);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * <p>Returns the
 * <a href=""http://mathworld.wolfram.com/Logarithm.html"">logarithm</a>
 * for base <code>b</code> of <code>x</code>.
 * </p>
 * <p>Returns <code>NaN<code> if either argument is negative.  If
 * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.
 * If <code>base</code> is positive and <code>x</code> is 0,
 * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments
 * are 0, the result is <code>NaN</code>.</p>
 *
 * @param base the base of the logarithm, must be greater than 0
 * @param x argument, must be greater than 0
 * @return the value of the logarithm - the number y such that base^y = x.
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test04251() throws Throwable {
    int int0 = MathUtils.hash((double[]) null);
    assertEquals(0, int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test04352() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 963.140565;
    int int0 = MathUtils.hash(doubleArray0);
    assertArrayEquals(new double[] { 963.140565 }, doubleArray0, 0.01);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test04455() throws Throwable {
    int int0 = MathUtils.hash(0.0);
    assertEquals(0, int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test04556() throws Throwable {
    int int0 = MathUtils.hash((-1534.27614016));
    assertEquals(82544730, int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
"public static double cosh(double x) {
    return (Math.exp(x) + Math.exp(-x)) / 2.0;
}","public void test04657() throws Throwable {
    double double0 = MathUtils.cosh(0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"">
 * hyperbolic cosine</a> of x.
 *
 * @param x double value for which to find the hyperbolic cosine
 * @return hyperbolic cosine of x
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test04758() throws Throwable {
    long long0 = MathUtils.addAndCheck(0L, 0L);
    assertEquals(0L, long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test04859() throws Throwable {
    int int0 = MathUtils.addAndCheck(0, 0);
    assertEquals(0, int0);
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test04960() throws Throwable {
    int int0 = MathUtils.addAndCheck(964, (-1774));
    assertEquals((-810), int0);
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test05061() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round((double) 21, 0, 1072);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding mode
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test05162() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round((-1881.0), (-2144658010), 1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // BigInteger would overflow supported range
        //
        verifyException(""java.math.BigInteger"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}","public void test05263() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.lcm((-277), (-1074790400));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test05364() throws Throwable {
    // Undeclared exception!
    MathUtils.factorialLog(21316);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test05465() throws Throwable {
    double double0 = MathUtils.nextAfter(0, (-1032.258982));
    assertEquals((-4.9E-324), double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test05566() throws Throwable {
    double double0 = MathUtils.nextAfter(0L, 10.0);
    assertEquals(4.9E-324, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test05667() throws Throwable {
    double double0 = MathUtils.nextAfter(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test05768() throws Throwable {
    double double0 = MathUtils.nextAfter(Double.NaN, 0.0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test05869() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(6402373705728000L, 6402373705728000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test05970() throws Throwable {
    long long0 = MathUtils.mulAndCheck((long) (short) 1, (long) (byte) 1);
    assertEquals(1L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test06071() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-1133L), (-1133L));
    assertEquals(1283689L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test06172() throws Throwable {
    int int0 = MathUtils.mulAndCheck(1, (-654));
    assertEquals((-654), int0);
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test06273() throws Throwable {
    float float0 = MathUtils.indicator((-1247.0F));
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test06374() throws Throwable {
    float float0 = MathUtils.indicator(26.5108F);
    assertEquals(1.0F, float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test06475() throws Throwable {
    int int0 = MathUtils.gcd(5, 31);
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test06576() throws Throwable {
    int int0 = MathUtils.gcd((-3914), (-3914));
    assertEquals(3914, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test06677() throws Throwable {
    double double0 = MathUtils.factorialLog(899);
    assertEquals(5219.673120736014, double0, 0.01);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static boolean equals(double x, double y) {
    return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);
}","public void test06778() throws Throwable {
    boolean boolean0 = MathUtils.equals(Double.NaN, Double.NaN);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are NaN or neither is NaN and they are
 * equal
 *
 * @param x first value
 * @param y second value
 * @return true if the values are equal or both are NaN
 */"
"public static boolean equals(double x, double y) {
    return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);
}","public void test06879() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) 0, (double) 0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are NaN or neither is NaN and they are
 * equal
 *
 * @param x first value
 * @param y second value
 * @return true if the values are equal or both are NaN
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test06980() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1810, 16);
    assertEquals(89.2789654764673, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test07081() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(435, 17);
    assertEquals(1.4646012137912087E30, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test07182() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(1, (-1259));
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test07283() throws Throwable {
    int int0 = MathUtils.subAndCheck(5, 31);
    assertEquals((-26), int0);
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int subAndCheck(int x, int y) {
    long s = (long) x - (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: subtract"");
    }
    return (int) s;
}","public void test07384() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.subAndCheck((-1105), 2147483643);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: subtract
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Subtract two integers, checking for overflow.
 *
 * @param x the minuend
 * @param y the subtrahend
 * @return the difference <code>x-y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test07485() throws Throwable {
    short short0 = MathUtils.sign((short) (-1));
    assertEquals((short) (-1), short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test07586() throws Throwable {
    short short0 = MathUtils.sign((short) 0);
    assertEquals((short) 0, short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static short sign(final short x) {
    return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
}","public void test07687() throws Throwable {
    short short0 = MathUtils.sign((short) 705);
    assertEquals((short) 1, short0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for short value <code>x</code>.
 * <p>
 * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)
 * if x = 0, and (short)(-1) if x < 0.</p>
 *
 * @param x the value, a short
 * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of
 *         x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test07788() throws Throwable {
    long long0 = MathUtils.sign((-2147483648L));
    assertEquals((-1L), long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test07889() throws Throwable {
    long long0 = MathUtils.sign((long) (byte) 0);
    assertEquals(0L, long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static long sign(final long x) {
    return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
}","public void test07990() throws Throwable {
    long long0 = MathUtils.sign((long) (byte) 1);
    assertEquals(1L, long0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for long value <code>x</code>.
 * <p>
 * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and
 * -1L if x < 0.</p>
 *
 * @param x the value, a long
 * @return +1L, 0L, or -1L, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test08091() throws Throwable {
    int int0 = MathUtils.sign((-2671));
    assertEquals((-1), int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test08192() throws Throwable {
    int int0 = MathUtils.sign(0);
    assertEquals(0, int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static int sign(final int x) {
    return (x == 0) ? 0 : (x > 0) ? 1 : -1;
}","public void test08293() throws Throwable {
    int int0 = MathUtils.sign(4402);
    assertEquals(1, int0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for int value <code>x</code>.
 * <p>
 * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1
 * if x < 0.</p>
 *
 * @param x the value, an int
 * @return +1, 0, or -1, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test08394() throws Throwable {
    float float0 = MathUtils.sign(1474.0F);
    assertEquals(1.0F, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test08495() throws Throwable {
    float float0 = MathUtils.sign(0.0F);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test08596() throws Throwable {
    float float0 = MathUtils.sign(Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static float sign(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
}","public void test08697() throws Throwable {
    float float0 = MathUtils.sign((-3141.9634F));
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for float value <code>x</code>.
 * <p>
 * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =
 * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>
 * is <code>NaN</code>.</p>
 *
 * @param x the value, a float
 * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test08798() throws Throwable {
    double double0 = MathUtils.sign((-630.973542217));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test08899() throws Throwable {
    double double0 = MathUtils.sign(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test089100() throws Throwable {
    double double0 = MathUtils.sign(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static double sign(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
}","public void test090101() throws Throwable {
    double double0 = MathUtils.sign(69.6366507738);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for double precision <code>x</code>.
 * <p>
 * For a double value <code>x</code>, this method returns
 * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if
 * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.
 * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>
 *
 * @param x the value, a double
 * @return +1.0, 0.0, or -1.0, depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test091102() throws Throwable {
    byte byte0 = MathUtils.sign((byte) (-96));
    assertEquals((byte) (-1), byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test092103() throws Throwable {
    byte byte0 = MathUtils.sign((byte) 0);
    assertEquals((byte) 0, byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static byte sign(final byte x) {
    return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
}","public void test093104() throws Throwable {
    byte byte0 = MathUtils.sign((byte) 17);
    assertEquals((byte) 1, byte0);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/Sign.html""> sign</a>
 * for byte value <code>x</code>.
 * <p>
 * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if
 * x = 0, and (byte)(-1) if x < 0.</p>
 *
 * @param x the value, a byte
 * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test094105() throws Throwable {
    float float0 = MathUtils.round(1317.8057F, (int) (byte) 0);
    assertEquals(1318.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test095106() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.round((-1245.479F), (-885), 5319);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid rounding method.
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test096107() throws Throwable {
    float float0 = MathUtils.round((float) (byte) 1, (-2101), 2);
    assertEquals(Float.POSITIVE_INFINITY, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test097108() throws Throwable {
    float float0 = MathUtils.round(1398.7898F, 0, 0);
    assertEquals(1399.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test098109() throws Throwable {
    double double0 = MathUtils.round(Double.NEGATIVE_INFINITY, (-608), (-1377));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","public void test099110() throws Throwable {
    double double0 = MathUtils.round(Double.NaN, 684, 0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test100111() throws Throwable {
    double double0 = MathUtils.scalb(Double.NEGATIVE_INFINITY, 887);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test101112() throws Throwable {
    double double0 = MathUtils.scalb(Double.NaN, (-2087));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test102113() throws Throwable {
    double double0 = MathUtils.scalb(1714.3074792154, 1);
    assertEquals(3428.6149584308, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double scalb(final double d, final int scaleFactor) {
    // handling of some important special cases
    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    }
    // split the double in raw components
    final long bits = Double.doubleToLongBits(d);
    final long exponent = bits & 0x7ff0000000000000L;
    final long rest = bits & 0x800fffffffffffffL;
    // shift the exponent
    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
    return Double.longBitsToDouble(newBits);
}","public void test103114() throws Throwable {
    double double0 = MathUtils.scalb(0, 2973);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Scale a number by 2<sup>scaleFactor</sup>.
 * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param scaleFactor power of two by which d sould be multiplied
 * @return d &times; 2<sup>scaleFactor</sup>
 * @since 2.0
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test104115() throws Throwable {
    double double0 = MathUtils.nextAfter(1.0, (-201.6));
    assertEquals(0.9999999999999999, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test105116() throws Throwable {
    float float0 = MathUtils.round((float) (byte) 0, 0, 5);
    assertEquals(-0.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test106117() throws Throwable {
    float float0 = MathUtils.round(1474.0F, 3637, 5);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float round(float x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test107118() throws Throwable {
    float float0 = MathUtils.round(0.0F, 0);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test108119() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient(2855, 205);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test109120() throws Throwable {
    long long0 = MathUtils.mulAndCheck((long) 0, (long) 0);
    assertEquals(0L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test110121() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-2174L), 0L);
    assertEquals(0L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test111122() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck((-9218868437227405313L), (-465L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: multiply
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test112123() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-1L), (-785L));
    assertEquals(785L, long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long mulAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: multiply"";
    if (a > b) {
        // use symmetry to reduce boundary cases
        ret = mulAndCheck(b, a);
    } else {
        if (a < 0) {
            if (b < 0) {
                // check for positive overflow with negative a, negative b
                if (a >= Long.MAX_VALUE / b) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else if (b > 0) {
                // check for negative overflow with negative a, positive b
                if (Long.MIN_VALUE / b <= a) {
                    ret = a * b;
                } else {
                    throw new ArithmeticException(msg);
                }
            } else {
                // assert b == 0
                ret = 0;
            }
        } else if (a > 0) {
            // assert a > 0
            // assert b > 0
            // check for positive overflow with positive a, positive b
            if (a <= Long.MAX_VALUE / b) {
                ret = a * b;
            } else {
                throw new ArithmeticException(msg);
            }
        } else {
            // assert a == 0
            ret = 0;
        }
    }
    return ret;
}","public void test113124() throws Throwable {
    long long0 = MathUtils.mulAndCheck((-2403L), 1301L);
    assertEquals((-3126303L), long0);
}","/**
 * Multiply two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the product <code>a * b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test114125() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(1259, 2134043785);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int mulAndCheck(int x, int y) {
    long m = ((long) x) * ((long) y);
    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: mul"");
    }
    return (int) m;
}","public void test115126() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.mulAndCheck(2092419964, (-1429));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Multiply two integers, checking for overflow.
 *
 * @param x a factor
 * @param y a factor
 * @return the product <code>x*y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}","public void test116127() throws Throwable {
    int int0 = MathUtils.lcm(15, 0);
    assertEquals(0, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}","public void test117128() throws Throwable {
    int int0 = MathUtils.lcm(0, 0);
    assertEquals(0, int0);
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test118129() throws Throwable {
    short short0 = MathUtils.indicator((short) 0);
    assertEquals((short) 1, short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static short indicator(final short x) {
    return (x >= ZS) ? PS : NS;
}","public void test119130() throws Throwable {
    short short0 = MathUtils.indicator((short) (-1));
    assertEquals((short) (-1), short0);
}","/**
 * For a short value x, this method returns (short)(+1) if x >= 0 and
 * (short)(-1) if x < 0.
 *
 * @param x the value, a short
 * @return (short)(+1) or (short)(-1), depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test120131() throws Throwable {
    long long0 = MathUtils.indicator(1L);
    assertEquals(1L, long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static long indicator(final long x) {
    return (x >= 0L) ? 1L : -1L;
}","public void test121132() throws Throwable {
    long long0 = MathUtils.indicator((-1L));
    assertEquals((-1L), long0);
}","/**
 * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.
 *
 * @param x the value, a long
 * @return +1L or -1L, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test122133() throws Throwable {
    int int0 = MathUtils.indicator(0);
    assertEquals(1, int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static int indicator(final int x) {
    return (x >= 0) ? 1 : -1;
}","public void test123134() throws Throwable {
    int int0 = MathUtils.indicator((-880));
    assertEquals((-1), int0);
}","/**
 * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.
 *
 * @param x the value, an int
 * @return +1 or -1, depending on the sign of x
 */"
"public static float round(float x, int scale, int roundingMethod) {
    float sign = indicator(x);
    float factor = (float) Math.pow(10.0f, scale) * sign;
    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;
}","public void test124135() throws Throwable {
    float float0 = MathUtils.round((float) (short) (-1), (-3852), 7);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */"
"public static float indicator(final float x) {
    if (Float.isNaN(x)) {
        return Float.NaN;
    }
    return (x >= 0.0F) ? 1.0F : -1.0F;
}","public void test125136() throws Throwable {
    float float0 = MathUtils.indicator(Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <
 * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.
 *
 * @param x the value, a float
 * @return +1.0F or -1.0F, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test126137() throws Throwable {
    double double0 = MathUtils.indicator((double) (-1.0F));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test127138() throws Throwable {
    double double0 = MathUtils.indicator(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static double indicator(final double x) {
    if (Double.isNaN(x)) {
        return Double.NaN;
    }
    return (x >= 0.0) ? 1.0 : -1.0;
}","public void test128139() throws Throwable {
    double double0 = MathUtils.indicator(4.9E-324);
    assertEquals(1.0, double0, 0.01);
}","/**
 * For a double precision value x, this method returns +1.0 if x >= 0 and
 * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is
 * <code>NaN</code>.
 *
 * @param x the value, a double
 * @return +1.0 or -1.0, depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test129140() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) 0);
    assertEquals((byte) 1, byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static byte indicator(final byte x) {
    return (x >= ZB) ? PB : NB;
}","public void test130141() throws Throwable {
    byte byte0 = MathUtils.indicator((byte) (-101));
    assertEquals((byte) (-1), byte0);
}","/**
 * For a byte value x, this method returns (byte)(+1) if x >= 0 and
 * (byte)(-1) if x < 0.
 *
 * @param x the value, a byte
 * @return (byte)(+1) or (byte)(-1), depending on the sign of x
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test131142() throws Throwable {
    int int0 = MathUtils.gcd(272, (-2049));
    assertEquals(1, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test132143() throws Throwable {
    int int0 = MathUtils.gcd(6, (byte) 0);
    assertEquals(6, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","public void test133144() throws Throwable {
    int int0 = MathUtils.gcd(0, 0);
    assertEquals(0, int0);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test134145() throws Throwable {
    double double0 = MathUtils.factorialLog(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}","public void test135146() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorialLog((-2146904029));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n > 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test136147() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorialDouble((-1253));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","public void test137148() throws Throwable {
    double double0 = MathUtils.factorialDouble(668);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}","public void test138149() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorial(2649);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // factorial value is too large to fit in a long
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static long factorial(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}","public void test139150() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.factorial((-4128));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for n!
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test140151() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 3675.144998324021;
    double[] doubleArray1 = new double[4];
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test141152() throws Throwable {
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = new double[6];
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray1);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test142153() throws Throwable {
    boolean boolean0 = MathUtils.equals((double[]) null, (double[]) null);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test143154() throws Throwable {
    double[] doubleArray0 = new double[4];
    boolean boolean0 = MathUtils.equals(doubleArray0, (double[]) null);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test144155() throws Throwable {
    double[] doubleArray0 = new double[4];
    boolean boolean0 = MathUtils.equals((double[]) null, doubleArray0);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test145156() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) 0, (double) (-1), 1.0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test146157() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) (-34), 1918.67918793, 1.3164036458569648E64);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test147158() throws Throwable {
    boolean boolean0 = MathUtils.equals(2753.5, 0.0, 1676.0);
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test148159() throws Throwable {
    boolean boolean0 = MathUtils.equals((double) (short) 1, (double) (short) 14, (-4.9E-324));
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y, double eps) {
    return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));
}","public void test149160() throws Throwable {
    boolean boolean0 = MathUtils.equals(1.0, (double) 1L, (double) (byte) 0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are equal or within the range of allowed
 * error (inclusive).
 *
 * @param x first value
 * @param y second value
 * @param eps the amount of absolute error to allow
 * @return true if the values are equal or within range of each other
 */"
"public static boolean equals(double x, double y) {
    return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);
}","public void test150161() throws Throwable {
    boolean boolean0 = MathUtils.equals(Double.NaN, (-3526.0));
    assertFalse(boolean0);
}","/**
 * Returns true iff both arguments are NaN or neither is NaN and they are
 * equal
 *
 * @param x first value
 * @param y second value
 * @return true if the values are equal or both are NaN
 */"
"public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","public void test151162() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[1] = (double) Float.NaN;
    boolean boolean0 = MathUtils.equals(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * Returns true iff both arguments are null or have same dimensions
 * and all their elements are {@link #equals(double,double) equals}
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements
 * @since 1.2
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test152163() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(347, 272);
    assertEquals(178.168829537372, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test153164() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(1030, 964);
    assertEquals(242.2023600153521, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test154165() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(0, (-1));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test155166() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog((byte) 17, (byte) 1);
    assertEquals(2.833213344056216, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test156167() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog((short) 705, 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test157168() throws Throwable {
    double double0 = MathUtils.binomialCoefficientLog(0, (short) 0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test158169() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((byte) (-1), (byte) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    if (k > n / 2) {
        return binomialCoefficientLog(n, n - k);
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/(n-k)!
    for (int i = n - k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by k!
    for (int i = 2; i <= k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}","public void test159170() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientLog((-3349), 2860);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test160171() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(1265, 719);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test161172() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(668, 1);
    assertEquals(668.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test162173() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble(787, 0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test163174() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble((-1403), (-1403));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test164175() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficientDouble(0, 14);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}","public void test165176() throws Throwable {
    double double0 = MathUtils.binomialCoefficientDouble((short) 62, 27);
    assertEquals(2.79692573246309984E17, double0, 0.01);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test166177() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(381, 9);
    assertEquals(423855132163373625L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test167178() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(19, 13);
    assertEquals(27132L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test168179() throws Throwable {
    long long0 = MathUtils.binomialCoefficient((short) 14, 13);
    assertEquals(14L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test169180() throws Throwable {
    long long0 = MathUtils.binomialCoefficient((byte) 5, (byte) 1);
    assertEquals(5L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test170181() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-1513), (-2087));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= 0 for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test171182() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.binomialCoefficient((-1774), 933);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have n >= k for binomial coefficient (n,k)
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // For n > 61 but n <= 66, the result cannot overflow,
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // For n > 66, a result overflow might occur, so we check
        // the multiplication, taking care to not overflow
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}","public void test172183() throws Throwable {
    long long0 = MathUtils.binomialCoefficient(3197, 0);
    assertEquals(1L, long0);
}","/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */"
"public static long subAndCheck(long a, long b) {
    long ret;
    String msg = ""overflow: subtract"";
    if (b == Long.MIN_VALUE) {
        if (a < 0) {
            ret = a - b;
        } else {
            throw new ArithmeticException(msg);
        }
    } else {
        // use additive inverse
        ret = addAndCheck(a, -b, msg);
    }
    return ret;
}","public void test173184() throws Throwable {
    long long0 = MathUtils.subAndCheck((long) 19, (long) 19);
    assertEquals(0L, long0);
}","/**
 * Subtract two long integers, checking for overflow.
 *
 * @param a first value
 * @param b second value
 * @return the difference <code>a-b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test174185() throws Throwable {
    long long0 = MathUtils.addAndCheck((long) 721, (long) 1);
    assertEquals(722L, long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test175186() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.addAndCheck(Integer.MAX_VALUE, (int) (short) 1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: add
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test176187() throws Throwable {
    int int0 = MathUtils.addAndCheck(0, 1);
    assertEquals(1, int0);
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static int addAndCheck(int x, int y) {
    long s = (long) x + (long) y;
    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
        throw new ArithmeticException(""overflow: add"");
    }
    return (int) s;
}","public void test177188() throws Throwable {
    // Undeclared exception!
    try {
        MathUtils.addAndCheck((-2147483646), (-2147483646));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: add
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Add two integers, checking for overflow.
 *
 * @param x an addend
 * @param y an addend
 * @return the sum <code>x+y</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         int
 * @since 1.1
 */"
"public static double round(double x, int scale) {
    return round(x, scale, BigDecimal.ROUND_HALF_UP);
}","public void test178189() throws Throwable {
    double double0 = MathUtils.round(1772.907094093, 721);
    assertEquals(1772.907094093, double0, 0.01);
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @return the rounded value.
 * @since 1.1
 */"
"public static double normalizeAngle(double a, double center) {
    return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);
}","public void test179190() throws Throwable {
    double double0 = MathUtils.normalizeAngle((-5636.940604490026), 4.9E-324);
    assertEquals((-0.9233839499374881), double0, 0.01);
}","/**
 * Normalize an angle in a 2&pi wide interval around a center value.
 * <p>This method has three main uses:</p>
 * <ul>
 *   <li>normalize an angle between 0 and 2&pi;:<br/>
 *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
 *   <li>normalize an angle between -&pi; and +&pi;<br/>
 *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
 *   <li>compute the angle between two defining angular positions:<br>
 *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
 * </ul>
 * <p>Note that due to numerical accuracy and since &pi; cannot be represented
 * exactly, the result interval is <em>closed</em>, it cannot be half-closed
 * as would be more satisfactory in a purely mathematical view.</p>
 * @param a angle to normalize
 * @param center center of the desired 2&pi; interval for the result
 * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
 * @since 1.2
 */"
"public static double sinh(double x) {
    return (Math.exp(x) - Math.exp(-x)) / 2.0;
}","public void test180191() throws Throwable {
    double double0 = MathUtils.sinh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"">
 * hyperbolic sine</a> of x.
 *
 * @param x double value for which to find the hyperbolic sine
 * @return hyperbolic sine of x
 */"
"public static long addAndCheck(long a, long b) {
    return addAndCheck(a, b, ""overflow: add"");
}","public void test181192() throws Throwable {
    long long0 = MathUtils.addAndCheck((-2147483648L), (-1L));
    assertEquals((-2147483649L), long0);
}","/**
 * Add two long integers, checking for overflow.
 *
 * @param a an addend
 * @param b an addend
 * @return the sum <code>a+b</code>
 * @throws ArithmeticException if the result can not be represented as an
 *         long
 * @since 1.2
 */"
"public static int hash(double[] value) {
    return Arrays.hashCode(value);
}","public void test182193() throws Throwable {
    double[] doubleArray0 = new double[5];
    int int0 = MathUtils.hash(doubleArray0);
    assertEquals(28629151, int0);
}","/**
 * Returns an integer hash code representing the given double array.
 *
 * @param value the value to be hashed (may be null)
 * @return the hash code
 * @since 1.2
 */"
"public static int hash(double value) {
    return new Double(value).hashCode();
}","public void test183194() throws Throwable {
    int int0 = MathUtils.hash((-2139.93606027));
    assertEquals((-2081809753), int0);
}","/**
 * Returns an integer hash code representing the given double value.
 *
 * @param value the value to be hashed
 * @return the hash code
 */"
