focal_method,test_prefix,docstring
"@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    while (true) {
        incrementIterationsCounter();
        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }
            return;
        }
        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept the contracted simplex
            // check convergence
            return;
        }
    }
}","public void test00() throws Throwable {
    MultiDirectional multiDirectional0 = new MultiDirectional(0.0, 1.1102230246251565E-14);
    multiDirectional0.setMaxIterations((-2143));
    try {
        multiDirectional0.iterateSimplex((Comparator<RealPointValuePair>) null);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: Maximal number of iterations (-2,143) exceeded
        //
        verifyException(""org.apache.commons.math.optimization.direct.DirectSearchOptimizer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    while (true) {
        incrementIterationsCounter();
        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }
            return;
        }
        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept the contracted simplex
            // check convergence
            return;
        }
    }
}","public void test11() throws Throwable {
    MultiDirectional multiDirectional0 = new MultiDirectional();
    RealPointValuePair[] realPointValuePairArray0 = new RealPointValuePair[1];
    double[] doubleArray0 = new double[2];
    RealPointValuePair realPointValuePair0 = new RealPointValuePair(doubleArray0, (-4225.05309));
    realPointValuePairArray0[0] = realPointValuePair0;
    multiDirectional0.simplex = realPointValuePairArray0;
    Comparator<RealPointValuePair> comparator0 = (Comparator<RealPointValuePair>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        multiDirectional0.iterateSimplex(comparator0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"public RealPointValuePair optimize(final MultivariateRealFunction f, final GoalType goalType, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (startConfiguration == null) {
        // no initial configuration has been set up for simplex
        // build a default one from a unit hypercube
        final double[] unit = new double[startPoint.length];
        Arrays.fill(unit, 1.0);
        setStartConfiguration(unit);
    }
    this.f = f;
    final Comparator<RealPointValuePair> comparator = new Comparator<RealPointValuePair>() {

        public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return (goalType == GoalType.MINIMIZE) ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // initialize search
    iterations = 0;
    evaluations = 0;
    buildSimplex(startPoint);
    evaluateSimplex(comparator);
    RealPointValuePair[] previous = new RealPointValuePair[simplex.length];
    while (true) {
        if (iterations > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.length; ++i) {
                converged &= checker.converged(iterations, previous[i], simplex[i]);
            }
            if (converged) {
                // we have found an optimum
                return simplex[0];
            }
        }
        // we still need to search
        System.arraycopy(simplex, 0, previous, 0, simplex.length);
        iterateSimplex(comparator);
    }
}","public void test22() throws Throwable {
    MultiDirectional multiDirectional0 = new MultiDirectional();
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 306;
    MultivariateVectorialFunction multivariateVectorialFunction0 = mock(MultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0).when(multivariateVectorialFunction0).value(any(double[].class));
    LeastSquaresConverter leastSquaresConverter0 = new LeastSquaresConverter(multivariateVectorialFunction0, doubleArray0);
    GoalType goalType0 = GoalType.MAXIMIZE;
    // Undeclared exception!
    multiDirectional0.optimize(leastSquaresConverter0, goalType0, doubleArray0);
}","/**
 * {@inheritDoc}
 */"
"@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    while (true) {
        incrementIterationsCounter();
        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }
            return;
        }
        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept the contracted simplex
            // check convergence
            return;
        }
    }
}","public void test33() throws Throwable {
    MultiDirectional multiDirectional0 = new MultiDirectional((-163.956534124), (-163.956534124));
    Comparator<RealPointValuePair> comparator0 = (Comparator<RealPointValuePair>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        multiDirectional0.iterateSimplex(comparator0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.optimization.direct.MultiDirectional"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public RealPointValuePair optimize(final MultivariateRealFunction f, final GoalType goalType, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    if (startConfiguration == null) {
        // no initial configuration has been set up for simplex
        // build a default one from a unit hypercube
        final double[] unit = new double[startPoint.length];
        Arrays.fill(unit, 1.0);
        setStartConfiguration(unit);
    }
    this.f = f;
    final Comparator<RealPointValuePair> comparator = new Comparator<RealPointValuePair>() {

        public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return (goalType == GoalType.MINIMIZE) ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // initialize search
    iterations = 0;
    evaluations = 0;
    buildSimplex(startPoint);
    evaluateSimplex(comparator);
    RealPointValuePair[] previous = new RealPointValuePair[simplex.length];
    while (true) {
        if (iterations > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.length; ++i) {
                converged &= checker.converged(iterations, previous[i], simplex[i]);
            }
            if (converged) {
                // we have found an optimum
                return simplex[0];
            }
        }
        // we still need to search
        System.arraycopy(simplex, 0, previous, 0, simplex.length);
        iterateSimplex(comparator);
    }
}","public void test44() throws Throwable {
    MultiDirectional multiDirectional0 = new MultiDirectional();
    double[] doubleArray0 = new double[5];
    MultivariateVectorialFunction multivariateVectorialFunction0 = mock(MultivariateVectorialFunction.class, new ViolatedAssumptionAnswer());
    doReturn((Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray0).when(multivariateVectorialFunction0).value(any(double[].class));
    LeastSquaresConverter leastSquaresConverter0 = new LeastSquaresConverter(multivariateVectorialFunction0, doubleArray0);
    GoalType goalType0 = GoalType.MAXIMIZE;
    // Undeclared exception!
    multiDirectional0.optimize(leastSquaresConverter0, goalType0, doubleArray0);
}","/**
 * {@inheritDoc}
 */"
