focal_method,test_prefix,docstring
"public OpenMapRealVector append(double d) {
    OpenMapRealVector res = new OpenMapRealVector(this, 1);
    res.setEntry(virtualSize, d);
    return res;
}","public void test000() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-901), (-901));
    // Undeclared exception!
    try {
        openMapRealVector0.append(1.0E-12);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-901)
        //
        verifyException(""org.apache.commons.math.linear.AbstractRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test011() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    double[] doubleArray0 = openMapRealVector0.toArray();
    assertEquals(0, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double[] toArray() {
    return getData();
}","public void test012() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    double[] doubleArray0 = openMapRealVector0.toArray();
    assertEquals(0, doubleArray0.length);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test023() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    assertEquals(2, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getL1Distance(double[] v) {
    checkVectorDimensions(v.length);
    double max = 0;
    for (int i = 0; i < v.length; i++) {
        double delta = FastMath.abs(getEntry(i) - v[i]);
        max += delta;
    }
    return max;
}","public void test024() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    double double0 = openMapRealVector0.getL1Distance(doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test025() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    double double0 = openMapRealVector0.getL1Distance(doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test036() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, 159);
    double double0 = openMapRealVector0.getSparsity();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    setSubVector(index, v.getData());
}","public void test047() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-457.556));
    // Undeclared exception!
    try {
        openMapRealVector0.setSubVector(2145163657, (RealVector) openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,145,163,657)
        //
        verifyException(""org.apache.commons.math.linear.AbstractRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test058() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-181.396));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.projection(doubleArray0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test059() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-181.396));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.projection(doubleArray0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test0610() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.mapMultiply((-500.9359379458425));
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0611() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.mapMultiply((-500.9359379458425));
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0712() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    openMapRealVector0.dotProduct(doubleArray0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test0914() throws Throwable {
    Double[] doubleArray0 = new Double[2];
    doubleArray0[0] = (Double) 854.7044674360784;
    doubleArray0[1] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1015() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    openMapRealVector0.add((RealVector) arrayRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1116() throws Throwable {
    double[] doubleArray0 = new double[8];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.0941672164758));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0E-12);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertTrue(openMapRealVector2.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1117() throws Throwable {
    double[] doubleArray0 = new double[8];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.0941672164758));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0E-12);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertEquals(1.0, openMapRealVector2.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public OpenMapRealVector add(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean copyThis = entries.size() > v.entries.size();
    OpenMapRealVector res = copyThis ? this.copy() : v.copy();
    Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();
    OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (randomAccess.containsKey(key)) {
            res.setEntry(key, randomAccess.get(key) + iter.value());
        } else {
            res.setEntry(key, iter.value());
        }
    }
    return res;
}","public void test1118() throws Throwable {
    double[] doubleArray0 = new double[8];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.0941672164758));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0E-12);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    assertNotSame(openMapRealVector2, openMapRealVector0);
}","/**
 * Optimized method to add two OpenMapRealVectors.
 * It copies the larger vector, then iterates over the smaller.
 *
 * @param v Vector to add.
 * @return the sum of {@code this} and {@code v}.
 * @throws org.apache.commons.math.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1219() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    Double[] doubleArray1 = new Double[2];
    doubleArray1[0] = (Double) 854.7044674360784;
    doubleArray1[1] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1, 15.0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    assertEquals(1.0, openMapRealVector2.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1220() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    Double[] doubleArray1 = new Double[2];
    doubleArray1[0] = (Double) 854.7044674360784;
    doubleArray1[1] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1, 15.0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1221() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    Double[] doubleArray1 = new Double[2];
    doubleArray1[0] = (Double) 854.7044674360784;
    doubleArray1[1] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1, 15.0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    assertEquals(0.5, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1322() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 36.372181253585396;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) openMapRealVector0);
    assertEquals(0.5, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public int getDimension() {
    return virtualSize;
}","public void test1323() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 36.372181253585396;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) openMapRealVector0);
    assertEquals(4, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1424() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1425() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public OpenMapRealVector append(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return append((OpenMapRealVector) v);
    }
    return append(v.getData());
}","public void test1426() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public int getDimension() {
    return virtualSize;
}","public void test1527() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(doubleArray0);
    assertEquals(2, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1528() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(doubleArray0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double dotProduct(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test1629() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector1.dotProduct(openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * It iterates over the smallest of the two.
 *
 * @param v Cector to compute the dot product with.
 * @return the dot product of {@code this} and {@code v}.
 * @throws org.apache.commons.math.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1630() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector1.dotProduct(openMapRealVector0);
    assertEquals(0.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1631() throws Throwable {
    double[] doubleArray0 = new double[20];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    double double0 = openMapRealVector1.dotProduct(openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double dotProduct(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test1732() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.70730381676447));
    double double0 = openMapRealVector0.dotProduct(openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * It iterates over the smallest of the two.
 *
 * @param v Cector to compute the dot product with.
 * @return the dot product of {@code this} and {@code v}.
 * @throws org.apache.commons.math.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1733() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.70730381676447));
    double double0 = openMapRealVector0.dotProduct(openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test1834() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide((RealVector) openMapRealVector0);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","public void test1835() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide((RealVector) openMapRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1836() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1937() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    openMapRealVector1.set(730519.7266551905);
    openMapRealVector0.subtract(openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test1938() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    openMapRealVector1.set(730519.7266551905);
    openMapRealVector0.subtract(openMapRealVector1);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2039() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 840.3684411499372;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    assertEquals(0.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2040() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = 840.3684411499372;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(doubleArray0);
    assertEquals(0.5, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2141() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) arrayRealVector0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}","public void test2142() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) arrayRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2143() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply((RealVector) arrayRealVector0);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test2244() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}","public void test2245() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2246() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(doubleArray0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2347() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(1, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2348() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(0.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2349() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(1, 1);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2450() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(0, 1);
    assertEquals(0.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2451() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(0, 1);
    assertEquals(0.5, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2452() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.getSubVector(0, 1);
    assertEquals(1, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double[] getData() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test2553() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    double[] doubleArray1 = openMapRealVector0.getData();
    assertArrayEquals(new double[] { 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2554() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    double[] doubleArray1 = openMapRealVector0.getData();
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    }
    return getDistance(v.getData());
}","public void test2655() throws Throwable {
    double[] doubleArray0 = new double[5];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.70730381676447));
    double double0 = openMapRealVector0.getDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2656() throws Throwable {
    double[] doubleArray0 = new double[5];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.70730381676447));
    double double0 = openMapRealVector0.getDistance((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test2757() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector();
    double double0 = openMapRealVector1.getDistance(openMapRealVector0);
    assertEquals(3929.1537256768156, double0, 0.01);
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test2758() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(249, 249);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector();
    double double0 = openMapRealVector1.getDistance(openMapRealVector0);
    assertEquals(0, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2859() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    double double0 = openMapRealVector0.getDistance((RealVector) arrayRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    }
    return getDistance(v.getData());
}","public void test2860() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    double double0 = openMapRealVector0.getDistance((RealVector) arrayRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2961() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-499.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector();
    double double0 = openMapRealVector1.getL1Distance(openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test2962() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-499.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector();
    double double0 = openMapRealVector1.getL1Distance(openMapRealVector0);
    assertEquals(Double.NaN, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getL1Distance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));
        max += delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            double delta = FastMath.abs(iter.value());
            max += FastMath.abs(delta);
        }
    }
    return max;
}","public void test2963() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-499.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector();
    double double0 = openMapRealVector1.getL1Distance(openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Distance between two vectors.
 * This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * elements differences.
 *
 * @param v Vector to which distance is requested.
 * @return distance between this vector and {@code v}.
 */"
"@Override
public double getL1Distance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    }
    return getL1Distance(v.getData());
}","public void test3064() throws Throwable {
    ArrayRealVector arrayRealVector0 = new ArrayRealVector();
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    double double0 = openMapRealVector0.getL1Distance((RealVector) arrayRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getL1Distance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    }
    return getL1Distance(v.getData());
}","public void test3165() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    double double0 = openMapRealVector0.getL1Distance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3166() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    double double0 = openMapRealVector0.getL1Distance((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3267() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-310.5358554));
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3268() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-310.5358554));
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public int getDimension() {
    return virtualSize;
}","public void test3369() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(1753, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3370() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3371() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    double double0 = openMapRealVector1.getLInfDistance((RealVector) openMapRealVector0);
    assertEquals(1753.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3472() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(openMapRealVector0);
    openMapRealVector1.set(806.3884);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test3473() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(openMapRealVector0);
    openMapRealVector1.set(806.3884);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3474() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(openMapRealVector0);
    openMapRealVector1.set(806.3884);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) openMapRealVector1);
    assertEquals(806.3884, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3575() throws Throwable {
    double[] doubleArray0 = new double[2];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, false);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) arrayRealVector0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    }
    return getLInfDistance(v.getData());
}","public void test3576() throws Throwable {
    double[] doubleArray0 = new double[2];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, false);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    double double0 = openMapRealVector0.getLInfDistance((RealVector) arrayRealVector0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3677() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (-390.0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, false);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public double getLInfDistance(double[] v) {
    checkVectorDimensions(v.length);
    double max = 0;
    for (int i = 0; i < v.length; i++) {
        double delta = FastMath.abs(getEntry(i) - v[i]);
        if (delta > max) {
            max = delta;
        }
    }
    return max;
}","public void test3678() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (-390.0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, false);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    openMapRealVector0.unitize();
    double double0 = openMapRealVector0.getLInfDistance(doubleArray0);
    assertEquals(389.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3779() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 36.372181253585396;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertEquals(0.5, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test3780() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 36.372181253585396;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3881() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    openMapRealVector0.unitize();
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test3882() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    openMapRealVector0.unitize();
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test3983() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public boolean isInfinite() {
    boolean infiniteFound = false;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        final double value = iter.value();
        if (Double.isNaN(value)) {
            return false;
        }
        if (Double.isInfinite(value)) {
            infiniteFound = true;
        }
    }
    return infiniteFound;
}","public void test3984() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-500.9359379458425));
    Power power0 = new Power((-500.9359379458425));
    openMapRealVector0.mapToSelf(power0);
    boolean boolean0 = openMapRealVector0.isInfinite();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4085() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    boolean boolean0 = openMapRealVector0.isNaN();
    assertEquals(0.5, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public boolean isNaN() {
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        if (Double.isNaN(iter.value())) {
            return true;
        }
    }
    return false;
}","public void test4086() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 40.19140625);
    boolean boolean0 = openMapRealVector0.isNaN();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public boolean isNaN() {
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        if (Double.isNaN(iter.value())) {
            return true;
        }
    }
    return false;
}","public void test4187() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    openMapRealVector0.unitize();
    boolean boolean0 = openMapRealVector0.isNaN();
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4188() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    openMapRealVector0.unitize();
    boolean boolean0 = openMapRealVector0.isNaN();
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"int getColumnDimension();","public void test4289() throws Throwable {
    double[] doubleArray0 = new double[17];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(17, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4290() throws Throwable {
    double[] doubleArray0 = new double[17];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"int getRowDimension();","public void test4291() throws Throwable {
    double[] doubleArray0 = new double[17];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(17, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"int getRowDimension();","public void test4392() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(2, realMatrix0.getRowDimension());
}","/**
 * Returns the number of rows in the matrix.
 *
 * @return rowDimension
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4393() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"int getColumnDimension();","public void test4394() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    RealMatrix realMatrix0 = openMapRealVector0.outerProduct(doubleArray0);
    assertEquals(2, realMatrix0.getColumnDimension());
}","/**
 * Returns the number of columns in the matrix.
 *
 * @return columnDimension
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4495() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1736, (-1.0));
    double[] doubleArray0 = new double[2];
    openMapRealVector0.setSubVector(102, doubleArray0);
    assertEquals(0.001152073732718894, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public OpenMapRealVector subtract(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    }
    return subtract(v.getData());
}","public void test4596() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) openMapRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test4597() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) openMapRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test4598() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) openMapRealVector0);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public OpenMapRealVector subtract(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    }
    return subtract(v.getData());
}","public void test4699() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) arrayRealVector0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test46100() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-498.7073));
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract((RealVector) arrayRealVector0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test47101() throws Throwable {
    double[] doubleArray0 = new double[10];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 4.0E-12);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(doubleArray0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test47102() throws Throwable {
    double[] doubleArray0 = new double[10];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 4.0E-12);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(doubleArray0);
    assertTrue(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public OpenMapRealVector subtract(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    for (int i = 0; i < v.length; i++) {
        if (entries.containsKey(i)) {
            res.setEntry(i, entries.get(i) - v[i]);
        } else {
            res.setEntry(i, -v[i]);
        }
    }
    return res;
}","public void test47103() throws Throwable {
    double[] doubleArray0 = new double[10];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 4.0E-12);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(doubleArray0);
    assertNotSame(openMapRealVector1, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test47104() throws Throwable {
    double[] doubleArray0 = new double[10];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 4.0E-12);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(doubleArray0);
    assertEquals(0.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test48105() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    // Undeclared exception!
    try {
        openMapRealVector0.unitVector();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test49106() throws Throwable {
    double[] doubleArray0 = new double[1];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    openMapRealVector0.hashCode();
    assertEquals(1.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test50107() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test50108() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-497.689));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test51109() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1), (-1));
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector0);
    assertEquals(-0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test51110() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1), (-1));
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector0);
    assertTrue(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test52111() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    Object object0 = new Object();
    boolean boolean0 = openMapRealVector0.equals(object0);
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test52112() throws Throwable {
    double[] doubleArray0 = new double[2];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    Object object0 = new Object();
    boolean boolean0 = openMapRealVector0.equals(object0);
    assertEquals(0.0, openMapRealVector0.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test53113() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(1509);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test53114() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(1509);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test53115() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(1509);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1509, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test54116() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1753, 1753);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(arrayRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test54117() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1753, 1753);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(arrayRealVector0);
    boolean boolean0 = openMapRealVector1.equals(openMapRealVector0);
    assertEquals(1753, openMapRealVector0.getDimension());
}","/**
 * {@inheritDoc}
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test55118() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.add((RealVector) openMapRealVector0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(0.5, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test55119() throws Throwable {
    double[] doubleArray0 = new double[2];
    doubleArray0[1] = 854.7044674360784;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 36.372181253585396);
    OpenMapRealVector openMapRealVector1 = (OpenMapRealVector) openMapRealVector0.add((RealVector) openMapRealVector0);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public int getDimension() {
    return virtualSize;
}","public void test56120() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1753, openMapRealVector1.getDimension());
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test56121() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenMapRealVector)) {
        return false;
    }
    OpenMapRealVector other = (OpenMapRealVector) obj;
    if (virtualSize != other.virtualSize) {
        return false;
    }
    if (Double.doubleToLongBits(epsilon) != Double.doubleToLongBits(other.epsilon)) {
        return false;
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = other.getEntry(iter.key());
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {
            return false;
        }
    }
    iter = other.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        double test = iter.value();
        if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {
            return false;
        }
    }
    return true;
}","public void test56122() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertFalse(openMapRealVector1.equals((Object) openMapRealVector0));
}","/**
 * {@inheritDoc}
 * Implementation Note: This performs an exact comparison, and as a result
 * it is possible for {@code a.subtract(b}} to be the zero vector, while
 * {@code  a.equals(b) == false}.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test56123() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1753, 1753, 1753);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1753);
    boolean boolean0 = openMapRealVector0.equals(openMapRealVector1);
    assertEquals(1.0, openMapRealVector1.getSparsity(), 0.01);
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
